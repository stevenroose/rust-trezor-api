// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `messages-common.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct Success {
    // message fields
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Success {
    fn default() -> &'a Success {
        <Success as ::protobuf::Message>::default_instance()
    }
}

impl Success {
    pub fn new() -> Success {
        ::std::default::Default::default()
    }

    // optional string message = 1;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Success {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Success {
        Success::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &Success| { &m.message },
                    |m: &mut Success| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Success>(
                    "Success",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Success {
        static mut instance: ::protobuf::lazy::Lazy<Success> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Success,
        };
        unsafe {
            instance.get(Success::new)
        }
    }
}

impl ::protobuf::Clear for Success {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Success {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Success {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Failure {
    // message fields
    code: ::std::option::Option<Failure_FailureType>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Failure {
    fn default() -> &'a Failure {
        <Failure as ::protobuf::Message>::default_instance()
    }
}

impl Failure {
    pub fn new() -> Failure {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.common.Failure.FailureType code = 1;


    pub fn get_code(&self) -> Failure_FailureType {
        self.code.unwrap_or(Failure_FailureType::Failure_UnexpectedMessage)
    }
    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Failure_FailureType) {
        self.code = ::std::option::Option::Some(v);
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Failure {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.code {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.code {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Failure {
        Failure::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Failure_FailureType>>(
                    "code",
                    |m: &Failure| { &m.code },
                    |m: &mut Failure| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &Failure| { &m.message },
                    |m: &mut Failure| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Failure>(
                    "Failure",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Failure {
        static mut instance: ::protobuf::lazy::Lazy<Failure> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Failure,
        };
        unsafe {
            instance.get(Failure::new)
        }
    }
}

impl ::protobuf::Clear for Failure {
    fn clear(&mut self) {
        self.code = ::std::option::Option::None;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Failure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Failure {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Failure_FailureType {
    Failure_UnexpectedMessage = 1,
    Failure_ButtonExpected = 2,
    Failure_DataError = 3,
    Failure_ActionCancelled = 4,
    Failure_PinExpected = 5,
    Failure_PinCancelled = 6,
    Failure_PinInvalid = 7,
    Failure_InvalidSignature = 8,
    Failure_ProcessError = 9,
    Failure_NotEnoughFunds = 10,
    Failure_NotInitialized = 11,
    Failure_PinMismatch = 12,
    Failure_FirmwareError = 99,
}

impl ::protobuf::ProtobufEnum for Failure_FailureType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Failure_FailureType> {
        match value {
            1 => ::std::option::Option::Some(Failure_FailureType::Failure_UnexpectedMessage),
            2 => ::std::option::Option::Some(Failure_FailureType::Failure_ButtonExpected),
            3 => ::std::option::Option::Some(Failure_FailureType::Failure_DataError),
            4 => ::std::option::Option::Some(Failure_FailureType::Failure_ActionCancelled),
            5 => ::std::option::Option::Some(Failure_FailureType::Failure_PinExpected),
            6 => ::std::option::Option::Some(Failure_FailureType::Failure_PinCancelled),
            7 => ::std::option::Option::Some(Failure_FailureType::Failure_PinInvalid),
            8 => ::std::option::Option::Some(Failure_FailureType::Failure_InvalidSignature),
            9 => ::std::option::Option::Some(Failure_FailureType::Failure_ProcessError),
            10 => ::std::option::Option::Some(Failure_FailureType::Failure_NotEnoughFunds),
            11 => ::std::option::Option::Some(Failure_FailureType::Failure_NotInitialized),
            12 => ::std::option::Option::Some(Failure_FailureType::Failure_PinMismatch),
            99 => ::std::option::Option::Some(Failure_FailureType::Failure_FirmwareError),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Failure_FailureType] = &[
            Failure_FailureType::Failure_UnexpectedMessage,
            Failure_FailureType::Failure_ButtonExpected,
            Failure_FailureType::Failure_DataError,
            Failure_FailureType::Failure_ActionCancelled,
            Failure_FailureType::Failure_PinExpected,
            Failure_FailureType::Failure_PinCancelled,
            Failure_FailureType::Failure_PinInvalid,
            Failure_FailureType::Failure_InvalidSignature,
            Failure_FailureType::Failure_ProcessError,
            Failure_FailureType::Failure_NotEnoughFunds,
            Failure_FailureType::Failure_NotInitialized,
            Failure_FailureType::Failure_PinMismatch,
            Failure_FailureType::Failure_FirmwareError,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Failure_FailureType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Failure_FailureType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Failure_FailureType {
    fn default() -> Self {
        Failure_FailureType::Failure_UnexpectedMessage
    }
}

impl ::protobuf::reflect::ProtobufValue for Failure_FailureType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ButtonRequest {
    // message fields
    code: ::std::option::Option<ButtonRequest_ButtonRequestType>,
    data: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ButtonRequest {
    fn default() -> &'a ButtonRequest {
        <ButtonRequest as ::protobuf::Message>::default_instance()
    }
}

impl ButtonRequest {
    pub fn new() -> ButtonRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.common.ButtonRequest.ButtonRequestType code = 1;


    pub fn get_code(&self) -> ButtonRequest_ButtonRequestType {
        self.code.unwrap_or(ButtonRequest_ButtonRequestType::ButtonRequest_Other)
    }
    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ButtonRequest_ButtonRequestType) {
        self.code = ::std::option::Option::Some(v);
    }

    // optional string data = 2;


    pub fn get_data(&self) -> &str {
        match self.data.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::string::String) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::string::String {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::string::String {
        self.data.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ButtonRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.code {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.code {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ButtonRequest {
        ButtonRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ButtonRequest_ButtonRequestType>>(
                    "code",
                    |m: &ButtonRequest| { &m.code },
                    |m: &mut ButtonRequest| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "data",
                    |m: &ButtonRequest| { &m.data },
                    |m: &mut ButtonRequest| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ButtonRequest>(
                    "ButtonRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ButtonRequest {
        static mut instance: ::protobuf::lazy::Lazy<ButtonRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ButtonRequest,
        };
        unsafe {
            instance.get(ButtonRequest::new)
        }
    }
}

impl ::protobuf::Clear for ButtonRequest {
    fn clear(&mut self) {
        self.code = ::std::option::Option::None;
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ButtonRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ButtonRequest_ButtonRequestType {
    ButtonRequest_Other = 1,
    ButtonRequest_FeeOverThreshold = 2,
    ButtonRequest_ConfirmOutput = 3,
    ButtonRequest_ResetDevice = 4,
    ButtonRequest_ConfirmWord = 5,
    ButtonRequest_WipeDevice = 6,
    ButtonRequest_ProtectCall = 7,
    ButtonRequest_SignTx = 8,
    ButtonRequest_FirmwareCheck = 9,
    ButtonRequest_Address = 10,
    ButtonRequest_PublicKey = 11,
    ButtonRequest_MnemonicWordCount = 12,
    ButtonRequest_MnemonicInput = 13,
    ButtonRequest_PassphraseType = 14,
    ButtonRequest_UnknownDerivationPath = 15,
}

impl ::protobuf::ProtobufEnum for ButtonRequest_ButtonRequestType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ButtonRequest_ButtonRequestType> {
        match value {
            1 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_Other),
            2 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_FeeOverThreshold),
            3 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_ConfirmOutput),
            4 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_ResetDevice),
            5 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_ConfirmWord),
            6 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_WipeDevice),
            7 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_ProtectCall),
            8 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_SignTx),
            9 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_FirmwareCheck),
            10 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_Address),
            11 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_PublicKey),
            12 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_MnemonicWordCount),
            13 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_MnemonicInput),
            14 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_PassphraseType),
            15 => ::std::option::Option::Some(ButtonRequest_ButtonRequestType::ButtonRequest_UnknownDerivationPath),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ButtonRequest_ButtonRequestType] = &[
            ButtonRequest_ButtonRequestType::ButtonRequest_Other,
            ButtonRequest_ButtonRequestType::ButtonRequest_FeeOverThreshold,
            ButtonRequest_ButtonRequestType::ButtonRequest_ConfirmOutput,
            ButtonRequest_ButtonRequestType::ButtonRequest_ResetDevice,
            ButtonRequest_ButtonRequestType::ButtonRequest_ConfirmWord,
            ButtonRequest_ButtonRequestType::ButtonRequest_WipeDevice,
            ButtonRequest_ButtonRequestType::ButtonRequest_ProtectCall,
            ButtonRequest_ButtonRequestType::ButtonRequest_SignTx,
            ButtonRequest_ButtonRequestType::ButtonRequest_FirmwareCheck,
            ButtonRequest_ButtonRequestType::ButtonRequest_Address,
            ButtonRequest_ButtonRequestType::ButtonRequest_PublicKey,
            ButtonRequest_ButtonRequestType::ButtonRequest_MnemonicWordCount,
            ButtonRequest_ButtonRequestType::ButtonRequest_MnemonicInput,
            ButtonRequest_ButtonRequestType::ButtonRequest_PassphraseType,
            ButtonRequest_ButtonRequestType::ButtonRequest_UnknownDerivationPath,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ButtonRequest_ButtonRequestType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ButtonRequest_ButtonRequestType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ButtonRequest_ButtonRequestType {
    fn default() -> Self {
        ButtonRequest_ButtonRequestType::ButtonRequest_Other
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonRequest_ButtonRequestType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ButtonAck {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ButtonAck {
    fn default() -> &'a ButtonAck {
        <ButtonAck as ::protobuf::Message>::default_instance()
    }
}

impl ButtonAck {
    pub fn new() -> ButtonAck {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ButtonAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ButtonAck {
        ButtonAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ButtonAck>(
                    "ButtonAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ButtonAck {
        static mut instance: ::protobuf::lazy::Lazy<ButtonAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ButtonAck,
        };
        unsafe {
            instance.get(ButtonAck::new)
        }
    }
}

impl ::protobuf::Clear for ButtonAck {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ButtonAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PinMatrixRequest {
    // message fields
    field_type: ::std::option::Option<PinMatrixRequest_PinMatrixRequestType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PinMatrixRequest {
    fn default() -> &'a PinMatrixRequest {
        <PinMatrixRequest as ::protobuf::Message>::default_instance()
    }
}

impl PinMatrixRequest {
    pub fn new() -> PinMatrixRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.common.PinMatrixRequest.PinMatrixRequestType type = 1;


    pub fn get_field_type(&self) -> PinMatrixRequest_PinMatrixRequestType {
        self.field_type.unwrap_or(PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_Current)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PinMatrixRequest_PinMatrixRequestType) {
        self.field_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PinMatrixRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PinMatrixRequest {
        PinMatrixRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PinMatrixRequest_PinMatrixRequestType>>(
                    "type",
                    |m: &PinMatrixRequest| { &m.field_type },
                    |m: &mut PinMatrixRequest| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PinMatrixRequest>(
                    "PinMatrixRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PinMatrixRequest {
        static mut instance: ::protobuf::lazy::Lazy<PinMatrixRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PinMatrixRequest,
        };
        unsafe {
            instance.get(PinMatrixRequest::new)
        }
    }
}

impl ::protobuf::Clear for PinMatrixRequest {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PinMatrixRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PinMatrixRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PinMatrixRequest_PinMatrixRequestType {
    PinMatrixRequestType_Current = 1,
    PinMatrixRequestType_NewFirst = 2,
    PinMatrixRequestType_NewSecond = 3,
}

impl ::protobuf::ProtobufEnum for PinMatrixRequest_PinMatrixRequestType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PinMatrixRequest_PinMatrixRequestType> {
        match value {
            1 => ::std::option::Option::Some(PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_Current),
            2 => ::std::option::Option::Some(PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_NewFirst),
            3 => ::std::option::Option::Some(PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_NewSecond),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PinMatrixRequest_PinMatrixRequestType] = &[
            PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_Current,
            PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_NewFirst,
            PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_NewSecond,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PinMatrixRequest_PinMatrixRequestType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PinMatrixRequest_PinMatrixRequestType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for PinMatrixRequest_PinMatrixRequestType {
    fn default() -> Self {
        PinMatrixRequest_PinMatrixRequestType::PinMatrixRequestType_Current
    }
}

impl ::protobuf::reflect::ProtobufValue for PinMatrixRequest_PinMatrixRequestType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PinMatrixAck {
    // message fields
    pin: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PinMatrixAck {
    fn default() -> &'a PinMatrixAck {
        <PinMatrixAck as ::protobuf::Message>::default_instance()
    }
}

impl PinMatrixAck {
    pub fn new() -> PinMatrixAck {
        ::std::default::Default::default()
    }

    // required string pin = 1;


    pub fn get_pin(&self) -> &str {
        match self.pin.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pin(&mut self) {
        self.pin.clear();
    }

    pub fn has_pin(&self) -> bool {
        self.pin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin(&mut self, v: ::std::string::String) {
        self.pin = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pin(&mut self) -> &mut ::std::string::String {
        if self.pin.is_none() {
            self.pin.set_default();
        }
        self.pin.as_mut().unwrap()
    }

    // Take field
    pub fn take_pin(&mut self) -> ::std::string::String {
        self.pin.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PinMatrixAck {
    fn is_initialized(&self) -> bool {
        if self.pin.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pin)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pin.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pin.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PinMatrixAck {
        PinMatrixAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pin",
                    |m: &PinMatrixAck| { &m.pin },
                    |m: &mut PinMatrixAck| { &mut m.pin },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PinMatrixAck>(
                    "PinMatrixAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PinMatrixAck {
        static mut instance: ::protobuf::lazy::Lazy<PinMatrixAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PinMatrixAck,
        };
        unsafe {
            instance.get(PinMatrixAck::new)
        }
    }
}

impl ::protobuf::Clear for PinMatrixAck {
    fn clear(&mut self) {
        self.pin.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PinMatrixAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PinMatrixAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PassphraseRequest {
    // message fields
    on_device: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PassphraseRequest {
    fn default() -> &'a PassphraseRequest {
        <PassphraseRequest as ::protobuf::Message>::default_instance()
    }
}

impl PassphraseRequest {
    pub fn new() -> PassphraseRequest {
        ::std::default::Default::default()
    }

    // optional bool on_device = 1;


    pub fn get_on_device(&self) -> bool {
        self.on_device.unwrap_or(false)
    }
    pub fn clear_on_device(&mut self) {
        self.on_device = ::std::option::Option::None;
    }

    pub fn has_on_device(&self) -> bool {
        self.on_device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_on_device(&mut self, v: bool) {
        self.on_device = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PassphraseRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.on_device = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.on_device {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.on_device {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PassphraseRequest {
        PassphraseRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "on_device",
                    |m: &PassphraseRequest| { &m.on_device },
                    |m: &mut PassphraseRequest| { &mut m.on_device },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PassphraseRequest>(
                    "PassphraseRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PassphraseRequest {
        static mut instance: ::protobuf::lazy::Lazy<PassphraseRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PassphraseRequest,
        };
        unsafe {
            instance.get(PassphraseRequest::new)
        }
    }
}

impl ::protobuf::Clear for PassphraseRequest {
    fn clear(&mut self) {
        self.on_device = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PassphraseRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PassphraseRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PassphraseAck {
    // message fields
    passphrase: ::protobuf::SingularField<::std::string::String>,
    state: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PassphraseAck {
    fn default() -> &'a PassphraseAck {
        <PassphraseAck as ::protobuf::Message>::default_instance()
    }
}

impl PassphraseAck {
    pub fn new() -> PassphraseAck {
        ::std::default::Default::default()
    }

    // optional string passphrase = 1;


    pub fn get_passphrase(&self) -> &str {
        match self.passphrase.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_passphrase(&mut self) {
        self.passphrase.clear();
    }

    pub fn has_passphrase(&self) -> bool {
        self.passphrase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passphrase(&mut self, v: ::std::string::String) {
        self.passphrase = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_passphrase(&mut self) -> &mut ::std::string::String {
        if self.passphrase.is_none() {
            self.passphrase.set_default();
        }
        self.passphrase.as_mut().unwrap()
    }

    // Take field
    pub fn take_passphrase(&mut self) -> ::std::string::String {
        self.passphrase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes state = 2;


    pub fn get_state(&self) -> &[u8] {
        match self.state.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::vec::Vec<u8>) {
        self.state = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::vec::Vec<u8> {
        self.state.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PassphraseAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.passphrase)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.passphrase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.state.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.passphrase.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PassphraseAck {
        PassphraseAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "passphrase",
                    |m: &PassphraseAck| { &m.passphrase },
                    |m: &mut PassphraseAck| { &mut m.passphrase },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "state",
                    |m: &PassphraseAck| { &m.state },
                    |m: &mut PassphraseAck| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PassphraseAck>(
                    "PassphraseAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PassphraseAck {
        static mut instance: ::protobuf::lazy::Lazy<PassphraseAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PassphraseAck,
        };
        unsafe {
            instance.get(PassphraseAck::new)
        }
    }
}

impl ::protobuf::Clear for PassphraseAck {
    fn clear(&mut self) {
        self.passphrase.clear();
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PassphraseAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PassphraseAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PassphraseStateRequest {
    // message fields
    state: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PassphraseStateRequest {
    fn default() -> &'a PassphraseStateRequest {
        <PassphraseStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl PassphraseStateRequest {
    pub fn new() -> PassphraseStateRequest {
        ::std::default::Default::default()
    }

    // optional bytes state = 1;


    pub fn get_state(&self) -> &[u8] {
        match self.state.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::vec::Vec<u8>) {
        self.state = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::vec::Vec<u8> {
        self.state.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PassphraseStateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PassphraseStateRequest {
        PassphraseStateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "state",
                    |m: &PassphraseStateRequest| { &m.state },
                    |m: &mut PassphraseStateRequest| { &mut m.state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PassphraseStateRequest>(
                    "PassphraseStateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PassphraseStateRequest {
        static mut instance: ::protobuf::lazy::Lazy<PassphraseStateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PassphraseStateRequest,
        };
        unsafe {
            instance.get(PassphraseStateRequest::new)
        }
    }
}

impl ::protobuf::Clear for PassphraseStateRequest {
    fn clear(&mut self) {
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PassphraseStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PassphraseStateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PassphraseStateAck {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PassphraseStateAck {
    fn default() -> &'a PassphraseStateAck {
        <PassphraseStateAck as ::protobuf::Message>::default_instance()
    }
}

impl PassphraseStateAck {
    pub fn new() -> PassphraseStateAck {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PassphraseStateAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PassphraseStateAck {
        PassphraseStateAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<PassphraseStateAck>(
                    "PassphraseStateAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PassphraseStateAck {
        static mut instance: ::protobuf::lazy::Lazy<PassphraseStateAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PassphraseStateAck,
        };
        unsafe {
            instance.get(PassphraseStateAck::new)
        }
    }
}

impl ::protobuf::Clear for PassphraseStateAck {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PassphraseStateAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PassphraseStateAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HDNodeType {
    // message fields
    depth: ::std::option::Option<u32>,
    fingerprint: ::std::option::Option<u32>,
    child_num: ::std::option::Option<u32>,
    chain_code: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    private_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HDNodeType {
    fn default() -> &'a HDNodeType {
        <HDNodeType as ::protobuf::Message>::default_instance()
    }
}

impl HDNodeType {
    pub fn new() -> HDNodeType {
        ::std::default::Default::default()
    }

    // required uint32 depth = 1;


    pub fn get_depth(&self) -> u32 {
        self.depth.unwrap_or(0)
    }
    pub fn clear_depth(&mut self) {
        self.depth = ::std::option::Option::None;
    }

    pub fn has_depth(&self) -> bool {
        self.depth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depth(&mut self, v: u32) {
        self.depth = ::std::option::Option::Some(v);
    }

    // required uint32 fingerprint = 2;


    pub fn get_fingerprint(&self) -> u32 {
        self.fingerprint.unwrap_or(0)
    }
    pub fn clear_fingerprint(&mut self) {
        self.fingerprint = ::std::option::Option::None;
    }

    pub fn has_fingerprint(&self) -> bool {
        self.fingerprint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerprint(&mut self, v: u32) {
        self.fingerprint = ::std::option::Option::Some(v);
    }

    // required uint32 child_num = 3;


    pub fn get_child_num(&self) -> u32 {
        self.child_num.unwrap_or(0)
    }
    pub fn clear_child_num(&mut self) {
        self.child_num = ::std::option::Option::None;
    }

    pub fn has_child_num(&self) -> bool {
        self.child_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child_num(&mut self, v: u32) {
        self.child_num = ::std::option::Option::Some(v);
    }

    // required bytes chain_code = 4;


    pub fn get_chain_code(&self) -> &[u8] {
        match self.chain_code.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_chain_code(&mut self) {
        self.chain_code.clear();
    }

    pub fn has_chain_code(&self) -> bool {
        self.chain_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chain_code(&mut self, v: ::std::vec::Vec<u8>) {
        self.chain_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chain_code(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.chain_code.is_none() {
            self.chain_code.set_default();
        }
        self.chain_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_chain_code(&mut self) -> ::std::vec::Vec<u8> {
        self.chain_code.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes private_key = 5;


    pub fn get_private_key(&self) -> &[u8] {
        match self.private_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_private_key(&mut self) {
        self.private_key.clear();
    }

    pub fn has_private_key(&self) -> bool {
        self.private_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.private_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_private_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.private_key.is_none() {
            self.private_key.set_default();
        }
        self.private_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_private_key(&mut self) -> ::std::vec::Vec<u8> {
        self.private_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes public_key = 6;


    pub fn get_public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key.set_default();
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for HDNodeType {
    fn is_initialized(&self) -> bool {
        if self.depth.is_none() {
            return false;
        }
        if self.fingerprint.is_none() {
            return false;
        }
        if self.child_num.is_none() {
            return false;
        }
        if self.chain_code.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.depth = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.fingerprint = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.child_num = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.chain_code)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.private_key)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.depth {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fingerprint {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.child_num {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.chain_code.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.private_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.depth {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerprint {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.child_num {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.chain_code.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.private_key.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.public_key.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HDNodeType {
        HDNodeType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "depth",
                    |m: &HDNodeType| { &m.depth },
                    |m: &mut HDNodeType| { &mut m.depth },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "fingerprint",
                    |m: &HDNodeType| { &m.fingerprint },
                    |m: &mut HDNodeType| { &mut m.fingerprint },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "child_num",
                    |m: &HDNodeType| { &m.child_num },
                    |m: &mut HDNodeType| { &mut m.child_num },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "chain_code",
                    |m: &HDNodeType| { &m.chain_code },
                    |m: &mut HDNodeType| { &mut m.chain_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "private_key",
                    |m: &HDNodeType| { &m.private_key },
                    |m: &mut HDNodeType| { &mut m.private_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "public_key",
                    |m: &HDNodeType| { &m.public_key },
                    |m: &mut HDNodeType| { &mut m.public_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HDNodeType>(
                    "HDNodeType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HDNodeType {
        static mut instance: ::protobuf::lazy::Lazy<HDNodeType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HDNodeType,
        };
        unsafe {
            instance.get(HDNodeType::new)
        }
    }
}

impl ::protobuf::Clear for HDNodeType {
    fn clear(&mut self) {
        self.depth = ::std::option::Option::None;
        self.fingerprint = ::std::option::Option::None;
        self.child_num = ::std::option::Option::None;
        self.chain_code.clear();
        self.private_key.clear();
        self.public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HDNodeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HDNodeType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15messages-common.proto\x12\x19hw.trezor.messages.common\"#\n\x07Suc\
    cess\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\"\xd5\x03\n\x07\
    Failure\x12B\n\x04code\x18\x01\x20\x01(\x0e2..hw.trezor.messages.common.\
    Failure.FailureTypeR\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\tR\
    \x07message\"\xeb\x02\n\x0bFailureType\x12\x1d\n\x19Failure_UnexpectedMe\
    ssage\x10\x01\x12\x1a\n\x16Failure_ButtonExpected\x10\x02\x12\x15\n\x11F\
    ailure_DataError\x10\x03\x12\x1b\n\x17Failure_ActionCancelled\x10\x04\
    \x12\x17\n\x13Failure_PinExpected\x10\x05\x12\x18\n\x14Failure_PinCancel\
    led\x10\x06\x12\x16\n\x12Failure_PinInvalid\x10\x07\x12\x1c\n\x18Failure\
    _InvalidSignature\x10\x08\x12\x18\n\x14Failure_ProcessError\x10\t\x12\
    \x1a\n\x16Failure_NotEnoughFunds\x10\n\x12\x1a\n\x16Failure_NotInitializ\
    ed\x10\x0b\x12\x17\n\x13Failure_PinMismatch\x10\x0c\x12\x19\n\x15Failure\
    _FirmwareError\x10c\"\xe6\x04\n\rButtonRequest\x12N\n\x04code\x18\x01\
    \x20\x01(\x0e2:.hw.trezor.messages.common.ButtonRequest.ButtonRequestTyp\
    eR\x04code\x12\x12\n\x04data\x18\x02\x20\x01(\tR\x04data\"\xf0\x03\n\x11\
    ButtonRequestType\x12\x17\n\x13ButtonRequest_Other\x10\x01\x12\"\n\x1eBu\
    ttonRequest_FeeOverThreshold\x10\x02\x12\x1f\n\x1bButtonRequest_ConfirmO\
    utput\x10\x03\x12\x1d\n\x19ButtonRequest_ResetDevice\x10\x04\x12\x1d\n\
    \x19ButtonRequest_ConfirmWord\x10\x05\x12\x1c\n\x18ButtonRequest_WipeDev\
    ice\x10\x06\x12\x1d\n\x19ButtonRequest_ProtectCall\x10\x07\x12\x18\n\x14\
    ButtonRequest_SignTx\x10\x08\x12\x1f\n\x1bButtonRequest_FirmwareCheck\
    \x10\t\x12\x19\n\x15ButtonRequest_Address\x10\n\x12\x1b\n\x17ButtonReque\
    st_PublicKey\x10\x0b\x12#\n\x1fButtonRequest_MnemonicWordCount\x10\x0c\
    \x12\x1f\n\x1bButtonRequest_MnemonicInput\x10\r\x12\x20\n\x1cButtonReque\
    st_PassphraseType\x10\x0e\x12'\n#ButtonRequest_UnknownDerivationPath\x10\
    \x0f\"\x0b\n\tButtonAck\"\xe9\x01\n\x10PinMatrixRequest\x12T\n\x04type\
    \x18\x01\x20\x01(\x0e2@.hw.trezor.messages.common.PinMatrixRequest.PinMa\
    trixRequestTypeR\x04type\"\x7f\n\x14PinMatrixRequestType\x12\x20\n\x1cPi\
    nMatrixRequestType_Current\x10\x01\x12!\n\x1dPinMatrixRequestType_NewFir\
    st\x10\x02\x12\"\n\x1ePinMatrixRequestType_NewSecond\x10\x03\"\x20\n\x0c\
    PinMatrixAck\x12\x10\n\x03pin\x18\x01\x20\x02(\tR\x03pin\"0\n\x11Passphr\
    aseRequest\x12\x1b\n\ton_device\x18\x01\x20\x01(\x08R\x08onDevice\"E\n\r\
    PassphraseAck\x12\x1e\n\npassphrase\x18\x01\x20\x01(\tR\npassphrase\x12\
    \x14\n\x05state\x18\x02\x20\x01(\x0cR\x05state\".\n\x16PassphraseStateRe\
    quest\x12\x14\n\x05state\x18\x01\x20\x01(\x0cR\x05state\"\x14\n\x12Passp\
    hraseStateAck\"\xc0\x01\n\nHDNodeType\x12\x14\n\x05depth\x18\x01\x20\x02\
    (\rR\x05depth\x12\x20\n\x0bfingerprint\x18\x02\x20\x02(\rR\x0bfingerprin\
    t\x12\x1b\n\tchild_num\x18\x03\x20\x02(\rR\x08childNum\x12\x1d\n\nchain_\
    code\x18\x04\x20\x02(\x0cR\tchainCode\x12\x1f\n\x0bprivate_key\x18\x05\
    \x20\x01(\x0cR\nprivateKey\x12\x1d\n\npublic_key\x18\x06\x20\x01(\x0cR\t\
    publicKeyJ\xb7!\n\x07\x12\x05\0\0\x8e\x01\x01\n\x08\n\x01\x0c\x12\x03\0\
    \0\x12\n\x08\n\x01\x02\x12\x03\x01\x08!\n?\n\x02\x04\0\x12\x04\x07\0\t\
    \x01\x1a3*\n\x20Response:\x20Success\x20of\x20the\x20previous\x20request\
    \n\x20@end\n\n\n\n\x03\x04\0\x01\x12\x03\x07\x08\x0f\nO\n\x04\x04\0\x02\
    \0\x12\x03\x08\x04\x20\"B\x20human\x20readable\x20description\x20of\x20a\
    ction\x20or\x20request-specific\x20payload\n\n\x0c\n\x05\x04\0\x02\0\x04\
    \x12\x03\x08\x04\x0c\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x08\r\x13\n\x0c\
    \n\x05\x04\0\x02\0\x01\x12\x03\x08\x14\x1b\n\x0c\n\x05\x04\0\x02\0\x03\
    \x12\x03\x08\x1e\x1f\n?\n\x02\x04\x01\x12\x04\x0f\0!\x01\x1a3*\n\x20Resp\
    onse:\x20Failure\x20of\x20the\x20previous\x20request\n\x20@end\n\n\n\n\
    \x03\x04\x01\x01\x12\x03\x0f\x08\x0f\n>\n\x04\x04\x01\x02\0\x12\x03\x10\
    \x04\"\"1\x20computer-readable\x20definition\x20of\x20the\x20error\x20st\
    ate\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x10\x04\x0c\n\x0c\n\x05\x04\
    \x01\x02\0\x06\x12\x03\x10\r\x18\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\
    \x10\x19\x1d\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x10\x20!\n8\n\x04\x04\
    \x01\x02\x01\x12\x03\x11\x04\x20\"+\x20human-readable\x20message\x20of\
    \x20the\x20error\x20state\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\x11\
    \x04\x0c\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x11\r\x13\n\x0c\n\x05\
    \x04\x01\x02\x01\x01\x12\x03\x11\x14\x1b\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03\x11\x1e\x1f\n\x0c\n\x04\x04\x01\x04\0\x12\x04\x12\x04\x20\x05\n\
    \x0c\n\x05\x04\x01\x04\0\x01\x12\x03\x12\t\x14\n\r\n\x06\x04\x01\x04\0\
    \x02\0\x12\x03\x13\x08&\n\x0e\n\x07\x04\x01\x04\0\x02\0\x01\x12\x03\x13\
    \x08!\n\x0e\n\x07\x04\x01\x04\0\x02\0\x02\x12\x03\x13$%\n\r\n\x06\x04\
    \x01\x04\0\x02\x01\x12\x03\x14\x08#\n\x0e\n\x07\x04\x01\x04\0\x02\x01\
    \x01\x12\x03\x14\x08\x1e\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x02\x12\x03\
    \x14!\"\n\r\n\x06\x04\x01\x04\0\x02\x02\x12\x03\x15\x08\x1e\n\x0e\n\x07\
    \x04\x01\x04\0\x02\x02\x01\x12\x03\x15\x08\x19\n\x0e\n\x07\x04\x01\x04\0\
    \x02\x02\x02\x12\x03\x15\x1c\x1d\n\r\n\x06\x04\x01\x04\0\x02\x03\x12\x03\
    \x16\x08$\n\x0e\n\x07\x04\x01\x04\0\x02\x03\x01\x12\x03\x16\x08\x1f\n\
    \x0e\n\x07\x04\x01\x04\0\x02\x03\x02\x12\x03\x16\"#\n\r\n\x06\x04\x01\
    \x04\0\x02\x04\x12\x03\x17\x08\x20\n\x0e\n\x07\x04\x01\x04\0\x02\x04\x01\
    \x12\x03\x17\x08\x1b\n\x0e\n\x07\x04\x01\x04\0\x02\x04\x02\x12\x03\x17\
    \x1e\x1f\n\r\n\x06\x04\x01\x04\0\x02\x05\x12\x03\x18\x08!\n\x0e\n\x07\
    \x04\x01\x04\0\x02\x05\x01\x12\x03\x18\x08\x1c\n\x0e\n\x07\x04\x01\x04\0\
    \x02\x05\x02\x12\x03\x18\x1f\x20\n\r\n\x06\x04\x01\x04\0\x02\x06\x12\x03\
    \x19\x08\x1f\n\x0e\n\x07\x04\x01\x04\0\x02\x06\x01\x12\x03\x19\x08\x1a\n\
    \x0e\n\x07\x04\x01\x04\0\x02\x06\x02\x12\x03\x19\x1d\x1e\n\r\n\x06\x04\
    \x01\x04\0\x02\x07\x12\x03\x1a\x08%\n\x0e\n\x07\x04\x01\x04\0\x02\x07\
    \x01\x12\x03\x1a\x08\x20\n\x0e\n\x07\x04\x01\x04\0\x02\x07\x02\x12\x03\
    \x1a#$\n\r\n\x06\x04\x01\x04\0\x02\x08\x12\x03\x1b\x08!\n\x0e\n\x07\x04\
    \x01\x04\0\x02\x08\x01\x12\x03\x1b\x08\x1c\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x08\x02\x12\x03\x1b\x1f\x20\n\r\n\x06\x04\x01\x04\0\x02\t\x12\x03\x1c\
    \x08$\n\x0e\n\x07\x04\x01\x04\0\x02\t\x01\x12\x03\x1c\x08\x1e\n\x0e\n\
    \x07\x04\x01\x04\0\x02\t\x02\x12\x03\x1c!#\n\r\n\x06\x04\x01\x04\0\x02\n\
    \x12\x03\x1d\x08$\n\x0e\n\x07\x04\x01\x04\0\x02\n\x01\x12\x03\x1d\x08\
    \x1e\n\x0e\n\x07\x04\x01\x04\0\x02\n\x02\x12\x03\x1d!#\n\r\n\x06\x04\x01\
    \x04\0\x02\x0b\x12\x03\x1e\x08!\n\x0e\n\x07\x04\x01\x04\0\x02\x0b\x01\
    \x12\x03\x1e\x08\x1b\n\x0e\n\x07\x04\x01\x04\0\x02\x0b\x02\x12\x03\x1e\
    \x1e\x20\n\r\n\x06\x04\x01\x04\0\x02\x0c\x12\x03\x1f\x08#\n\x0e\n\x07\
    \x04\x01\x04\0\x02\x0c\x01\x12\x03\x1f\x08\x1d\n\x0e\n\x07\x04\x01\x04\0\
    \x02\x0c\x02\x12\x03\x1f\x20\"\n\\\n\x02\x04\x02\x12\x04(\0?\x01\x1aP*\n\
    \x20Response:\x20Device\x20is\x20waiting\x20for\x20HW\x20button\x20press\
    .\n\x20@auxstart\n\x20@next\x20ButtonAck\n\n\n\n\x03\x04\x02\x01\x12\x03\
    (\x08\x15\n\x0b\n\x04\x04\x02\x02\0\x12\x03)\x04(\n\x0c\n\x05\x04\x02\
    \x02\0\x04\x12\x03)\x04\x0c\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03)\r\x1e\
    \n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03)\x1f#\n\x0c\n\x05\x04\x02\x02\0\
    \x03\x12\x03)&'\n\x0b\n\x04\x04\x02\x02\x01\x12\x03*\x04\x1d\n\x0c\n\x05\
    \x04\x02\x02\x01\x04\x12\x03*\x04\x0c\n\x0c\n\x05\x04\x02\x02\x01\x05\
    \x12\x03*\r\x13\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03*\x14\x18\n\x0c\n\
    \x05\x04\x02\x02\x01\x03\x12\x03*\x1b\x1c\n(\n\x04\x04\x02\x04\0\x12\x04\
    .\x04>\x05\x1a\x1a*\n\x20Type\x20of\x20button\x20request\n\n\x0c\n\x05\
    \x04\x02\x04\0\x01\x12\x03.\t\x1a\n\r\n\x06\x04\x02\x04\0\x02\0\x12\x03/\
    \x08\x20\n\x0e\n\x07\x04\x02\x04\0\x02\0\x01\x12\x03/\x08\x1b\n\x0e\n\
    \x07\x04\x02\x04\0\x02\0\x02\x12\x03/\x1e\x1f\n\r\n\x06\x04\x02\x04\0\
    \x02\x01\x12\x030\x08+\n\x0e\n\x07\x04\x02\x04\0\x02\x01\x01\x12\x030\
    \x08&\n\x0e\n\x07\x04\x02\x04\0\x02\x01\x02\x12\x030)*\n\r\n\x06\x04\x02\
    \x04\0\x02\x02\x12\x031\x08(\n\x0e\n\x07\x04\x02\x04\0\x02\x02\x01\x12\
    \x031\x08#\n\x0e\n\x07\x04\x02\x04\0\x02\x02\x02\x12\x031&'\n\r\n\x06\
    \x04\x02\x04\0\x02\x03\x12\x032\x08&\n\x0e\n\x07\x04\x02\x04\0\x02\x03\
    \x01\x12\x032\x08!\n\x0e\n\x07\x04\x02\x04\0\x02\x03\x02\x12\x032$%\n\r\
    \n\x06\x04\x02\x04\0\x02\x04\x12\x033\x08&\n\x0e\n\x07\x04\x02\x04\0\x02\
    \x04\x01\x12\x033\x08!\n\x0e\n\x07\x04\x02\x04\0\x02\x04\x02\x12\x033$%\
    \n\r\n\x06\x04\x02\x04\0\x02\x05\x12\x034\x08%\n\x0e\n\x07\x04\x02\x04\0\
    \x02\x05\x01\x12\x034\x08\x20\n\x0e\n\x07\x04\x02\x04\0\x02\x05\x02\x12\
    \x034#$\n\r\n\x06\x04\x02\x04\0\x02\x06\x12\x035\x08&\n\x0e\n\x07\x04\
    \x02\x04\0\x02\x06\x01\x12\x035\x08!\n\x0e\n\x07\x04\x02\x04\0\x02\x06\
    \x02\x12\x035$%\n\r\n\x06\x04\x02\x04\0\x02\x07\x12\x036\x08!\n\x0e\n\
    \x07\x04\x02\x04\0\x02\x07\x01\x12\x036\x08\x1c\n\x0e\n\x07\x04\x02\x04\
    \0\x02\x07\x02\x12\x036\x1f\x20\n\r\n\x06\x04\x02\x04\0\x02\x08\x12\x037\
    \x08(\n\x0e\n\x07\x04\x02\x04\0\x02\x08\x01\x12\x037\x08#\n\x0e\n\x07\
    \x04\x02\x04\0\x02\x08\x02\x12\x037&'\n\r\n\x06\x04\x02\x04\0\x02\t\x12\
    \x038\x08#\n\x0e\n\x07\x04\x02\x04\0\x02\t\x01\x12\x038\x08\x1d\n\x0e\n\
    \x07\x04\x02\x04\0\x02\t\x02\x12\x038\x20\"\n\r\n\x06\x04\x02\x04\0\x02\
    \n\x12\x039\x08%\n\x0e\n\x07\x04\x02\x04\0\x02\n\x01\x12\x039\x08\x1f\n\
    \x0e\n\x07\x04\x02\x04\0\x02\n\x02\x12\x039\"$\n\r\n\x06\x04\x02\x04\0\
    \x02\x0b\x12\x03:\x08-\n\x0e\n\x07\x04\x02\x04\0\x02\x0b\x01\x12\x03:\
    \x08'\n\x0e\n\x07\x04\x02\x04\0\x02\x0b\x02\x12\x03:*,\n\r\n\x06\x04\x02\
    \x04\0\x02\x0c\x12\x03;\x08)\n\x0e\n\x07\x04\x02\x04\0\x02\x0c\x01\x12\
    \x03;\x08#\n\x0e\n\x07\x04\x02\x04\0\x02\x0c\x02\x12\x03;&(\n\r\n\x06\
    \x04\x02\x04\0\x02\r\x12\x03<\x08*\n\x0e\n\x07\x04\x02\x04\0\x02\r\x01\
    \x12\x03<\x08$\n\x0e\n\x07\x04\x02\x04\0\x02\r\x02\x12\x03<')\n\r\n\x06\
    \x04\x02\x04\0\x02\x0e\x12\x03=\x081\n\x0e\n\x07\x04\x02\x04\0\x02\x0e\
    \x01\x12\x03=\x08+\n\x0e\n\x07\x04\x02\x04\0\x02\x0e\x02\x12\x03=.0\nM\n\
    \x02\x04\x03\x12\x04E\0F\x01\x1aA*\n\x20Request:\x20Computer\x20agrees\
    \x20to\x20wait\x20for\x20HW\x20button\x20press\n\x20@auxend\n\n\n\n\x03\
    \x04\x03\x01\x12\x03E\x08\x11\n\x96\x01\n\x02\x04\x04\x12\x04M\0W\x01\
    \x1a\x89\x01*\n\x20Response:\x20Device\x20is\x20asking\x20computer\x20to\
    \x20show\x20PIN\x20matrix\x20and\x20awaits\x20PIN\x20encoded\x20using\
    \x20this\x20matrix\x20scheme\n\x20@auxstart\n\x20@next\x20PinMatrixAck\n\
    \n\n\n\x03\x04\x04\x01\x12\x03M\x08\x18\n\x0b\n\x04\x04\x04\x02\0\x12\
    \x03N\x04+\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03N\x04\x0c\n\x0c\n\x05\
    \x04\x04\x02\0\x06\x12\x03N\r!\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03N\"&\
    \n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03N)*\n%\n\x04\x04\x04\x04\0\x12\x04\
    R\x04V\x05\x1a\x17*\n\x20Type\x20of\x20PIN\x20request\n\n\x0c\n\x05\x04\
    \x04\x04\0\x01\x12\x03R\t\x1d\n\r\n\x06\x04\x04\x04\0\x02\0\x12\x03S\x08\
    )\n\x0e\n\x07\x04\x04\x04\0\x02\0\x01\x12\x03S\x08$\n\x0e\n\x07\x04\x04\
    \x04\0\x02\0\x02\x12\x03S'(\n\r\n\x06\x04\x04\x04\0\x02\x01\x12\x03T\x08\
    *\n\x0e\n\x07\x04\x04\x04\0\x02\x01\x01\x12\x03T\x08%\n\x0e\n\x07\x04\
    \x04\x04\0\x02\x01\x02\x12\x03T()\n\r\n\x06\x04\x04\x04\0\x02\x02\x12\
    \x03U\x08+\n\x0e\n\x07\x04\x04\x04\0\x02\x02\x01\x12\x03U\x08&\n\x0e\n\
    \x07\x04\x04\x04\0\x02\x02\x02\x12\x03U)*\nD\n\x02\x04\x05\x12\x04]\0_\
    \x01\x1a8*\n\x20Request:\x20Computer\x20responds\x20with\x20encoded\x20P\
    IN\n\x20@auxend\n\n\n\n\x03\x04\x05\x01\x12\x03]\x08\x14\n1\n\x04\x04\
    \x05\x02\0\x12\x03^\x04\x1c\"$\x20matrix\x20encoded\x20PIN\x20entered\
    \x20by\x20user\n\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03^\x04\x0c\n\x0c\n\
    \x05\x04\x05\x02\0\x05\x12\x03^\r\x13\n\x0c\n\x05\x04\x05\x02\0\x01\x12\
    \x03^\x14\x17\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03^\x1a\x1b\n]\n\x02\
    \x04\x06\x12\x04f\0h\x01\x1aQ*\n\x20Response:\x20Device\x20awaits\x20enc\
    ryption\x20passphrase\n\x20@auxstart\n\x20@next\x20PassphraseAck\n\n\n\n\
    \x03\x04\x06\x01\x12\x03f\x08\x19\n8\n\x04\x04\x06\x02\0\x12\x03g\x04\
    \x20\"+\x20passphrase\x20is\x20being\x20entered\x20on\x20the\x20device\n\
    \n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03g\x04\x0c\n\x0c\n\x05\x04\x06\x02\
    \0\x05\x12\x03g\r\x11\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03g\x12\x1b\n\
    \x0c\n\x05\x04\x06\x02\0\x03\x12\x03g\x1e\x1f\nK\n\x02\x04\x07\x12\x04n\
    \0q\x01\x1a?*\n\x20Request:\x20Send\x20passphrase\x20back\n\x20@next\x20\
    PassphraseStateRequest\n\n\n\n\x03\x04\x07\x01\x12\x03n\x08\x15\n\x0b\n\
    \x04\x04\x07\x02\0\x12\x03o\x04#\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03o\
    \x04\x0c\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03o\r\x13\n\x0c\n\x05\x04\
    \x07\x02\0\x01\x12\x03o\x14\x1e\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03o!\
    \"\n$\n\x04\x04\x07\x02\x01\x12\x03p\x04\x1d\"\x17\x20expected\x20device\
    \x20state\n\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03p\x04\x0c\n\x0c\n\x05\
    \x04\x07\x02\x01\x05\x12\x03p\r\x12\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\
    \x03p\x13\x18\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03p\x1b\x1c\nR\n\x02\
    \x04\x08\x12\x04w\0y\x01\x1aF*\n\x20Response:\x20Device\x20awaits\x20pas\
    sphrase\x20state\n\x20@next\x20PassphraseStateAck\n\n\n\n\x03\x04\x08\
    \x01\x12\x03w\x08\x1e\n\"\n\x04\x04\x08\x02\0\x12\x03x\x04\x1d\"\x15\x20\
    actual\x20device\x20state\n\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03x\x04\
    \x0c\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03x\r\x12\n\x0c\n\x05\x04\x08\
    \x02\0\x01\x12\x03x\x13\x18\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03x\x1b\
    \x1c\n=\n\x02\x04\t\x12\x05\x7f\0\x80\x01\x01\x1a0*\n\x20Request:\x20Sen\
    d\x20passphrase\x20state\x20back\n\x20@auxend\n\n\n\n\x03\x04\t\x01\x12\
    \x03\x7f\x08\x1a\n\xb1\x01\n\x02\x04\n\x12\x06\x87\x01\0\x8e\x01\x01\x1a\
    \xa2\x01*\n\x20Structure\x20representing\x20BIP32\x20(hierarchical\x20de\
    terministic)\x20node\n\x20Used\x20for\x20imports\x20of\x20private\x20key\
    \x20into\x20the\x20device\x20and\x20exporting\x20public\x20key\x20out\
    \x20of\x20device\n\x20@embed\n\n\x0b\n\x03\x04\n\x01\x12\x04\x87\x01\x08\
    \x12\n\x0c\n\x04\x04\n\x02\0\x12\x04\x88\x01\x04\x1e\n\r\n\x05\x04\n\x02\
    \0\x04\x12\x04\x88\x01\x04\x0c\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x88\x01\
    \r\x13\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x88\x01\x14\x19\n\r\n\x05\x04\n\
    \x02\0\x03\x12\x04\x88\x01\x1c\x1d\n\x0c\n\x04\x04\n\x02\x01\x12\x04\x89\
    \x01\x04$\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\x89\x01\x04\x0c\n\r\n\x05\
    \x04\n\x02\x01\x05\x12\x04\x89\x01\r\x13\n\r\n\x05\x04\n\x02\x01\x01\x12\
    \x04\x89\x01\x14\x1f\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\x89\x01\"#\n\
    \x0c\n\x04\x04\n\x02\x02\x12\x04\x8a\x01\x04\"\n\r\n\x05\x04\n\x02\x02\
    \x04\x12\x04\x8a\x01\x04\x0c\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\x8a\x01\
    \r\x13\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\x8a\x01\x14\x1d\n\r\n\x05\x04\
    \n\x02\x02\x03\x12\x04\x8a\x01\x20!\n\x0c\n\x04\x04\n\x02\x03\x12\x04\
    \x8b\x01\x04\"\n\r\n\x05\x04\n\x02\x03\x04\x12\x04\x8b\x01\x04\x0c\n\r\n\
    \x05\x04\n\x02\x03\x05\x12\x04\x8b\x01\r\x12\n\r\n\x05\x04\n\x02\x03\x01\
    \x12\x04\x8b\x01\x13\x1d\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\x8b\x01\x20\
    !\n\x0c\n\x04\x04\n\x02\x04\x12\x04\x8c\x01\x04#\n\r\n\x05\x04\n\x02\x04\
    \x04\x12\x04\x8c\x01\x04\x0c\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\x8c\x01\
    \r\x12\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\x8c\x01\x13\x1e\n\r\n\x05\x04\
    \n\x02\x04\x03\x12\x04\x8c\x01!\"\n\x0c\n\x04\x04\n\x02\x05\x12\x04\x8d\
    \x01\x04\"\n\r\n\x05\x04\n\x02\x05\x04\x12\x04\x8d\x01\x04\x0c\n\r\n\x05\
    \x04\n\x02\x05\x05\x12\x04\x8d\x01\r\x12\n\r\n\x05\x04\n\x02\x05\x01\x12\
    \x04\x8d\x01\x13\x1d\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\x8d\x01\x20!\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
