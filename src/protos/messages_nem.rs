// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `messages-nem.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct NEMGetAddress {
    // message fields
    address_n: ::std::vec::Vec<u32>,
    network: ::std::option::Option<u32>,
    show_display: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMGetAddress {
    fn default() -> &'a NEMGetAddress {
        <NEMGetAddress as ::protobuf::Message>::default_instance()
    }
}

impl NEMGetAddress {
    pub fn new() -> NEMGetAddress {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional uint32 network = 2;


    pub fn get_network(&self) -> u32 {
        self.network.unwrap_or(0)
    }
    pub fn clear_network(&mut self) {
        self.network = ::std::option::Option::None;
    }

    pub fn has_network(&self) -> bool {
        self.network.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: u32) {
        self.network = ::std::option::Option::Some(v);
    }

    // optional bool show_display = 3;


    pub fn get_show_display(&self) -> bool {
        self.show_display.unwrap_or(false)
    }
    pub fn clear_show_display(&mut self) {
        self.show_display = ::std::option::Option::None;
    }

    pub fn has_show_display(&self) -> bool {
        self.show_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_display(&mut self, v: bool) {
        self.show_display = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for NEMGetAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_display = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.network {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.show_display {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.network {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.show_display {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMGetAddress {
        NEMGetAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address_n",
                    |m: &NEMGetAddress| { &m.address_n },
                    |m: &mut NEMGetAddress| { &mut m.address_n },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "network",
                    |m: &NEMGetAddress| { &m.network },
                    |m: &mut NEMGetAddress| { &mut m.network },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "show_display",
                    |m: &NEMGetAddress| { &m.show_display },
                    |m: &mut NEMGetAddress| { &mut m.show_display },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMGetAddress>(
                    "NEMGetAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMGetAddress {
        static mut instance: ::protobuf::lazy::Lazy<NEMGetAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMGetAddress,
        };
        unsafe {
            instance.get(NEMGetAddress::new)
        }
    }
}

impl ::protobuf::Clear for NEMGetAddress {
    fn clear(&mut self) {
        self.address_n.clear();
        self.network = ::std::option::Option::None;
        self.show_display = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMGetAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMGetAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMAddress {
    // message fields
    address: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMAddress {
    fn default() -> &'a NEMAddress {
        <NEMAddress as ::protobuf::Message>::default_instance()
    }
}

impl NEMAddress {
    pub fn new() -> NEMAddress {
        ::std::default::Default::default()
    }

    // required string address = 1;


    pub fn get_address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NEMAddress {
    fn is_initialized(&self) -> bool {
        if self.address.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMAddress {
        NEMAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &NEMAddress| { &m.address },
                    |m: &mut NEMAddress| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMAddress>(
                    "NEMAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMAddress {
        static mut instance: ::protobuf::lazy::Lazy<NEMAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMAddress,
        };
        unsafe {
            instance.get(NEMAddress::new)
        }
    }
}

impl ::protobuf::Clear for NEMAddress {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMSignTx {
    // message fields
    transaction: ::protobuf::SingularPtrField<NEMSignTx_NEMTransactionCommon>,
    multisig: ::protobuf::SingularPtrField<NEMSignTx_NEMTransactionCommon>,
    transfer: ::protobuf::SingularPtrField<NEMSignTx_NEMTransfer>,
    cosigning: ::std::option::Option<bool>,
    provision_namespace: ::protobuf::SingularPtrField<NEMSignTx_NEMProvisionNamespace>,
    mosaic_creation: ::protobuf::SingularPtrField<NEMSignTx_NEMMosaicCreation>,
    supply_change: ::protobuf::SingularPtrField<NEMSignTx_NEMMosaicSupplyChange>,
    aggregate_modification: ::protobuf::SingularPtrField<NEMSignTx_NEMAggregateModification>,
    importance_transfer: ::protobuf::SingularPtrField<NEMSignTx_NEMImportanceTransfer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMSignTx {
    fn default() -> &'a NEMSignTx {
        <NEMSignTx as ::protobuf::Message>::default_instance()
    }
}

impl NEMSignTx {
    pub fn new() -> NEMSignTx {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon transaction = 1;


    pub fn get_transaction(&self) -> &NEMSignTx_NEMTransactionCommon {
        self.transaction.as_ref().unwrap_or_else(|| NEMSignTx_NEMTransactionCommon::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: NEMSignTx_NEMTransactionCommon) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut NEMSignTx_NEMTransactionCommon {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> NEMSignTx_NEMTransactionCommon {
        self.transaction.take().unwrap_or_else(|| NEMSignTx_NEMTransactionCommon::new())
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon multisig = 2;


    pub fn get_multisig(&self) -> &NEMSignTx_NEMTransactionCommon {
        self.multisig.as_ref().unwrap_or_else(|| NEMSignTx_NEMTransactionCommon::default_instance())
    }
    pub fn clear_multisig(&mut self) {
        self.multisig.clear();
    }

    pub fn has_multisig(&self) -> bool {
        self.multisig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multisig(&mut self, v: NEMSignTx_NEMTransactionCommon) {
        self.multisig = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multisig(&mut self) -> &mut NEMSignTx_NEMTransactionCommon {
        if self.multisig.is_none() {
            self.multisig.set_default();
        }
        self.multisig.as_mut().unwrap()
    }

    // Take field
    pub fn take_multisig(&mut self) -> NEMSignTx_NEMTransactionCommon {
        self.multisig.take().unwrap_or_else(|| NEMSignTx_NEMTransactionCommon::new())
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMTransfer transfer = 3;


    pub fn get_transfer(&self) -> &NEMSignTx_NEMTransfer {
        self.transfer.as_ref().unwrap_or_else(|| NEMSignTx_NEMTransfer::default_instance())
    }
    pub fn clear_transfer(&mut self) {
        self.transfer.clear();
    }

    pub fn has_transfer(&self) -> bool {
        self.transfer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transfer(&mut self, v: NEMSignTx_NEMTransfer) {
        self.transfer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transfer(&mut self) -> &mut NEMSignTx_NEMTransfer {
        if self.transfer.is_none() {
            self.transfer.set_default();
        }
        self.transfer.as_mut().unwrap()
    }

    // Take field
    pub fn take_transfer(&mut self) -> NEMSignTx_NEMTransfer {
        self.transfer.take().unwrap_or_else(|| NEMSignTx_NEMTransfer::new())
    }

    // optional bool cosigning = 4;


    pub fn get_cosigning(&self) -> bool {
        self.cosigning.unwrap_or(false)
    }
    pub fn clear_cosigning(&mut self) {
        self.cosigning = ::std::option::Option::None;
    }

    pub fn has_cosigning(&self) -> bool {
        self.cosigning.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cosigning(&mut self, v: bool) {
        self.cosigning = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace provision_namespace = 5;


    pub fn get_provision_namespace(&self) -> &NEMSignTx_NEMProvisionNamespace {
        self.provision_namespace.as_ref().unwrap_or_else(|| NEMSignTx_NEMProvisionNamespace::default_instance())
    }
    pub fn clear_provision_namespace(&mut self) {
        self.provision_namespace.clear();
    }

    pub fn has_provision_namespace(&self) -> bool {
        self.provision_namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_provision_namespace(&mut self, v: NEMSignTx_NEMProvisionNamespace) {
        self.provision_namespace = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_provision_namespace(&mut self) -> &mut NEMSignTx_NEMProvisionNamespace {
        if self.provision_namespace.is_none() {
            self.provision_namespace.set_default();
        }
        self.provision_namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_provision_namespace(&mut self) -> NEMSignTx_NEMProvisionNamespace {
        self.provision_namespace.take().unwrap_or_else(|| NEMSignTx_NEMProvisionNamespace::new())
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation mosaic_creation = 6;


    pub fn get_mosaic_creation(&self) -> &NEMSignTx_NEMMosaicCreation {
        self.mosaic_creation.as_ref().unwrap_or_else(|| NEMSignTx_NEMMosaicCreation::default_instance())
    }
    pub fn clear_mosaic_creation(&mut self) {
        self.mosaic_creation.clear();
    }

    pub fn has_mosaic_creation(&self) -> bool {
        self.mosaic_creation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mosaic_creation(&mut self, v: NEMSignTx_NEMMosaicCreation) {
        self.mosaic_creation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mosaic_creation(&mut self) -> &mut NEMSignTx_NEMMosaicCreation {
        if self.mosaic_creation.is_none() {
            self.mosaic_creation.set_default();
        }
        self.mosaic_creation.as_mut().unwrap()
    }

    // Take field
    pub fn take_mosaic_creation(&mut self) -> NEMSignTx_NEMMosaicCreation {
        self.mosaic_creation.take().unwrap_or_else(|| NEMSignTx_NEMMosaicCreation::new())
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange supply_change = 7;


    pub fn get_supply_change(&self) -> &NEMSignTx_NEMMosaicSupplyChange {
        self.supply_change.as_ref().unwrap_or_else(|| NEMSignTx_NEMMosaicSupplyChange::default_instance())
    }
    pub fn clear_supply_change(&mut self) {
        self.supply_change.clear();
    }

    pub fn has_supply_change(&self) -> bool {
        self.supply_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supply_change(&mut self, v: NEMSignTx_NEMMosaicSupplyChange) {
        self.supply_change = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_supply_change(&mut self) -> &mut NEMSignTx_NEMMosaicSupplyChange {
        if self.supply_change.is_none() {
            self.supply_change.set_default();
        }
        self.supply_change.as_mut().unwrap()
    }

    // Take field
    pub fn take_supply_change(&mut self) -> NEMSignTx_NEMMosaicSupplyChange {
        self.supply_change.take().unwrap_or_else(|| NEMSignTx_NEMMosaicSupplyChange::new())
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification aggregate_modification = 8;


    pub fn get_aggregate_modification(&self) -> &NEMSignTx_NEMAggregateModification {
        self.aggregate_modification.as_ref().unwrap_or_else(|| NEMSignTx_NEMAggregateModification::default_instance())
    }
    pub fn clear_aggregate_modification(&mut self) {
        self.aggregate_modification.clear();
    }

    pub fn has_aggregate_modification(&self) -> bool {
        self.aggregate_modification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregate_modification(&mut self, v: NEMSignTx_NEMAggregateModification) {
        self.aggregate_modification = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aggregate_modification(&mut self) -> &mut NEMSignTx_NEMAggregateModification {
        if self.aggregate_modification.is_none() {
            self.aggregate_modification.set_default();
        }
        self.aggregate_modification.as_mut().unwrap()
    }

    // Take field
    pub fn take_aggregate_modification(&mut self) -> NEMSignTx_NEMAggregateModification {
        self.aggregate_modification.take().unwrap_or_else(|| NEMSignTx_NEMAggregateModification::new())
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer importance_transfer = 9;


    pub fn get_importance_transfer(&self) -> &NEMSignTx_NEMImportanceTransfer {
        self.importance_transfer.as_ref().unwrap_or_else(|| NEMSignTx_NEMImportanceTransfer::default_instance())
    }
    pub fn clear_importance_transfer(&mut self) {
        self.importance_transfer.clear();
    }

    pub fn has_importance_transfer(&self) -> bool {
        self.importance_transfer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_importance_transfer(&mut self, v: NEMSignTx_NEMImportanceTransfer) {
        self.importance_transfer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_importance_transfer(&mut self) -> &mut NEMSignTx_NEMImportanceTransfer {
        if self.importance_transfer.is_none() {
            self.importance_transfer.set_default();
        }
        self.importance_transfer.as_mut().unwrap()
    }

    // Take field
    pub fn take_importance_transfer(&mut self) -> NEMSignTx_NEMImportanceTransfer {
        self.importance_transfer.take().unwrap_or_else(|| NEMSignTx_NEMImportanceTransfer::new())
    }
}

impl ::protobuf::Message for NEMSignTx {
    fn is_initialized(&self) -> bool {
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.multisig {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transfer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.provision_namespace {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mosaic_creation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.supply_change {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.aggregate_modification {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.importance_transfer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.multisig)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transfer)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.cosigning = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.provision_namespace)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mosaic_creation)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.supply_change)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.aggregate_modification)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.importance_transfer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.multisig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transfer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.cosigning {
            my_size += 2;
        }
        if let Some(ref v) = self.provision_namespace.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mosaic_creation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.supply_change.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.aggregate_modification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.importance_transfer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.multisig.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transfer.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.cosigning {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.provision_namespace.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mosaic_creation.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.supply_change.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.aggregate_modification.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.importance_transfer.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMSignTx {
        NEMSignTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NEMSignTx_NEMTransactionCommon>>(
                    "transaction",
                    |m: &NEMSignTx| { &m.transaction },
                    |m: &mut NEMSignTx| { &mut m.transaction },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NEMSignTx_NEMTransactionCommon>>(
                    "multisig",
                    |m: &NEMSignTx| { &m.multisig },
                    |m: &mut NEMSignTx| { &mut m.multisig },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NEMSignTx_NEMTransfer>>(
                    "transfer",
                    |m: &NEMSignTx| { &m.transfer },
                    |m: &mut NEMSignTx| { &mut m.transfer },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "cosigning",
                    |m: &NEMSignTx| { &m.cosigning },
                    |m: &mut NEMSignTx| { &mut m.cosigning },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NEMSignTx_NEMProvisionNamespace>>(
                    "provision_namespace",
                    |m: &NEMSignTx| { &m.provision_namespace },
                    |m: &mut NEMSignTx| { &mut m.provision_namespace },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NEMSignTx_NEMMosaicCreation>>(
                    "mosaic_creation",
                    |m: &NEMSignTx| { &m.mosaic_creation },
                    |m: &mut NEMSignTx| { &mut m.mosaic_creation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NEMSignTx_NEMMosaicSupplyChange>>(
                    "supply_change",
                    |m: &NEMSignTx| { &m.supply_change },
                    |m: &mut NEMSignTx| { &mut m.supply_change },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NEMSignTx_NEMAggregateModification>>(
                    "aggregate_modification",
                    |m: &NEMSignTx| { &m.aggregate_modification },
                    |m: &mut NEMSignTx| { &mut m.aggregate_modification },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NEMSignTx_NEMImportanceTransfer>>(
                    "importance_transfer",
                    |m: &NEMSignTx| { &m.importance_transfer },
                    |m: &mut NEMSignTx| { &mut m.importance_transfer },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMSignTx>(
                    "NEMSignTx",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMSignTx {
        static mut instance: ::protobuf::lazy::Lazy<NEMSignTx> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMSignTx,
        };
        unsafe {
            instance.get(NEMSignTx::new)
        }
    }
}

impl ::protobuf::Clear for NEMSignTx {
    fn clear(&mut self) {
        self.transaction.clear();
        self.multisig.clear();
        self.transfer.clear();
        self.cosigning = ::std::option::Option::None;
        self.provision_namespace.clear();
        self.mosaic_creation.clear();
        self.supply_change.clear();
        self.aggregate_modification.clear();
        self.importance_transfer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMSignTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMSignTx_NEMTransactionCommon {
    // message fields
    address_n: ::std::vec::Vec<u32>,
    network: ::std::option::Option<u32>,
    timestamp: ::std::option::Option<u32>,
    fee: ::std::option::Option<u64>,
    deadline: ::std::option::Option<u32>,
    signer: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMSignTx_NEMTransactionCommon {
    fn default() -> &'a NEMSignTx_NEMTransactionCommon {
        <NEMSignTx_NEMTransactionCommon as ::protobuf::Message>::default_instance()
    }
}

impl NEMSignTx_NEMTransactionCommon {
    pub fn new() -> NEMSignTx_NEMTransactionCommon {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional uint32 network = 2;


    pub fn get_network(&self) -> u32 {
        self.network.unwrap_or(0)
    }
    pub fn clear_network(&mut self) {
        self.network = ::std::option::Option::None;
    }

    pub fn has_network(&self) -> bool {
        self.network.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: u32) {
        self.network = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 3;


    pub fn get_timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 fee = 4;


    pub fn get_fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }
    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }

    // optional uint32 deadline = 5;


    pub fn get_deadline(&self) -> u32 {
        self.deadline.unwrap_or(0)
    }
    pub fn clear_deadline(&mut self) {
        self.deadline = ::std::option::Option::None;
    }

    pub fn has_deadline(&self) -> bool {
        self.deadline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deadline(&mut self, v: u32) {
        self.deadline = ::std::option::Option::Some(v);
    }

    // optional bytes signer = 6;


    pub fn get_signer(&self) -> &[u8] {
        match self.signer.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    pub fn has_signer(&self) -> bool {
        self.signer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::vec::Vec<u8>) {
        self.signer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signer.is_none() {
            self.signer.set_default();
        }
        self.signer.as_mut().unwrap()
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::vec::Vec<u8> {
        self.signer.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NEMSignTx_NEMTransactionCommon {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deadline = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.network {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.deadline {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.signer.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.network {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.deadline {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.signer.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMSignTx_NEMTransactionCommon {
        NEMSignTx_NEMTransactionCommon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address_n",
                    |m: &NEMSignTx_NEMTransactionCommon| { &m.address_n },
                    |m: &mut NEMSignTx_NEMTransactionCommon| { &mut m.address_n },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "network",
                    |m: &NEMSignTx_NEMTransactionCommon| { &m.network },
                    |m: &mut NEMSignTx_NEMTransactionCommon| { &mut m.network },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "timestamp",
                    |m: &NEMSignTx_NEMTransactionCommon| { &m.timestamp },
                    |m: &mut NEMSignTx_NEMTransactionCommon| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fee",
                    |m: &NEMSignTx_NEMTransactionCommon| { &m.fee },
                    |m: &mut NEMSignTx_NEMTransactionCommon| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "deadline",
                    |m: &NEMSignTx_NEMTransactionCommon| { &m.deadline },
                    |m: &mut NEMSignTx_NEMTransactionCommon| { &mut m.deadline },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "signer",
                    |m: &NEMSignTx_NEMTransactionCommon| { &m.signer },
                    |m: &mut NEMSignTx_NEMTransactionCommon| { &mut m.signer },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMSignTx_NEMTransactionCommon>(
                    "NEMSignTx_NEMTransactionCommon",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMSignTx_NEMTransactionCommon {
        static mut instance: ::protobuf::lazy::Lazy<NEMSignTx_NEMTransactionCommon> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMSignTx_NEMTransactionCommon,
        };
        unsafe {
            instance.get(NEMSignTx_NEMTransactionCommon::new)
        }
    }
}

impl ::protobuf::Clear for NEMSignTx_NEMTransactionCommon {
    fn clear(&mut self) {
        self.address_n.clear();
        self.network = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.fee = ::std::option::Option::None;
        self.deadline = ::std::option::Option::None;
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMSignTx_NEMTransactionCommon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx_NEMTransactionCommon {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMSignTx_NEMTransfer {
    // message fields
    recipient: ::protobuf::SingularField<::std::string::String>,
    amount: ::std::option::Option<u64>,
    payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    mosaics: ::protobuf::RepeatedField<NEMSignTx_NEMTransfer_NEMMosaic>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMSignTx_NEMTransfer {
    fn default() -> &'a NEMSignTx_NEMTransfer {
        <NEMSignTx_NEMTransfer as ::protobuf::Message>::default_instance()
    }
}

impl NEMSignTx_NEMTransfer {
    pub fn new() -> NEMSignTx_NEMTransfer {
        ::std::default::Default::default()
    }

    // optional string recipient = 1;


    pub fn get_recipient(&self) -> &str {
        match self.recipient.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_recipient(&mut self) {
        self.recipient.clear();
    }

    pub fn has_recipient(&self) -> bool {
        self.recipient.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient(&mut self, v: ::std::string::String) {
        self.recipient = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient(&mut self) -> &mut ::std::string::String {
        if self.recipient.is_none() {
            self.recipient.set_default();
        }
        self.recipient.as_mut().unwrap()
    }

    // Take field
    pub fn take_recipient(&mut self) -> ::std::string::String {
        self.recipient.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 amount = 2;


    pub fn get_amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 3;


    pub fn get_payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes public_key = 4;


    pub fn get_public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key.set_default();
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated .hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic mosaics = 5;


    pub fn get_mosaics(&self) -> &[NEMSignTx_NEMTransfer_NEMMosaic] {
        &self.mosaics
    }
    pub fn clear_mosaics(&mut self) {
        self.mosaics.clear();
    }

    // Param is passed by value, moved
    pub fn set_mosaics(&mut self, v: ::protobuf::RepeatedField<NEMSignTx_NEMTransfer_NEMMosaic>) {
        self.mosaics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mosaics(&mut self) -> &mut ::protobuf::RepeatedField<NEMSignTx_NEMTransfer_NEMMosaic> {
        &mut self.mosaics
    }

    // Take field
    pub fn take_mosaics(&mut self) -> ::protobuf::RepeatedField<NEMSignTx_NEMTransfer_NEMMosaic> {
        ::std::mem::replace(&mut self.mosaics, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NEMSignTx_NEMTransfer {
    fn is_initialized(&self) -> bool {
        for v in &self.mosaics {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.recipient)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mosaics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.recipient.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        for value in &self.mosaics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.recipient.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.public_key.as_ref() {
            os.write_bytes(4, &v)?;
        }
        for v in &self.mosaics {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMSignTx_NEMTransfer {
        NEMSignTx_NEMTransfer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "recipient",
                    |m: &NEMSignTx_NEMTransfer| { &m.recipient },
                    |m: &mut NEMSignTx_NEMTransfer| { &mut m.recipient },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "amount",
                    |m: &NEMSignTx_NEMTransfer| { &m.amount },
                    |m: &mut NEMSignTx_NEMTransfer| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &NEMSignTx_NEMTransfer| { &m.payload },
                    |m: &mut NEMSignTx_NEMTransfer| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "public_key",
                    |m: &NEMSignTx_NEMTransfer| { &m.public_key },
                    |m: &mut NEMSignTx_NEMTransfer| { &mut m.public_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NEMSignTx_NEMTransfer_NEMMosaic>>(
                    "mosaics",
                    |m: &NEMSignTx_NEMTransfer| { &m.mosaics },
                    |m: &mut NEMSignTx_NEMTransfer| { &mut m.mosaics },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMSignTx_NEMTransfer>(
                    "NEMSignTx_NEMTransfer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMSignTx_NEMTransfer {
        static mut instance: ::protobuf::lazy::Lazy<NEMSignTx_NEMTransfer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMSignTx_NEMTransfer,
        };
        unsafe {
            instance.get(NEMSignTx_NEMTransfer::new)
        }
    }
}

impl ::protobuf::Clear for NEMSignTx_NEMTransfer {
    fn clear(&mut self) {
        self.recipient.clear();
        self.amount = ::std::option::Option::None;
        self.payload.clear();
        self.public_key.clear();
        self.mosaics.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMSignTx_NEMTransfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx_NEMTransfer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMSignTx_NEMTransfer_NEMMosaic {
    // message fields
    namespace: ::protobuf::SingularField<::std::string::String>,
    mosaic: ::protobuf::SingularField<::std::string::String>,
    quantity: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMSignTx_NEMTransfer_NEMMosaic {
    fn default() -> &'a NEMSignTx_NEMTransfer_NEMMosaic {
        <NEMSignTx_NEMTransfer_NEMMosaic as ::protobuf::Message>::default_instance()
    }
}

impl NEMSignTx_NEMTransfer_NEMMosaic {
    pub fn new() -> NEMSignTx_NEMTransfer_NEMMosaic {
        ::std::default::Default::default()
    }

    // optional string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace.set_default();
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mosaic = 2;


    pub fn get_mosaic(&self) -> &str {
        match self.mosaic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mosaic(&mut self) {
        self.mosaic.clear();
    }

    pub fn has_mosaic(&self) -> bool {
        self.mosaic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mosaic(&mut self, v: ::std::string::String) {
        self.mosaic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mosaic(&mut self) -> &mut ::std::string::String {
        if self.mosaic.is_none() {
            self.mosaic.set_default();
        }
        self.mosaic.as_mut().unwrap()
    }

    // Take field
    pub fn take_mosaic(&mut self) -> ::std::string::String {
        self.mosaic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 quantity = 3;


    pub fn get_quantity(&self) -> u64 {
        self.quantity.unwrap_or(0)
    }
    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u64) {
        self.quantity = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for NEMSignTx_NEMTransfer_NEMMosaic {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.namespace)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mosaic)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.quantity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.mosaic.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.namespace.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.mosaic.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMSignTx_NEMTransfer_NEMMosaic {
        NEMSignTx_NEMTransfer_NEMMosaic::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "namespace",
                    |m: &NEMSignTx_NEMTransfer_NEMMosaic| { &m.namespace },
                    |m: &mut NEMSignTx_NEMTransfer_NEMMosaic| { &mut m.namespace },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mosaic",
                    |m: &NEMSignTx_NEMTransfer_NEMMosaic| { &m.mosaic },
                    |m: &mut NEMSignTx_NEMTransfer_NEMMosaic| { &mut m.mosaic },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "quantity",
                    |m: &NEMSignTx_NEMTransfer_NEMMosaic| { &m.quantity },
                    |m: &mut NEMSignTx_NEMTransfer_NEMMosaic| { &mut m.quantity },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMSignTx_NEMTransfer_NEMMosaic>(
                    "NEMSignTx_NEMTransfer_NEMMosaic",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMSignTx_NEMTransfer_NEMMosaic {
        static mut instance: ::protobuf::lazy::Lazy<NEMSignTx_NEMTransfer_NEMMosaic> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMSignTx_NEMTransfer_NEMMosaic,
        };
        unsafe {
            instance.get(NEMSignTx_NEMTransfer_NEMMosaic::new)
        }
    }
}

impl ::protobuf::Clear for NEMSignTx_NEMTransfer_NEMMosaic {
    fn clear(&mut self) {
        self.namespace.clear();
        self.mosaic.clear();
        self.quantity = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMSignTx_NEMTransfer_NEMMosaic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx_NEMTransfer_NEMMosaic {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMSignTx_NEMProvisionNamespace {
    // message fields
    namespace: ::protobuf::SingularField<::std::string::String>,
    parent: ::protobuf::SingularField<::std::string::String>,
    sink: ::protobuf::SingularField<::std::string::String>,
    fee: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMSignTx_NEMProvisionNamespace {
    fn default() -> &'a NEMSignTx_NEMProvisionNamespace {
        <NEMSignTx_NEMProvisionNamespace as ::protobuf::Message>::default_instance()
    }
}

impl NEMSignTx_NEMProvisionNamespace {
    pub fn new() -> NEMSignTx_NEMProvisionNamespace {
        ::std::default::Default::default()
    }

    // optional string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace.set_default();
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string parent = 2;


    pub fn get_parent(&self) -> &str {
        match self.parent.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        if self.parent.is_none() {
            self.parent.set_default();
        }
        self.parent.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        self.parent.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sink = 3;


    pub fn get_sink(&self) -> &str {
        match self.sink.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sink(&mut self) {
        self.sink.clear();
    }

    pub fn has_sink(&self) -> bool {
        self.sink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sink(&mut self, v: ::std::string::String) {
        self.sink = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sink(&mut self) -> &mut ::std::string::String {
        if self.sink.is_none() {
            self.sink.set_default();
        }
        self.sink.as_mut().unwrap()
    }

    // Take field
    pub fn take_sink(&mut self) -> ::std::string::String {
        self.sink.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 fee = 4;


    pub fn get_fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }
    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for NEMSignTx_NEMProvisionNamespace {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.namespace)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parent)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sink)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.parent.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.sink.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.namespace.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.parent.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.sink.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMSignTx_NEMProvisionNamespace {
        NEMSignTx_NEMProvisionNamespace::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "namespace",
                    |m: &NEMSignTx_NEMProvisionNamespace| { &m.namespace },
                    |m: &mut NEMSignTx_NEMProvisionNamespace| { &mut m.namespace },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parent",
                    |m: &NEMSignTx_NEMProvisionNamespace| { &m.parent },
                    |m: &mut NEMSignTx_NEMProvisionNamespace| { &mut m.parent },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sink",
                    |m: &NEMSignTx_NEMProvisionNamespace| { &m.sink },
                    |m: &mut NEMSignTx_NEMProvisionNamespace| { &mut m.sink },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fee",
                    |m: &NEMSignTx_NEMProvisionNamespace| { &m.fee },
                    |m: &mut NEMSignTx_NEMProvisionNamespace| { &mut m.fee },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMSignTx_NEMProvisionNamespace>(
                    "NEMSignTx_NEMProvisionNamespace",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMSignTx_NEMProvisionNamespace {
        static mut instance: ::protobuf::lazy::Lazy<NEMSignTx_NEMProvisionNamespace> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMSignTx_NEMProvisionNamespace,
        };
        unsafe {
            instance.get(NEMSignTx_NEMProvisionNamespace::new)
        }
    }
}

impl ::protobuf::Clear for NEMSignTx_NEMProvisionNamespace {
    fn clear(&mut self) {
        self.namespace.clear();
        self.parent.clear();
        self.sink.clear();
        self.fee = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMSignTx_NEMProvisionNamespace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx_NEMProvisionNamespace {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMSignTx_NEMMosaicCreation {
    // message fields
    definition: ::protobuf::SingularPtrField<NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition>,
    sink: ::protobuf::SingularField<::std::string::String>,
    fee: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMSignTx_NEMMosaicCreation {
    fn default() -> &'a NEMSignTx_NEMMosaicCreation {
        <NEMSignTx_NEMMosaicCreation as ::protobuf::Message>::default_instance()
    }
}

impl NEMSignTx_NEMMosaicCreation {
    pub fn new() -> NEMSignTx_NEMMosaicCreation {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition definition = 1;


    pub fn get_definition(&self) -> &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
        self.definition.as_ref().unwrap_or_else(|| NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::default_instance())
    }
    pub fn clear_definition(&mut self) {
        self.definition.clear();
    }

    pub fn has_definition(&self) -> bool {
        self.definition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_definition(&mut self, v: NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) {
        self.definition = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_definition(&mut self) -> &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
        if self.definition.is_none() {
            self.definition.set_default();
        }
        self.definition.as_mut().unwrap()
    }

    // Take field
    pub fn take_definition(&mut self) -> NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
        self.definition.take().unwrap_or_else(|| NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::new())
    }

    // optional string sink = 2;


    pub fn get_sink(&self) -> &str {
        match self.sink.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sink(&mut self) {
        self.sink.clear();
    }

    pub fn has_sink(&self) -> bool {
        self.sink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sink(&mut self, v: ::std::string::String) {
        self.sink = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sink(&mut self) -> &mut ::std::string::String {
        if self.sink.is_none() {
            self.sink.set_default();
        }
        self.sink.as_mut().unwrap()
    }

    // Take field
    pub fn take_sink(&mut self) -> ::std::string::String {
        self.sink.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 fee = 3;


    pub fn get_fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }
    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for NEMSignTx_NEMMosaicCreation {
    fn is_initialized(&self) -> bool {
        for v in &self.definition {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.definition)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sink)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.definition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sink.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.definition.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sink.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMSignTx_NEMMosaicCreation {
        NEMSignTx_NEMMosaicCreation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition>>(
                    "definition",
                    |m: &NEMSignTx_NEMMosaicCreation| { &m.definition },
                    |m: &mut NEMSignTx_NEMMosaicCreation| { &mut m.definition },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sink",
                    |m: &NEMSignTx_NEMMosaicCreation| { &m.sink },
                    |m: &mut NEMSignTx_NEMMosaicCreation| { &mut m.sink },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fee",
                    |m: &NEMSignTx_NEMMosaicCreation| { &m.fee },
                    |m: &mut NEMSignTx_NEMMosaicCreation| { &mut m.fee },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMSignTx_NEMMosaicCreation>(
                    "NEMSignTx_NEMMosaicCreation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMSignTx_NEMMosaicCreation {
        static mut instance: ::protobuf::lazy::Lazy<NEMSignTx_NEMMosaicCreation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMSignTx_NEMMosaicCreation,
        };
        unsafe {
            instance.get(NEMSignTx_NEMMosaicCreation::new)
        }
    }
}

impl ::protobuf::Clear for NEMSignTx_NEMMosaicCreation {
    fn clear(&mut self) {
        self.definition.clear();
        self.sink.clear();
        self.fee = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMSignTx_NEMMosaicCreation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx_NEMMosaicCreation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    ticker: ::protobuf::SingularField<::std::string::String>,
    namespace: ::protobuf::SingularField<::std::string::String>,
    mosaic: ::protobuf::SingularField<::std::string::String>,
    divisibility: ::std::option::Option<u32>,
    levy: ::std::option::Option<NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy>,
    fee: ::std::option::Option<u64>,
    levy_address: ::protobuf::SingularField<::std::string::String>,
    levy_namespace: ::protobuf::SingularField<::std::string::String>,
    levy_mosaic: ::protobuf::SingularField<::std::string::String>,
    supply: ::std::option::Option<u64>,
    mutable_supply: ::std::option::Option<bool>,
    transferable: ::std::option::Option<bool>,
    description: ::protobuf::SingularField<::std::string::String>,
    networks: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
    fn default() -> &'a NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
        <NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition as ::protobuf::Message>::default_instance()
    }
}

impl NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
    pub fn new() -> NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ticker = 2;


    pub fn get_ticker(&self) -> &str {
        match self.ticker.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ticker(&mut self) {
        self.ticker.clear();
    }

    pub fn has_ticker(&self) -> bool {
        self.ticker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticker(&mut self, v: ::std::string::String) {
        self.ticker = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticker(&mut self) -> &mut ::std::string::String {
        if self.ticker.is_none() {
            self.ticker.set_default();
        }
        self.ticker.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticker(&mut self) -> ::std::string::String {
        self.ticker.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 3;


    pub fn get_namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace.set_default();
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mosaic = 4;


    pub fn get_mosaic(&self) -> &str {
        match self.mosaic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mosaic(&mut self) {
        self.mosaic.clear();
    }

    pub fn has_mosaic(&self) -> bool {
        self.mosaic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mosaic(&mut self, v: ::std::string::String) {
        self.mosaic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mosaic(&mut self) -> &mut ::std::string::String {
        if self.mosaic.is_none() {
            self.mosaic.set_default();
        }
        self.mosaic.as_mut().unwrap()
    }

    // Take field
    pub fn take_mosaic(&mut self) -> ::std::string::String {
        self.mosaic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 divisibility = 5;


    pub fn get_divisibility(&self) -> u32 {
        self.divisibility.unwrap_or(0)
    }
    pub fn clear_divisibility(&mut self) {
        self.divisibility = ::std::option::Option::None;
    }

    pub fn has_divisibility(&self) -> bool {
        self.divisibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_divisibility(&mut self, v: u32) {
        self.divisibility = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.NEMMosaicLevy levy = 6;


    pub fn get_levy(&self) -> NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy {
        self.levy.unwrap_or(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy::MosaicLevy_Absolute)
    }
    pub fn clear_levy(&mut self) {
        self.levy = ::std::option::Option::None;
    }

    pub fn has_levy(&self) -> bool {
        self.levy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_levy(&mut self, v: NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy) {
        self.levy = ::std::option::Option::Some(v);
    }

    // optional uint64 fee = 7;


    pub fn get_fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }
    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }

    // optional string levy_address = 8;


    pub fn get_levy_address(&self) -> &str {
        match self.levy_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_levy_address(&mut self) {
        self.levy_address.clear();
    }

    pub fn has_levy_address(&self) -> bool {
        self.levy_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_levy_address(&mut self, v: ::std::string::String) {
        self.levy_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_levy_address(&mut self) -> &mut ::std::string::String {
        if self.levy_address.is_none() {
            self.levy_address.set_default();
        }
        self.levy_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_levy_address(&mut self) -> ::std::string::String {
        self.levy_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string levy_namespace = 9;


    pub fn get_levy_namespace(&self) -> &str {
        match self.levy_namespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_levy_namespace(&mut self) {
        self.levy_namespace.clear();
    }

    pub fn has_levy_namespace(&self) -> bool {
        self.levy_namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_levy_namespace(&mut self, v: ::std::string::String) {
        self.levy_namespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_levy_namespace(&mut self) -> &mut ::std::string::String {
        if self.levy_namespace.is_none() {
            self.levy_namespace.set_default();
        }
        self.levy_namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_levy_namespace(&mut self) -> ::std::string::String {
        self.levy_namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string levy_mosaic = 10;


    pub fn get_levy_mosaic(&self) -> &str {
        match self.levy_mosaic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_levy_mosaic(&mut self) {
        self.levy_mosaic.clear();
    }

    pub fn has_levy_mosaic(&self) -> bool {
        self.levy_mosaic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_levy_mosaic(&mut self, v: ::std::string::String) {
        self.levy_mosaic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_levy_mosaic(&mut self) -> &mut ::std::string::String {
        if self.levy_mosaic.is_none() {
            self.levy_mosaic.set_default();
        }
        self.levy_mosaic.as_mut().unwrap()
    }

    // Take field
    pub fn take_levy_mosaic(&mut self) -> ::std::string::String {
        self.levy_mosaic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 supply = 11;


    pub fn get_supply(&self) -> u64 {
        self.supply.unwrap_or(0)
    }
    pub fn clear_supply(&mut self) {
        self.supply = ::std::option::Option::None;
    }

    pub fn has_supply(&self) -> bool {
        self.supply.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supply(&mut self, v: u64) {
        self.supply = ::std::option::Option::Some(v);
    }

    // optional bool mutable_supply = 12;


    pub fn get_mutable_supply(&self) -> bool {
        self.mutable_supply.unwrap_or(false)
    }
    pub fn clear_mutable_supply(&mut self) {
        self.mutable_supply = ::std::option::Option::None;
    }

    pub fn has_mutable_supply(&self) -> bool {
        self.mutable_supply.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mutable_supply(&mut self, v: bool) {
        self.mutable_supply = ::std::option::Option::Some(v);
    }

    // optional bool transferable = 13;


    pub fn get_transferable(&self) -> bool {
        self.transferable.unwrap_or(false)
    }
    pub fn clear_transferable(&mut self) {
        self.transferable = ::std::option::Option::None;
    }

    pub fn has_transferable(&self) -> bool {
        self.transferable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transferable(&mut self, v: bool) {
        self.transferable = ::std::option::Option::Some(v);
    }

    // optional string description = 14;


    pub fn get_description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated uint32 networks = 15;


    pub fn get_networks(&self) -> &[u32] {
        &self.networks
    }
    pub fn clear_networks(&mut self) {
        self.networks.clear();
    }

    // Param is passed by value, moved
    pub fn set_networks(&mut self, v: ::std::vec::Vec<u32>) {
        self.networks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_networks(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.networks
    }

    // Take field
    pub fn take_networks(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.networks, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ticker)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.namespace)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mosaic)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.divisibility = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.levy, 6, &mut self.unknown_fields)?
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.levy_address)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.levy_namespace)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.levy_mosaic)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.supply = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mutable_supply = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.transferable = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.description)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.networks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.ticker.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.mosaic.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.divisibility {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.levy {
            my_size += ::protobuf::rt::enum_size(6, v);
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.levy_address.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.levy_namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.levy_mosaic.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.supply {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mutable_supply {
            my_size += 2;
        }
        if let Some(v) = self.transferable {
            my_size += 2;
        }
        if let Some(ref v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        for value in &self.networks {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.ticker.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.namespace.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.mosaic.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.divisibility {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.levy {
            os.write_enum(6, v.value())?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(7, v)?;
        }
        if let Some(ref v) = self.levy_address.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.levy_namespace.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.levy_mosaic.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.supply {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.mutable_supply {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.transferable {
            os.write_bool(13, v)?;
        }
        if let Some(ref v) = self.description.as_ref() {
            os.write_string(14, &v)?;
        }
        for v in &self.networks {
            os.write_uint32(15, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
        NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.name },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ticker",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.ticker },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.ticker },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "namespace",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.namespace },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.namespace },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mosaic",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.mosaic },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.mosaic },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "divisibility",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.divisibility },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.divisibility },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy>>(
                    "levy",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.levy },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.levy },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fee",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.fee },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "levy_address",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.levy_address },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.levy_address },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "levy_namespace",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.levy_namespace },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.levy_namespace },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "levy_mosaic",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.levy_mosaic },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.levy_mosaic },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "supply",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.supply },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.supply },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "mutable_supply",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.mutable_supply },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.mutable_supply },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "transferable",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.transferable },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.transferable },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.description },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "networks",
                    |m: &NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &m.networks },
                    |m: &mut NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition| { &mut m.networks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition>(
                    "NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
        static mut instance: ::protobuf::lazy::Lazy<NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition,
        };
        unsafe {
            instance.get(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition::new)
        }
    }
}

impl ::protobuf::Clear for NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
    fn clear(&mut self) {
        self.name.clear();
        self.ticker.clear();
        self.namespace.clear();
        self.mosaic.clear();
        self.divisibility = ::std::option::Option::None;
        self.levy = ::std::option::Option::None;
        self.fee = ::std::option::Option::None;
        self.levy_address.clear();
        self.levy_namespace.clear();
        self.levy_mosaic.clear();
        self.supply = ::std::option::Option::None;
        self.mutable_supply = ::std::option::Option::None;
        self.transferable = ::std::option::Option::None;
        self.description.clear();
        self.networks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy {
    MosaicLevy_Absolute = 1,
    MosaicLevy_Percentile = 2,
}

impl ::protobuf::ProtobufEnum for NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy> {
        match value {
            1 => ::std::option::Option::Some(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy::MosaicLevy_Absolute),
            2 => ::std::option::Option::Some(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy::MosaicLevy_Percentile),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy] = &[
            NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy::MosaicLevy_Absolute,
            NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy::MosaicLevy_Percentile,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy {
    fn default() -> Self {
        NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy::MosaicLevy_Absolute
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMSignTx_NEMMosaicSupplyChange {
    // message fields
    namespace: ::protobuf::SingularField<::std::string::String>,
    mosaic: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType>,
    delta: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMSignTx_NEMMosaicSupplyChange {
    fn default() -> &'a NEMSignTx_NEMMosaicSupplyChange {
        <NEMSignTx_NEMMosaicSupplyChange as ::protobuf::Message>::default_instance()
    }
}

impl NEMSignTx_NEMMosaicSupplyChange {
    pub fn new() -> NEMSignTx_NEMMosaicSupplyChange {
        ::std::default::Default::default()
    }

    // optional string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace.set_default();
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mosaic = 2;


    pub fn get_mosaic(&self) -> &str {
        match self.mosaic.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mosaic(&mut self) {
        self.mosaic.clear();
    }

    pub fn has_mosaic(&self) -> bool {
        self.mosaic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mosaic(&mut self, v: ::std::string::String) {
        self.mosaic = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mosaic(&mut self) -> &mut ::std::string::String {
        if self.mosaic.is_none() {
            self.mosaic.set_default();
        }
        self.mosaic.as_mut().unwrap()
    }

    // Take field
    pub fn take_mosaic(&mut self) -> ::std::string::String {
        self.mosaic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.NEMSupplyChangeType type = 3;


    pub fn get_field_type(&self) -> NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType {
        self.field_type.unwrap_or(NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType::SupplyChange_Increase)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional uint64 delta = 4;


    pub fn get_delta(&self) -> u64 {
        self.delta.unwrap_or(0)
    }
    pub fn clear_delta(&mut self) {
        self.delta = ::std::option::Option::None;
    }

    pub fn has_delta(&self) -> bool {
        self.delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta(&mut self, v: u64) {
        self.delta = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for NEMSignTx_NEMMosaicSupplyChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.namespace)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mosaic)?;
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.delta = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.mosaic.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        if let Some(v) = self.delta {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.namespace.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.mosaic.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.field_type {
            os.write_enum(3, v.value())?;
        }
        if let Some(v) = self.delta {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMSignTx_NEMMosaicSupplyChange {
        NEMSignTx_NEMMosaicSupplyChange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "namespace",
                    |m: &NEMSignTx_NEMMosaicSupplyChange| { &m.namespace },
                    |m: &mut NEMSignTx_NEMMosaicSupplyChange| { &mut m.namespace },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mosaic",
                    |m: &NEMSignTx_NEMMosaicSupplyChange| { &m.mosaic },
                    |m: &mut NEMSignTx_NEMMosaicSupplyChange| { &mut m.mosaic },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType>>(
                    "type",
                    |m: &NEMSignTx_NEMMosaicSupplyChange| { &m.field_type },
                    |m: &mut NEMSignTx_NEMMosaicSupplyChange| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "delta",
                    |m: &NEMSignTx_NEMMosaicSupplyChange| { &m.delta },
                    |m: &mut NEMSignTx_NEMMosaicSupplyChange| { &mut m.delta },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMSignTx_NEMMosaicSupplyChange>(
                    "NEMSignTx_NEMMosaicSupplyChange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMSignTx_NEMMosaicSupplyChange {
        static mut instance: ::protobuf::lazy::Lazy<NEMSignTx_NEMMosaicSupplyChange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMSignTx_NEMMosaicSupplyChange,
        };
        unsafe {
            instance.get(NEMSignTx_NEMMosaicSupplyChange::new)
        }
    }
}

impl ::protobuf::Clear for NEMSignTx_NEMMosaicSupplyChange {
    fn clear(&mut self) {
        self.namespace.clear();
        self.mosaic.clear();
        self.field_type = ::std::option::Option::None;
        self.delta = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMSignTx_NEMMosaicSupplyChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx_NEMMosaicSupplyChange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType {
    SupplyChange_Increase = 1,
    SupplyChange_Decrease = 2,
}

impl ::protobuf::ProtobufEnum for NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType> {
        match value {
            1 => ::std::option::Option::Some(NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType::SupplyChange_Increase),
            2 => ::std::option::Option::Some(NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType::SupplyChange_Decrease),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType] = &[
            NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType::SupplyChange_Increase,
            NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType::SupplyChange_Decrease,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType {
    fn default() -> Self {
        NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType::SupplyChange_Increase
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMSignTx_NEMAggregateModification {
    // message fields
    modifications: ::protobuf::RepeatedField<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification>,
    relative_change: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMSignTx_NEMAggregateModification {
    fn default() -> &'a NEMSignTx_NEMAggregateModification {
        <NEMSignTx_NEMAggregateModification as ::protobuf::Message>::default_instance()
    }
}

impl NEMSignTx_NEMAggregateModification {
    pub fn new() -> NEMSignTx_NEMAggregateModification {
        ::std::default::Default::default()
    }

    // repeated .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification modifications = 1;


    pub fn get_modifications(&self) -> &[NEMSignTx_NEMAggregateModification_NEMCosignatoryModification] {
        &self.modifications
    }
    pub fn clear_modifications(&mut self) {
        self.modifications.clear();
    }

    // Param is passed by value, moved
    pub fn set_modifications(&mut self, v: ::protobuf::RepeatedField<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification>) {
        self.modifications = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modifications(&mut self) -> &mut ::protobuf::RepeatedField<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification> {
        &mut self.modifications
    }

    // Take field
    pub fn take_modifications(&mut self) -> ::protobuf::RepeatedField<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification> {
        ::std::mem::replace(&mut self.modifications, ::protobuf::RepeatedField::new())
    }

    // optional sint32 relative_change = 2;


    pub fn get_relative_change(&self) -> i32 {
        self.relative_change.unwrap_or(0)
    }
    pub fn clear_relative_change(&mut self) {
        self.relative_change = ::std::option::Option::None;
    }

    pub fn has_relative_change(&self) -> bool {
        self.relative_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relative_change(&mut self, v: i32) {
        self.relative_change = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for NEMSignTx_NEMAggregateModification {
    fn is_initialized(&self) -> bool {
        for v in &self.modifications {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.modifications)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.relative_change = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.modifications {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.relative_change {
            my_size += ::protobuf::rt::value_varint_zigzag_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.modifications {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.relative_change {
            os.write_sint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMSignTx_NEMAggregateModification {
        NEMSignTx_NEMAggregateModification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification>>(
                    "modifications",
                    |m: &NEMSignTx_NEMAggregateModification| { &m.modifications },
                    |m: &mut NEMSignTx_NEMAggregateModification| { &mut m.modifications },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                    "relative_change",
                    |m: &NEMSignTx_NEMAggregateModification| { &m.relative_change },
                    |m: &mut NEMSignTx_NEMAggregateModification| { &mut m.relative_change },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMSignTx_NEMAggregateModification>(
                    "NEMSignTx_NEMAggregateModification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMSignTx_NEMAggregateModification {
        static mut instance: ::protobuf::lazy::Lazy<NEMSignTx_NEMAggregateModification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMSignTx_NEMAggregateModification,
        };
        unsafe {
            instance.get(NEMSignTx_NEMAggregateModification::new)
        }
    }
}

impl ::protobuf::Clear for NEMSignTx_NEMAggregateModification {
    fn clear(&mut self) {
        self.modifications.clear();
        self.relative_change = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMSignTx_NEMAggregateModification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx_NEMAggregateModification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMSignTx_NEMAggregateModification_NEMCosignatoryModification {
    // message fields
    field_type: ::std::option::Option<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType>,
    public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMSignTx_NEMAggregateModification_NEMCosignatoryModification {
    fn default() -> &'a NEMSignTx_NEMAggregateModification_NEMCosignatoryModification {
        <NEMSignTx_NEMAggregateModification_NEMCosignatoryModification as ::protobuf::Message>::default_instance()
    }
}

impl NEMSignTx_NEMAggregateModification_NEMCosignatoryModification {
    pub fn new() -> NEMSignTx_NEMAggregateModification_NEMCosignatoryModification {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.NEMModificationType type = 1;


    pub fn get_field_type(&self) -> NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType {
        self.field_type.unwrap_or(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType::CosignatoryModification_Add)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional bytes public_key = 2;


    pub fn get_public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key.set_default();
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NEMSignTx_NEMAggregateModification_NEMCosignatoryModification {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.public_key.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMSignTx_NEMAggregateModification_NEMCosignatoryModification {
        NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType>>(
                    "type",
                    |m: &NEMSignTx_NEMAggregateModification_NEMCosignatoryModification| { &m.field_type },
                    |m: &mut NEMSignTx_NEMAggregateModification_NEMCosignatoryModification| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "public_key",
                    |m: &NEMSignTx_NEMAggregateModification_NEMCosignatoryModification| { &m.public_key },
                    |m: &mut NEMSignTx_NEMAggregateModification_NEMCosignatoryModification| { &mut m.public_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification>(
                    "NEMSignTx_NEMAggregateModification_NEMCosignatoryModification",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMSignTx_NEMAggregateModification_NEMCosignatoryModification {
        static mut instance: ::protobuf::lazy::Lazy<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMSignTx_NEMAggregateModification_NEMCosignatoryModification,
        };
        unsafe {
            instance.get(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification::new)
        }
    }
}

impl ::protobuf::Clear for NEMSignTx_NEMAggregateModification_NEMCosignatoryModification {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMSignTx_NEMAggregateModification_NEMCosignatoryModification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx_NEMAggregateModification_NEMCosignatoryModification {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType {
    CosignatoryModification_Add = 1,
    CosignatoryModification_Delete = 2,
}

impl ::protobuf::ProtobufEnum for NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType> {
        match value {
            1 => ::std::option::Option::Some(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType::CosignatoryModification_Add),
            2 => ::std::option::Option::Some(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType::CosignatoryModification_Delete),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType] = &[
            NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType::CosignatoryModification_Add,
            NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType::CosignatoryModification_Delete,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType {
    fn default() -> Self {
        NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType::CosignatoryModification_Add
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMSignTx_NEMImportanceTransfer {
    // message fields
    mode: ::std::option::Option<NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode>,
    public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMSignTx_NEMImportanceTransfer {
    fn default() -> &'a NEMSignTx_NEMImportanceTransfer {
        <NEMSignTx_NEMImportanceTransfer as ::protobuf::Message>::default_instance()
    }
}

impl NEMSignTx_NEMImportanceTransfer {
    pub fn new() -> NEMSignTx_NEMImportanceTransfer {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.NEMImportanceTransferMode mode = 1;


    pub fn get_mode(&self) -> NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode {
        self.mode.unwrap_or(NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode::ImportanceTransfer_Activate)
    }
    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode) {
        self.mode = ::std::option::Option::Some(v);
    }

    // optional bytes public_key = 2;


    pub fn get_public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key.set_default();
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NEMSignTx_NEMImportanceTransfer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mode {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.public_key.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMSignTx_NEMImportanceTransfer {
        NEMSignTx_NEMImportanceTransfer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode>>(
                    "mode",
                    |m: &NEMSignTx_NEMImportanceTransfer| { &m.mode },
                    |m: &mut NEMSignTx_NEMImportanceTransfer| { &mut m.mode },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "public_key",
                    |m: &NEMSignTx_NEMImportanceTransfer| { &m.public_key },
                    |m: &mut NEMSignTx_NEMImportanceTransfer| { &mut m.public_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMSignTx_NEMImportanceTransfer>(
                    "NEMSignTx_NEMImportanceTransfer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMSignTx_NEMImportanceTransfer {
        static mut instance: ::protobuf::lazy::Lazy<NEMSignTx_NEMImportanceTransfer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMSignTx_NEMImportanceTransfer,
        };
        unsafe {
            instance.get(NEMSignTx_NEMImportanceTransfer::new)
        }
    }
}

impl ::protobuf::Clear for NEMSignTx_NEMImportanceTransfer {
    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMSignTx_NEMImportanceTransfer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx_NEMImportanceTransfer {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode {
    ImportanceTransfer_Activate = 1,
    ImportanceTransfer_Deactivate = 2,
}

impl ::protobuf::ProtobufEnum for NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode> {
        match value {
            1 => ::std::option::Option::Some(NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode::ImportanceTransfer_Activate),
            2 => ::std::option::Option::Some(NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode::ImportanceTransfer_Deactivate),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode] = &[
            NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode::ImportanceTransfer_Activate,
            NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode::ImportanceTransfer_Deactivate,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode {
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode {
    fn default() -> Self {
        NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode::ImportanceTransfer_Activate
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMSignedTx {
    // message fields
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMSignedTx {
    fn default() -> &'a NEMSignedTx {
        <NEMSignedTx as ::protobuf::Message>::default_instance()
    }
}

impl NEMSignedTx {
    pub fn new() -> NEMSignedTx {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes signature = 2;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NEMSignedTx {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMSignedTx {
        NEMSignedTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &NEMSignedTx| { &m.data },
                    |m: &mut NEMSignedTx| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "signature",
                    |m: &NEMSignedTx| { &m.signature },
                    |m: &mut NEMSignedTx| { &mut m.signature },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMSignedTx>(
                    "NEMSignedTx",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMSignedTx {
        static mut instance: ::protobuf::lazy::Lazy<NEMSignedTx> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMSignedTx,
        };
        unsafe {
            instance.get(NEMSignedTx::new)
        }
    }
}

impl ::protobuf::Clear for NEMSignedTx {
    fn clear(&mut self) {
        self.data.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMSignedTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMSignedTx {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMDecryptMessage {
    // message fields
    address_n: ::std::vec::Vec<u32>,
    network: ::std::option::Option<u32>,
    public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMDecryptMessage {
    fn default() -> &'a NEMDecryptMessage {
        <NEMDecryptMessage as ::protobuf::Message>::default_instance()
    }
}

impl NEMDecryptMessage {
    pub fn new() -> NEMDecryptMessage {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional uint32 network = 2;


    pub fn get_network(&self) -> u32 {
        self.network.unwrap_or(0)
    }
    pub fn clear_network(&mut self) {
        self.network = ::std::option::Option::None;
    }

    pub fn has_network(&self) -> bool {
        self.network.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: u32) {
        self.network = ::std::option::Option::Some(v);
    }

    // optional bytes public_key = 3;


    pub fn get_public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key.set_default();
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes payload = 4;


    pub fn get_payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NEMDecryptMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.network {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.network {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.public_key.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMDecryptMessage {
        NEMDecryptMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address_n",
                    |m: &NEMDecryptMessage| { &m.address_n },
                    |m: &mut NEMDecryptMessage| { &mut m.address_n },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "network",
                    |m: &NEMDecryptMessage| { &m.network },
                    |m: &mut NEMDecryptMessage| { &mut m.network },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "public_key",
                    |m: &NEMDecryptMessage| { &m.public_key },
                    |m: &mut NEMDecryptMessage| { &mut m.public_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &NEMDecryptMessage| { &m.payload },
                    |m: &mut NEMDecryptMessage| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMDecryptMessage>(
                    "NEMDecryptMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMDecryptMessage {
        static mut instance: ::protobuf::lazy::Lazy<NEMDecryptMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMDecryptMessage,
        };
        unsafe {
            instance.get(NEMDecryptMessage::new)
        }
    }
}

impl ::protobuf::Clear for NEMDecryptMessage {
    fn clear(&mut self) {
        self.address_n.clear();
        self.network = ::std::option::Option::None;
        self.public_key.clear();
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMDecryptMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMDecryptMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NEMDecryptedMessage {
    // message fields
    payload: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NEMDecryptedMessage {
    fn default() -> &'a NEMDecryptedMessage {
        <NEMDecryptedMessage as ::protobuf::Message>::default_instance()
    }
}

impl NEMDecryptedMessage {
    pub fn new() -> NEMDecryptedMessage {
        ::std::default::Default::default()
    }

    // optional bytes payload = 1;


    pub fn get_payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NEMDecryptedMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.payload.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NEMDecryptedMessage {
        NEMDecryptedMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &NEMDecryptedMessage| { &m.payload },
                    |m: &mut NEMDecryptedMessage| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NEMDecryptedMessage>(
                    "NEMDecryptedMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NEMDecryptedMessage {
        static mut instance: ::protobuf::lazy::Lazy<NEMDecryptedMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NEMDecryptedMessage,
        };
        unsafe {
            instance.get(NEMDecryptedMessage::new)
        }
    }
}

impl ::protobuf::Clear for NEMDecryptedMessage {
    fn clear(&mut self) {
        self.payload.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NEMDecryptedMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NEMDecryptedMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12messages-nem.proto\x12\x16hw.trezor.messages.nem\"i\n\rNEMGetAddre\
    ss\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12\x18\n\x07net\
    work\x18\x02\x20\x01(\rR\x07network\x12!\n\x0cshow_display\x18\x03\x20\
    \x01(\x08R\x0bshowDisplay\"&\n\nNEMAddress\x12\x18\n\x07address\x18\x01\
    \x20\x02(\tR\x07address\"\x81\x19\n\tNEMSignTx\x12X\n\x0btransaction\x18\
    \x01\x20\x01(\x0b26.hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommo\
    nR\x0btransaction\x12R\n\x08multisig\x18\x02\x20\x01(\x0b26.hw.trezor.me\
    ssages.nem.NEMSignTx.NEMTransactionCommonR\x08multisig\x12I\n\x08transfe\
    r\x18\x03\x20\x01(\x0b2-.hw.trezor.messages.nem.NEMSignTx.NEMTransferR\
    \x08transfer\x12\x1c\n\tcosigning\x18\x04\x20\x01(\x08R\tcosigning\x12h\
    \n\x13provision_namespace\x18\x05\x20\x01(\x0b27.hw.trezor.messages.nem.\
    NEMSignTx.NEMProvisionNamespaceR\x12provisionNamespace\x12\\\n\x0fmosaic\
    _creation\x18\x06\x20\x01(\x0b23.hw.trezor.messages.nem.NEMSignTx.NEMMos\
    aicCreationR\x0emosaicCreation\x12\\\n\rsupply_change\x18\x07\x20\x01(\
    \x0b27.hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChangeR\x0csupply\
    Change\x12q\n\x16aggregate_modification\x18\x08\x20\x01(\x0b2:.hw.trezor\
    .messages.nem.NEMSignTx.NEMAggregateModificationR\x15aggregateModificati\
    on\x12h\n\x13importance_transfer\x18\t\x20\x01(\x0b27.hw.trezor.messages\
    .nem.NEMSignTx.NEMImportanceTransferR\x12importanceTransfer\x1a\xb1\x01\
    \n\x14NEMTransactionCommon\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08a\
    ddressN\x12\x18\n\x07network\x18\x02\x20\x01(\rR\x07network\x12\x1c\n\tt\
    imestamp\x18\x03\x20\x01(\rR\ttimestamp\x12\x10\n\x03fee\x18\x04\x20\x01\
    (\x04R\x03fee\x12\x1a\n\x08deadline\x18\x05\x20\x01(\rR\x08deadline\x12\
    \x16\n\x06signer\x18\x06\x20\x01(\x0cR\x06signer\x1a\xae\x02\n\x0bNEMTra\
    nsfer\x12\x1c\n\trecipient\x18\x01\x20\x01(\tR\trecipient\x12\x16\n\x06a\
    mount\x18\x02\x20\x01(\x04R\x06amount\x12\x18\n\x07payload\x18\x03\x20\
    \x01(\x0cR\x07payload\x12\x1d\n\npublic_key\x18\x04\x20\x01(\x0cR\tpubli\
    cKey\x12Q\n\x07mosaics\x18\x05\x20\x03(\x0b27.hw.trezor.messages.nem.NEM\
    SignTx.NEMTransfer.NEMMosaicR\x07mosaics\x1a]\n\tNEMMosaic\x12\x1c\n\tna\
    mespace\x18\x01\x20\x01(\tR\tnamespace\x12\x16\n\x06mosaic\x18\x02\x20\
    \x01(\tR\x06mosaic\x12\x1a\n\x08quantity\x18\x03\x20\x01(\x04R\x08quanti\
    ty\x1as\n\x15NEMProvisionNamespace\x12\x1c\n\tnamespace\x18\x01\x20\x01(\
    \tR\tnamespace\x12\x16\n\x06parent\x18\x02\x20\x01(\tR\x06parent\x12\x12\
    \n\x04sink\x18\x03\x20\x01(\tR\x04sink\x12\x10\n\x03fee\x18\x04\x20\x01(\
    \x04R\x03fee\x1a\x8e\x06\n\x11NEMMosaicCreation\x12g\n\ndefinition\x18\
    \x01\x20\x01(\x0b2G.hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.N\
    EMMosaicDefinitionR\ndefinition\x12\x12\n\x04sink\x18\x02\x20\x01(\tR\
    \x04sink\x12\x10\n\x03fee\x18\x03\x20\x01(\x04R\x03fee\x1a\xe9\x04\n\x13\
    NEMMosaicDefinition\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x16\n\x06ticker\x18\x02\x20\x01(\tR\x06ticker\x12\x1c\n\tnamespace\x18\
    \x03\x20\x01(\tR\tnamespace\x12\x16\n\x06mosaic\x18\x04\x20\x01(\tR\x06m\
    osaic\x12\"\n\x0cdivisibility\x18\x05\x20\x01(\rR\x0cdivisibility\x12i\n\
    \x04levy\x18\x06\x20\x01(\x0e2U.hw.trezor.messages.nem.NEMSignTx.NEMMosa\
    icCreation.NEMMosaicDefinition.NEMMosaicLevyR\x04levy\x12\x10\n\x03fee\
    \x18\x07\x20\x01(\x04R\x03fee\x12!\n\x0clevy_address\x18\x08\x20\x01(\tR\
    \x0blevyAddress\x12%\n\x0elevy_namespace\x18\t\x20\x01(\tR\rlevyNamespac\
    e\x12\x1f\n\x0blevy_mosaic\x18\n\x20\x01(\tR\nlevyMosaic\x12\x16\n\x06su\
    pply\x18\x0b\x20\x01(\x04R\x06supply\x12%\n\x0emutable_supply\x18\x0c\
    \x20\x01(\x08R\rmutableSupply\x12\"\n\x0ctransferable\x18\r\x20\x01(\x08\
    R\x0ctransferable\x12\x20\n\x0bdescription\x18\x0e\x20\x01(\tR\x0bdescri\
    ption\x12\x1a\n\x08networks\x18\x0f\x20\x03(\rR\x08networks\"C\n\rNEMMos\
    aicLevy\x12\x17\n\x13MosaicLevy_Absolute\x10\x01\x12\x19\n\x15MosaicLevy\
    _Percentile\x10\x02\x1a\x91\x02\n\x15NEMMosaicSupplyChange\x12\x1c\n\tna\
    mespace\x18\x01\x20\x01(\tR\tnamespace\x12\x16\n\x06mosaic\x18\x02\x20\
    \x01(\tR\x06mosaic\x12_\n\x04type\x18\x03\x20\x01(\x0e2K.hw.trezor.messa\
    ges.nem.NEMSignTx.NEMMosaicSupplyChange.NEMSupplyChangeTypeR\x04type\x12\
    \x14\n\x05delta\x18\x04\x20\x01(\x04R\x05delta\"K\n\x13NEMSupplyChangeTy\
    pe\x12\x19\n\x15SupplyChange_Increase\x10\x01\x12\x19\n\x15SupplyChange_\
    Decrease\x10\x02\x1a\xd9\x03\n\x18NEMAggregateModification\x12{\n\rmodif\
    ications\x18\x01\x20\x03(\x0b2U.hw.trezor.messages.nem.NEMSignTx.NEMAggr\
    egateModification.NEMCosignatoryModificationR\rmodifications\x12'\n\x0fr\
    elative_change\x18\x02\x20\x01(\x11R\x0erelativeChange\x1a\x96\x02\n\x1a\
    NEMCosignatoryModification\x12}\n\x04type\x18\x01\x20\x01(\x0e2i.hw.trez\
    or.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModific\
    ation.NEMModificationTypeR\x04type\x12\x1d\n\npublic_key\x18\x02\x20\x01\
    (\x0cR\tpublicKey\"Z\n\x13NEMModificationType\x12\x1f\n\x1bCosignatoryMo\
    dification_Add\x10\x01\x12\"\n\x1eCosignatoryModification_Delete\x10\x02\
    \x1a\xfe\x01\n\x15NEMImportanceTransfer\x12e\n\x04mode\x18\x01\x20\x01(\
    \x0e2Q.hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.NEMImporta\
    nceTransferModeR\x04mode\x12\x1d\n\npublic_key\x18\x02\x20\x01(\x0cR\tpu\
    blicKey\"_\n\x19NEMImportanceTransferMode\x12\x1f\n\x1bImportanceTransfe\
    r_Activate\x10\x01\x12!\n\x1dImportanceTransfer_Deactivate\x10\x02\"?\n\
    \x0bNEMSignedTx\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x1c\
    \n\tsignature\x18\x02\x20\x01(\x0cR\tsignature\"\x83\x01\n\x11NEMDecrypt\
    Message\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12\x18\n\
    \x07network\x18\x02\x20\x01(\rR\x07network\x12\x1d\n\npublic_key\x18\x03\
    \x20\x01(\x0cR\tpublicKey\x12\x18\n\x07payload\x18\x04\x20\x01(\x0cR\x07\
    payload\"/\n\x13NEMDecryptedMessage\x12\x18\n\x07payload\x18\x01\x20\x01\
    (\x0cR\x07payloadB7\n#com.satoshilabs.trezor.lib.protobufB\x10TrezorMess\
    ageNemJ\xf1Q\n\x07\x12\x05\0\0\xc5\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\
    \x12\n\x08\n\x01\x02\x12\x03\x01\x08\x1e\n\x08\n\x01\x08\x12\x03\x04\0<\
    \n.\n\x02\x08\x01\x12\x03\x04\0<\x1a#\x20Sugar\x20for\x20easier\x20handl\
    ing\x20in\x20Java\n\n\x08\n\x01\x08\x12\x03\x05\01\n\t\n\x02\x08\x08\x12\
    \x03\x05\01\n|\n\x02\x04\0\x12\x04\r\0\x11\x01\x1ap*\n\x20Request:\x20As\
    k\x20device\x20for\x20NEM\x20address\x20corresponding\x20to\x20address_n\
    \x20path\n\x20@start\n\x20@next\x20NEMAddress\n\x20@next\x20Failure\n\n\
    \n\n\x03\x04\0\x01\x12\x03\r\x08\x15\n=\n\x04\x04\0\x02\0\x12\x03\x0e\
    \x04\"\"0\x20BIP-32\x20path\x20to\x20derive\x20the\x20key\x20from\x20mas\
    ter\x20node\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x0e\x04\x0c\n\x0c\n\
    \x05\x04\0\x02\0\x05\x12\x03\x0e\r\x13\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x03\x0e\x14\x1d\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x0e\x20!\nH\n\x04\
    \x04\0\x02\x01\x12\x03\x0f\x04\x20\";\x20Network\x20ID\x20(0x68\x20=\x20\
    Mainnet,\x200x98\x20=\x20Testnet,\x200x60\x20=\x20Mijin)\n\n\x0c\n\x05\
    \x04\0\x02\x01\x04\x12\x03\x0f\x04\x0c\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x03\x0f\r\x13\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x0f\x14\x1b\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x03\x0f\x1e\x1f\nC\n\x04\x04\0\x02\x02\x12\
    \x03\x10\x04#\"6\x20Optionally\x20show\x20on\x20display\x20before\x20sen\
    ding\x20the\x20result\n\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\x10\x04\
    \x0c\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x10\r\x11\n\x0c\n\x05\x04\0\
    \x02\x02\x01\x12\x03\x10\x12\x1e\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\
    \x10!\"\nU\n\x02\x04\x01\x12\x04\x17\0\x19\x01\x1aI*\n\x20Response:\x20C\
    ontains\x20NEM\x20address\x20derived\x20from\x20device\x20private\x20see\
    d\n\x20@end\n\n\n\n\x03\x04\x01\x01\x12\x03\x17\x08\x12\n-\n\x04\x04\x01\
    \x02\0\x12\x03\x18\x04\x20\"\x20\x20NEM\x20address\x20in\x20Base32\x20en\
    coding\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x18\x04\x0c\n\x0c\n\x05\
    \x04\x01\x02\0\x05\x12\x03\x18\r\x13\n\x0c\n\x05\x04\x01\x02\0\x01\x12\
    \x03\x18\x14\x1b\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x18\x1e\x1f\nb\n\
    \x02\x04\x02\x12\x05!\0\xa7\x01\x01\x1aU*\n\x20Request:\x20Ask\x20device\
    \x20to\x20sign\x20transaction\n\x20@start\n\x20@next\x20NEMSignedTx\n\
    \x20@next\x20Failure\n\n\n\n\x03\x04\x02\x01\x12\x03!\x08\x11\n)\n\x04\
    \x04\x02\x02\0\x12\x03\"\x042\"\x1c\x20Common\x20part\x20of\x20transacti\
    on\n\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03\"\x04\x0c\n\x0c\n\x05\x04\x02\
    \x02\0\x06\x12\x03\"\r!\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\"\"-\n\x0c\
    \n\x05\x04\x02\x02\0\x03\x12\x03\"01\nI\n\x04\x04\x02\x02\x01\x12\x03#\
    \x04/\"<\x20Common\x20part\x20of\x20inner\x20transaction\x20for\x20multi\
    sig\x20transactions\n\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03#\x04\x0c\n\
    \x0c\n\x05\x04\x02\x02\x01\x06\x12\x03#\r!\n\x0c\n\x05\x04\x02\x02\x01\
    \x01\x12\x03#\"*\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03#-.\n(\n\x04\x04\
    \x02\x02\x02\x12\x03$\x04&\"\x1b\x20Transfer\x20transaction\x20part\n\n\
    \x0c\n\x05\x04\x02\x02\x02\x04\x12\x03$\x04\x0c\n\x0c\n\x05\x04\x02\x02\
    \x02\x06\x12\x03$\r\x18\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03$\x19!\n\
    \x0c\n\x05\x04\x02\x02\x02\x03\x12\x03$$%\nG\n\x04\x04\x02\x02\x03\x12\
    \x03%\x04\x20\":\x20Whether\x20cosigning\x20or\x20initiating\x20the\x20m\
    ultisig\x20transaction\n\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03%\x04\
    \x0c\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03%\r\x11\n\x0c\n\x05\x04\x02\
    \x02\x03\x01\x12\x03%\x12\x1b\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03%\
    \x1e\x1f\n'\n\x04\x04\x02\x02\x04\x12\x03&\x04;\"\x1a\x20Provision\x20na\
    mespace\x20part\n\n\x0c\n\x05\x04\x02\x02\x04\x04\x12\x03&\x04\x0c\n\x0c\
    \n\x05\x04\x02\x02\x04\x06\x12\x03&\r\"\n\x0c\n\x05\x04\x02\x02\x04\x01\
    \x12\x03&#6\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03&9:\n.\n\x04\x04\x02\
    \x02\x05\x12\x03'\x043\"!\x20Mosaic\x20definition\x20creation\x20part\n\
    \n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x03'\x04\x0c\n\x0c\n\x05\x04\x02\
    \x02\x05\x06\x12\x03'\r\x1e\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03'\x1f\
    .\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03'12\n(\n\x04\x04\x02\x02\x06\
    \x12\x03(\x045\"\x1b\x20Mosaic\x20supply\x20change\x20part\n\n\x0c\n\x05\
    \x04\x02\x02\x06\x04\x12\x03(\x04\x0c\n\x0c\n\x05\x04\x02\x02\x06\x06\
    \x12\x03(\r\"\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03(#0\n\x0c\n\x05\x04\
    \x02\x02\x06\x03\x12\x03(34\n*\n\x04\x04\x02\x02\x07\x12\x03)\x04A\"\x1d\
    \x20Aggregate\x20modification\x20part\n\n\x0c\n\x05\x04\x02\x02\x07\x04\
    \x12\x03)\x04\x0c\n\x0c\n\x05\x04\x02\x02\x07\x06\x12\x03)\r%\n\x0c\n\
    \x05\x04\x02\x02\x07\x01\x12\x03)&<\n\x0c\n\x05\x04\x02\x02\x07\x03\x12\
    \x03)?@\n'\n\x04\x04\x02\x02\x08\x12\x03*\x04;\"\x1a\x20Importance\x20tr\
    ansfer\x20part\n\n\x0c\n\x05\x04\x02\x02\x08\x04\x12\x03*\x04\x0c\n\x0c\
    \n\x05\x04\x02\x02\x08\x06\x12\x03*\r\"\n\x0c\n\x05\x04\x02\x02\x08\x01\
    \x12\x03*#6\n\x0c\n\x05\x04\x02\x02\x08\x03\x12\x03*9:\nM\n\x04\x04\x02\
    \x03\0\x12\x04.\x045\x05\x1a?*\n\x20Structure\x20representing\x20the\x20\
    common\x20part\x20for\x20NEM\x20transactions\n\n\x0c\n\x05\x04\x02\x03\0\
    \x01\x12\x03.\x0c\x20\n?\n\x06\x04\x02\x03\0\x02\0\x12\x03/\x08&\"0\x20B\
    IP-32\x20path\x20to\x20derive\x20the\x20key\x20from\x20master\x20node\n\
    \n\x0e\n\x07\x04\x02\x03\0\x02\0\x04\x12\x03/\x08\x10\n\x0e\n\x07\x04\
    \x02\x03\0\x02\0\x05\x12\x03/\x11\x17\n\x0e\n\x07\x04\x02\x03\0\x02\0\
    \x01\x12\x03/\x18!\n\x0e\n\x07\x04\x02\x03\0\x02\0\x03\x12\x03/$%\nJ\n\
    \x06\x04\x02\x03\0\x02\x01\x12\x030\x08$\";\x20Network\x20ID\x20(0x68\
    \x20=\x20Mainnet,\x200x98\x20=\x20Testnet,\x200x60\x20=\x20Mijin)\n\n\
    \x0e\n\x07\x04\x02\x03\0\x02\x01\x04\x12\x030\x08\x10\n\x0e\n\x07\x04\
    \x02\x03\0\x02\x01\x05\x12\x030\x11\x17\n\x0e\n\x07\x04\x02\x03\0\x02\
    \x01\x01\x12\x030\x18\x1f\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x03\x12\x030\
    \"#\nR\n\x06\x04\x02\x03\0\x02\x02\x12\x031\x08&\"C\x20Number\x20of\x20s\
    econds\x20elapsed\x20since\x20the\x20creation\x20of\x20the\x20nemesis\
    \x20block\n\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x04\x12\x031\x08\x10\n\x0e\
    \n\x07\x04\x02\x03\0\x02\x02\x05\x12\x031\x11\x17\n\x0e\n\x07\x04\x02\
    \x03\0\x02\x02\x01\x12\x031\x18!\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x03\
    \x12\x031$%\n(\n\x06\x04\x02\x03\0\x02\x03\x12\x032\x08\x20\"\x19\x20Fee\
    \x20for\x20the\x20transaction\n\n\x0e\n\x07\x04\x02\x03\0\x02\x03\x04\
    \x12\x032\x08\x10\n\x0e\n\x07\x04\x02\x03\0\x02\x03\x05\x12\x032\x11\x17\
    \n\x0e\n\x07\x04\x02\x03\0\x02\x03\x01\x12\x032\x18\x1b\n\x0e\n\x07\x04\
    \x02\x03\0\x02\x03\x03\x12\x032\x1e\x1f\n,\n\x06\x04\x02\x03\0\x02\x04\
    \x12\x033\x08%\"\x1d\x20Deadline\x20of\x20the\x20transaction\n\n\x0e\n\
    \x07\x04\x02\x03\0\x02\x04\x04\x12\x033\x08\x10\n\x0e\n\x07\x04\x02\x03\
    \0\x02\x04\x05\x12\x033\x11\x17\n\x0e\n\x07\x04\x02\x03\0\x02\x04\x01\
    \x12\x033\x18\x20\n\x0e\n\x07\x04\x02\x03\0\x02\x04\x03\x12\x033#$\nF\n\
    \x06\x04\x02\x03\0\x02\x05\x12\x034\x08\"\"7\x20Public\x20key\x20of\x20t\
    he\x20account\x20(for\x20multisig\x20transactions)\n\n\x0e\n\x07\x04\x02\
    \x03\0\x02\x05\x04\x12\x034\x08\x10\n\x0e\n\x07\x04\x02\x03\0\x02\x05\
    \x05\x12\x034\x11\x16\n\x0e\n\x07\x04\x02\x03\0\x02\x05\x01\x12\x034\x17\
    \x1d\n\x0e\n\x07\x04\x02\x03\0\x02\x05\x03\x12\x034\x20!\n[\n\x04\x04\
    \x02\x03\x01\x12\x049\x04G\x05\x1aM*\n\x20Structure\x20representing\x20t\
    he\x20transfer\x20transaction\x20part\x20for\x20NEM\x20transactions\n\n\
    \x0c\n\x05\x04\x02\x03\x01\x01\x12\x039\x0c\x17\n)\n\x06\x04\x02\x03\x01\
    \x02\0\x12\x03:\x08&\"\x1a\x20Address\x20of\x20the\x20recipient\n\n\x0e\
    \n\x07\x04\x02\x03\x01\x02\0\x04\x12\x03:\x08\x10\n\x0e\n\x07\x04\x02\
    \x03\x01\x02\0\x05\x12\x03:\x11\x17\n\x0e\n\x07\x04\x02\x03\x01\x02\0\
    \x01\x12\x03:\x18!\n\x0e\n\x07\x04\x02\x03\x01\x02\0\x03\x12\x03:$%\n8\n\
    \x06\x04\x02\x03\x01\x02\x01\x12\x03;\x08#\")\x20Amount\x20of\x20micro\
    \x20NEM\x20that\x20is\x20transferred\n\n\x0e\n\x07\x04\x02\x03\x01\x02\
    \x01\x04\x12\x03;\x08\x10\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\x05\x12\
    \x03;\x11\x17\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\x01\x12\x03;\x18\x1e\n\
    \x0e\n\x07\x04\x02\x03\x01\x02\x01\x03\x12\x03;!\"\n2\n\x06\x04\x02\x03\
    \x01\x02\x02\x12\x03<\x08#\"#\x20Actual\x20message\x20data\x20(unencrypt\
    ed)\n\n\x0e\n\x07\x04\x02\x03\x01\x02\x02\x04\x12\x03<\x08\x10\n\x0e\n\
    \x07\x04\x02\x03\x01\x02\x02\x05\x12\x03<\x11\x16\n\x0e\n\x07\x04\x02\
    \x03\x01\x02\x02\x01\x12\x03<\x17\x1e\n\x0e\n\x07\x04\x02\x03\x01\x02\
    \x02\x03\x12\x03<!\"\nE\n\x06\x04\x02\x03\x01\x02\x03\x12\x03=\x08&\"6\
    \x20Public\x20key\x20of\x20the\x20recipient\x20(for\x20encrypted\x20payl\
    oads)\n\n\x0e\n\x07\x04\x02\x03\x01\x02\x03\x04\x12\x03=\x08\x10\n\x0e\n\
    \x07\x04\x02\x03\x01\x02\x03\x05\x12\x03=\x11\x16\n\x0e\n\x07\x04\x02\
    \x03\x01\x02\x03\x01\x12\x03=\x17!\n\x0e\n\x07\x04\x02\x03\x01\x02\x03\
    \x03\x12\x03=$%\n!\n\x06\x04\x02\x03\x01\x02\x04\x12\x03>\x08'\"\x12\x20\
    Attached\x20mosaics\n\n\x0e\n\x07\x04\x02\x03\x01\x02\x04\x04\x12\x03>\
    \x08\x10\n\x0e\n\x07\x04\x02\x03\x01\x02\x04\x06\x12\x03>\x11\x1a\n\x0e\
    \n\x07\x04\x02\x03\x01\x02\x04\x01\x12\x03>\x1b\"\n\x0e\n\x07\x04\x02\
    \x03\x01\x02\x04\x03\x12\x03>%&\n^\n\x06\x04\x02\x03\x01\x03\0\x12\x04B\
    \x08F\t\x1aN*\n\x20Structure\x20representing\x20the\x20mosaic\x20attachm\
    ent\x20for\x20NEM\x20transfer\x20transactions\n\n\x0e\n\x07\x04\x02\x03\
    \x01\x03\0\x01\x12\x03B\x10\x19\n8\n\x08\x04\x02\x03\x01\x03\0\x02\0\x12\
    \x03C\x0c*\"'\x20Fully\x20qualified\x20name\x20of\x20the\x20namespace\n\
    \n\x10\n\t\x04\x02\x03\x01\x03\0\x02\0\x04\x12\x03C\x0c\x14\n\x10\n\t\
    \x04\x02\x03\x01\x03\0\x02\0\x05\x12\x03C\x15\x1b\n\x10\n\t\x04\x02\x03\
    \x01\x03\0\x02\0\x01\x12\x03C\x1c%\n\x10\n\t\x04\x02\x03\x01\x03\0\x02\0\
    \x03\x12\x03C()\n0\n\x08\x04\x02\x03\x01\x03\0\x02\x01\x12\x03D\x0c'\"\
    \x1f\x20Name\x20of\x20the\x20mosaic\x20definition\n\n\x10\n\t\x04\x02\
    \x03\x01\x03\0\x02\x01\x04\x12\x03D\x0c\x14\n\x10\n\t\x04\x02\x03\x01\
    \x03\0\x02\x01\x05\x12\x03D\x15\x1b\n\x10\n\t\x04\x02\x03\x01\x03\0\x02\
    \x01\x01\x12\x03D\x1c\"\n\x10\n\t\x04\x02\x03\x01\x03\0\x02\x01\x03\x12\
    \x03D%&\nB\n\x08\x04\x02\x03\x01\x03\0\x02\x02\x12\x03E\x0c)\"1\x20Mosai\
    c\x20quantity,\x20always\x20given\x20in\x20smallest\x20units\n\n\x10\n\t\
    \x04\x02\x03\x01\x03\0\x02\x02\x04\x12\x03E\x0c\x14\n\x10\n\t\x04\x02\
    \x03\x01\x03\0\x02\x02\x05\x12\x03E\x15\x1b\n\x10\n\t\x04\x02\x03\x01\
    \x03\0\x02\x02\x01\x12\x03E\x1c$\n\x10\n\t\x04\x02\x03\x01\x03\0\x02\x02\
    \x03\x12\x03E'(\nZ\n\x04\x04\x02\x03\x02\x12\x04K\x04P\x05\x1aL*\n\x20St\
    ructure\x20representing\x20the\x20provision\x20namespace\x20part\x20for\
    \x20NEM\x20transactions\n\n\x0c\n\x05\x04\x02\x03\x02\x01\x12\x03K\x0c!\
    \n4\n\x06\x04\x02\x03\x02\x02\0\x12\x03L\x08&\"%\x20New\x20part\x20conca\
    tenated\x20to\x20the\x20parent\n\n\x0e\n\x07\x04\x02\x03\x02\x02\0\x04\
    \x12\x03L\x08\x10\n\x0e\n\x07\x04\x02\x03\x02\x02\0\x05\x12\x03L\x11\x17\
    \n\x0e\n\x07\x04\x02\x03\x02\x02\0\x01\x12\x03L\x18!\n\x0e\n\x07\x04\x02\
    \x03\x02\x02\0\x03\x12\x03L$%\n8\n\x06\x04\x02\x03\x02\x02\x01\x12\x03M\
    \x08#\")\x20Parent\x20namespace\x20(for\x20child\x20namespaces)\n\n\x0e\
    \n\x07\x04\x02\x03\x02\x02\x01\x04\x12\x03M\x08\x10\n\x0e\n\x07\x04\x02\
    \x03\x02\x02\x01\x05\x12\x03M\x11\x17\n\x0e\n\x07\x04\x02\x03\x02\x02\
    \x01\x01\x12\x03M\x18\x1e\n\x0e\n\x07\x04\x02\x03\x02\x02\x01\x03\x12\
    \x03M!\"\n(\n\x06\x04\x02\x03\x02\x02\x02\x12\x03N\x08!\"\x19\x20Rental\
    \x20fee\x20sink\x20address\n\n\x0e\n\x07\x04\x02\x03\x02\x02\x02\x04\x12\
    \x03N\x08\x10\n\x0e\n\x07\x04\x02\x03\x02\x02\x02\x05\x12\x03N\x11\x17\n\
    \x0e\n\x07\x04\x02\x03\x02\x02\x02\x01\x12\x03N\x18\x1c\n\x0e\n\x07\x04\
    \x02\x03\x02\x02\x02\x03\x12\x03N\x1f\x20\n\x1b\n\x06\x04\x02\x03\x02\
    \x02\x03\x12\x03O\x08\x20\"\x0c\x20Rental\x20fee\n\n\x0e\n\x07\x04\x02\
    \x03\x02\x02\x03\x04\x12\x03O\x08\x10\n\x0e\n\x07\x04\x02\x03\x02\x02\
    \x03\x05\x12\x03O\x11\x17\n\x0e\n\x07\x04\x02\x03\x02\x02\x03\x01\x12\
    \x03O\x18\x1b\n\x0e\n\x07\x04\x02\x03\x02\x02\x03\x03\x12\x03O\x1e\x1f\n\
    a\n\x04\x04\x02\x03\x03\x12\x04T\x04s\x05\x1aS*\n\x20Structure\x20repres\
    enting\x20the\x20mosaic\x20definition\x20creation\x20part\x20for\x20NEM\
    \x20transactions\n\n\x0c\n\x05\x04\x02\x03\x03\x01\x12\x03T\x0c\x1d\n\"\
    \n\x06\x04\x02\x03\x03\x02\0\x12\x03U\x084\"\x13\x20Mosaic\x20definition\
    \n\n\x0e\n\x07\x04\x02\x03\x03\x02\0\x04\x12\x03U\x08\x10\n\x0e\n\x07\
    \x04\x02\x03\x03\x02\0\x06\x12\x03U\x11$\n\x0e\n\x07\x04\x02\x03\x03\x02\
    \0\x01\x12\x03U%/\n\x0e\n\x07\x04\x02\x03\x03\x02\0\x03\x12\x03U23\n*\n\
    \x06\x04\x02\x03\x03\x02\x01\x12\x03V\x08!\"\x1b\x20Creation\x20fee\x20s\
    ink\x20address\n\n\x0e\n\x07\x04\x02\x03\x03\x02\x01\x04\x12\x03V\x08\
    \x10\n\x0e\n\x07\x04\x02\x03\x03\x02\x01\x05\x12\x03V\x11\x17\n\x0e\n\
    \x07\x04\x02\x03\x03\x02\x01\x01\x12\x03V\x18\x1c\n\x0e\n\x07\x04\x02\
    \x03\x03\x02\x01\x03\x12\x03V\x1f\x20\n\x1d\n\x06\x04\x02\x03\x03\x02\
    \x02\x12\x03W\x08\x20\"\x0e\x20Creation\x20fee\n\n\x0e\n\x07\x04\x02\x03\
    \x03\x02\x02\x04\x12\x03W\x08\x10\n\x0e\n\x07\x04\x02\x03\x03\x02\x02\
    \x05\x12\x03W\x11\x17\n\x0e\n\x07\x04\x02\x03\x03\x02\x02\x01\x12\x03W\
    \x18\x1b\n\x0e\n\x07\x04\x02\x03\x03\x02\x02\x03\x12\x03W\x1e\x1f\n>\n\
    \x06\x04\x02\x03\x03\x03\0\x12\x04[\x08r\t\x1a.*\n\x20Structure\x20repre\
    senting\x20a\x20mosaic\x20definition\n\n\x0e\n\x07\x04\x02\x03\x03\x03\0\
    \x01\x12\x03[\x10#\nM\n\x08\x04\x02\x03\x03\x03\0\x02\0\x12\x03\\\x0c%\"\
    <\x20User-friendly\x20name\x20of\x20the\x20mosaic\x20(for\x20whitelisted\
    \x20mosaics)\n\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\0\x04\x12\x03\\\x0c\
    \x14\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\0\x05\x12\x03\\\x15\x1b\n\x10\n\
    \t\x04\x02\x03\x03\x03\0\x02\0\x01\x12\x03\\\x1c\x20\n\x10\n\t\x04\x02\
    \x03\x03\x03\0\x02\0\x03\x12\x03\\#$\nA\n\x08\x04\x02\x03\x03\x03\0\x02\
    \x01\x12\x03]\x0c'\"0\x20Ticker\x20of\x20the\x20mosaic\x20(for\x20whitel\
    isted\x20mosaics)\n\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x01\x04\x12\x03]\
    \x0c\x14\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x01\x05\x12\x03]\x15\x1b\n\
    \x10\n\t\x04\x02\x03\x03\x03\0\x02\x01\x01\x12\x03]\x1c\"\n\x10\n\t\x04\
    \x02\x03\x03\x03\0\x02\x01\x03\x12\x03]%&\n8\n\x08\x04\x02\x03\x03\x03\0\
    \x02\x02\x12\x03^\x0c*\"'\x20Fully\x20qualified\x20name\x20of\x20the\x20\
    namespace\n\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x02\x04\x12\x03^\x0c\x14\
    \n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x02\x05\x12\x03^\x15\x1b\n\x10\n\t\
    \x04\x02\x03\x03\x03\0\x02\x02\x01\x12\x03^\x1c%\n\x10\n\t\x04\x02\x03\
    \x03\x03\0\x02\x02\x03\x12\x03^()\n0\n\x08\x04\x02\x03\x03\x03\0\x02\x03\
    \x12\x03_\x0c'\"\x1f\x20Name\x20of\x20the\x20mosaic\x20definition\n\n\
    \x10\n\t\x04\x02\x03\x03\x03\0\x02\x03\x04\x12\x03_\x0c\x14\n\x10\n\t\
    \x04\x02\x03\x03\x03\0\x02\x03\x05\x12\x03_\x15\x1b\n\x10\n\t\x04\x02\
    \x03\x03\x03\0\x02\x03\x01\x12\x03_\x1c\"\n\x10\n\t\x04\x02\x03\x03\x03\
    \0\x02\x03\x03\x12\x03_%&\nM\n\x08\x04\x02\x03\x03\x03\0\x02\x04\x12\x03\
    `\x0c-\"<\x20Number\x20of\x20decimal\x20places\x20that\x20a\x20mosaic\
    \x20can\x20be\x20divided\x20into\n\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\
    \x04\x04\x12\x03`\x0c\x14\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x04\x05\
    \x12\x03`\x15\x1b\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x04\x01\x12\x03`\
    \x1c(\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x04\x03\x12\x03`+,\n\x1c\n\x08\
    \x04\x02\x03\x03\x03\0\x02\x05\x12\x03a\x0c,\"\x0b\x20Levy\x20type\n\n\
    \x10\n\t\x04\x02\x03\x03\x03\0\x02\x05\x04\x12\x03a\x0c\x14\n\x10\n\t\
    \x04\x02\x03\x03\x03\0\x02\x05\x06\x12\x03a\x15\"\n\x10\n\t\x04\x02\x03\
    \x03\x03\0\x02\x05\x01\x12\x03a#'\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\
    \x05\x03\x12\x03a*+\nA\n\x08\x04\x02\x03\x03\x03\0\x02\x06\x12\x03b\x0c$\
    \"0\x20Levy\x20fee\x20(interpretation\x20depends\x20on\x20levy\x20type)\
    \n\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x06\x04\x12\x03b\x0c\x14\n\x10\n\
    \t\x04\x02\x03\x03\x03\0\x02\x06\x05\x12\x03b\x15\x1b\n\x10\n\t\x04\x02\
    \x03\x03\x03\0\x02\x06\x01\x12\x03b\x1c\x1f\n\x10\n\t\x04\x02\x03\x03\
    \x03\0\x02\x06\x03\x12\x03b\"#\n\x1f\n\x08\x04\x02\x03\x03\x03\0\x02\x07\
    \x12\x03c\x0c-\"\x0e\x20Levy\x20address\n\n\x10\n\t\x04\x02\x03\x03\x03\
    \0\x02\x07\x04\x12\x03c\x0c\x14\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x07\
    \x05\x12\x03c\x15\x1b\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x07\x01\x12\
    \x03c\x1c(\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x07\x03\x12\x03c+,\nK\n\
    \x08\x04\x02\x03\x03\x03\0\x02\x08\x12\x03d\x0c/\":\x20Fully\x20qualifie\
    d\x20name\x20of\x20the\x20namespace\x20of\x20the\x20levy\x20mosaic\n\n\
    \x10\n\t\x04\x02\x03\x03\x03\0\x02\x08\x04\x12\x03d\x0c\x14\n\x10\n\t\
    \x04\x02\x03\x03\x03\0\x02\x08\x05\x12\x03d\x15\x1b\n\x10\n\t\x04\x02\
    \x03\x03\x03\0\x02\x08\x01\x12\x03d\x1c*\n\x10\n\t\x04\x02\x03\x03\x03\0\
    \x02\x08\x03\x12\x03d-.\n*\n\x08\x04\x02\x03\x03\x03\0\x02\t\x12\x03e\
    \x0c-\"\x19\x20Name\x20of\x20the\x20levy\x20mosaic\n\n\x10\n\t\x04\x02\
    \x03\x03\x03\0\x02\t\x04\x12\x03e\x0c\x14\n\x10\n\t\x04\x02\x03\x03\x03\
    \0\x02\t\x05\x12\x03e\x15\x1b\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\t\x01\
    \x12\x03e\x1c'\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\t\x03\x12\x03e*,\nI\n\
    \x08\x04\x02\x03\x03\x03\0\x02\n\x12\x03f\x0c(\"8\x20Initial\x20supply\
    \x20to\x20create,\x20always\x20given\x20in\x20entire\x20units\n\n\x10\n\
    \t\x04\x02\x03\x03\x03\0\x02\n\x04\x12\x03f\x0c\x14\n\x10\n\t\x04\x02\
    \x03\x03\x03\0\x02\n\x05\x12\x03f\x15\x1b\n\x10\n\t\x04\x02\x03\x03\x03\
    \0\x02\n\x01\x12\x03f\x1c\"\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\n\x03\
    \x12\x03f%'\n!\n\x08\x04\x02\x03\x03\x03\0\x02\x0b\x12\x03g\x0c.\"\x10\
    \x20Mutable\x20supply\n\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x0b\x04\x12\
    \x03g\x0c\x14\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x0b\x05\x12\x03g\x15\
    \x19\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x0b\x01\x12\x03g\x1a(\n\x10\n\t\
    \x04\x02\x03\x03\x03\0\x02\x0b\x03\x12\x03g+-\nP\n\x08\x04\x02\x03\x03\
    \x03\0\x02\x0c\x12\x03h\x0c,\"?\x20Mosaic\x20allows\x20transfers\x20amon\
    g\x20accounts\x20other\x20than\x20the\x20creator\n\n\x10\n\t\x04\x02\x03\
    \x03\x03\0\x02\x0c\x04\x12\x03h\x0c\x14\n\x10\n\t\x04\x02\x03\x03\x03\0\
    \x02\x0c\x05\x12\x03h\x15\x19\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x0c\
    \x01\x12\x03h\x1a&\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x0c\x03\x12\x03h)\
    +\n%\n\x08\x04\x02\x03\x03\x03\0\x02\r\x12\x03i\x0c-\"\x14\x20Mosaic\x20\
    description\n\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\r\x04\x12\x03i\x0c\x14\
    \n\x10\n\t\x04\x02\x03\x03\x03\0\x02\r\x05\x12\x03i\x15\x1b\n\x10\n\t\
    \x04\x02\x03\x03\x03\0\x02\r\x01\x12\x03i\x1c'\n\x10\n\t\x04\x02\x03\x03\
    \x03\0\x02\r\x03\x12\x03i*,\nQ\n\x08\x04\x02\x03\x03\x03\0\x02\x0e\x12\
    \x03j\x0c*\"@\x20Networks\x20that\x20the\x20mosaic\x20is\x20valid\x20on\
    \x20(for\x20whitelisted\x20mosaics)\n\n\x10\n\t\x04\x02\x03\x03\x03\0\
    \x02\x0e\x04\x12\x03j\x0c\x14\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x0e\
    \x05\x12\x03j\x15\x1b\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x0e\x01\x12\
    \x03j\x1c$\n\x10\n\t\x04\x02\x03\x03\x03\0\x02\x0e\x03\x12\x03j')\n@\n\
    \x08\x04\x02\x03\x03\x03\0\x04\0\x12\x04n\x0cq\r\x1a.*\n\x20Type\x20of\
    \x20levy\x20which\x20will\x20be\x20used\x20for\x20mosaic\n\n\x10\n\t\x04\
    \x02\x03\x03\x03\0\x04\0\x01\x12\x03n\x11\x1e\n\x11\n\n\x04\x02\x03\x03\
    \x03\0\x04\0\x02\0\x12\x03o\x10(\n\x12\n\x0b\x04\x02\x03\x03\x03\0\x04\0\
    \x02\0\x01\x12\x03o\x10#\n\x12\n\x0b\x04\x02\x03\x03\x03\0\x04\0\x02\0\
    \x02\x12\x03o&'\n\x11\n\n\x04\x02\x03\x03\x03\0\x04\0\x02\x01\x12\x03p\
    \x10*\n\x12\n\x0b\x04\x02\x03\x03\x03\0\x04\0\x02\x01\x01\x12\x03p\x10%\
    \n\x12\n\x0b\x04\x02\x03\x03\x03\0\x04\0\x02\x01\x02\x12\x03p()\n\\\n\
    \x04\x04\x02\x03\x04\x12\x05w\x04\x83\x01\x05\x1aM*\n\x20Structure\x20re\
    presenting\x20the\x20mosaic\x20supply\x20change\x20part\x20for\x20NEM\
    \x20transactions\n\n\x0c\n\x05\x04\x02\x03\x04\x01\x12\x03w\x0c!\n6\n\
    \x06\x04\x02\x03\x04\x02\0\x12\x03x\x08&\"'\x20Fully\x20qualified\x20nam\
    e\x20of\x20the\x20namespace\n\n\x0e\n\x07\x04\x02\x03\x04\x02\0\x04\x12\
    \x03x\x08\x10\n\x0e\n\x07\x04\x02\x03\x04\x02\0\x05\x12\x03x\x11\x17\n\
    \x0e\n\x07\x04\x02\x03\x04\x02\0\x01\x12\x03x\x18!\n\x0e\n\x07\x04\x02\
    \x03\x04\x02\0\x03\x12\x03x$%\n.\n\x06\x04\x02\x03\x04\x02\x01\x12\x03y\
    \x08#\"\x1f\x20Name\x20of\x20the\x20mosaic\x20definition\n\n\x0e\n\x07\
    \x04\x02\x03\x04\x02\x01\x04\x12\x03y\x08\x10\n\x0e\n\x07\x04\x02\x03\
    \x04\x02\x01\x05\x12\x03y\x11\x17\n\x0e\n\x07\x04\x02\x03\x04\x02\x01\
    \x01\x12\x03y\x18\x1e\n\x0e\n\x07\x04\x02\x03\x04\x02\x01\x03\x12\x03y!\
    \"\n&\n\x06\x04\x02\x03\x04\x02\x02\x12\x03z\x08.\"\x17\x20Type\x20of\
    \x20supply\x20change\n\n\x0e\n\x07\x04\x02\x03\x04\x02\x02\x04\x12\x03z\
    \x08\x10\n\x0e\n\x07\x04\x02\x03\x04\x02\x02\x06\x12\x03z\x11$\n\x0e\n\
    \x07\x04\x02\x03\x04\x02\x02\x01\x12\x03z%)\n\x0e\n\x07\x04\x02\x03\x04\
    \x02\x02\x03\x12\x03z,-\n\x1d\n\x06\x04\x02\x03\x04\x02\x03\x12\x03{\x08\
    \"\"\x0e\x20Supply\x20delta\n\n\x0e\n\x07\x04\x02\x03\x04\x02\x03\x04\
    \x12\x03{\x08\x10\n\x0e\n\x07\x04\x02\x03\x04\x02\x03\x05\x12\x03{\x11\
    \x17\n\x0e\n\x07\x04\x02\x03\x04\x02\x03\x01\x12\x03{\x18\x1d\n\x0e\n\
    \x07\x04\x02\x03\x04\x02\x03\x03\x12\x03{\x20!\nJ\n\x06\x04\x02\x03\x04\
    \x04\0\x12\x05\x7f\x08\x82\x01\t\x1a9*\n\x20Type\x20of\x20supply\x20chan\
    ge\x20which\x20will\x20be\x20applied\x20to\x20mosaic\n\n\x0e\n\x07\x04\
    \x02\x03\x04\x04\0\x01\x12\x03\x7f\r\x20\n\x10\n\x08\x04\x02\x03\x04\x04\
    \0\x02\0\x12\x04\x80\x01\x0c&\n\x11\n\t\x04\x02\x03\x04\x04\0\x02\0\x01\
    \x12\x04\x80\x01\x0c!\n\x11\n\t\x04\x02\x03\x04\x04\0\x02\0\x02\x12\x04\
    \x80\x01$%\n\x10\n\x08\x04\x02\x03\x04\x04\0\x02\x01\x12\x04\x81\x01\x0c\
    &\n\x11\n\t\x04\x02\x03\x04\x04\0\x02\x01\x01\x12\x04\x81\x01\x0c!\n\x11\
    \n\t\x04\x02\x03\x04\x04\0\x02\x01\x02\x12\x04\x81\x01$%\n_\n\x04\x04\
    \x02\x03\x05\x12\x06\x87\x01\x04\x98\x01\x05\x1aO*\n\x20Structure\x20rep\
    resenting\x20the\x20aggregate\x20modification\x20part\x20for\x20NEM\x20t\
    ransactions\n\n\r\n\x05\x04\x02\x03\x05\x01\x12\x04\x87\x01\x0c$\n+\n\
    \x06\x04\x02\x03\x05\x02\0\x12\x04\x88\x01\x08>\"\x1b\x20Cosignatory\x20\
    modifications\n\n\x0f\n\x07\x04\x02\x03\x05\x02\0\x04\x12\x04\x88\x01\
    \x08\x10\n\x0f\n\x07\x04\x02\x03\x05\x02\0\x06\x12\x04\x88\x01\x11+\n\
    \x0f\n\x07\x04\x02\x03\x05\x02\0\x01\x12\x04\x88\x01,9\n\x0f\n\x07\x04\
    \x02\x03\x05\x02\0\x03\x12\x04\x88\x01<=\n>\n\x06\x04\x02\x03\x05\x02\
    \x01\x12\x04\x89\x01\x08,\".\x20Relative\x20change\x20of\x20the\x20minim\
    um\x20cosignatories\n\n\x0f\n\x07\x04\x02\x03\x05\x02\x01\x04\x12\x04\
    \x89\x01\x08\x10\n\x0f\n\x07\x04\x02\x03\x05\x02\x01\x05\x12\x04\x89\x01\
    \x11\x17\n\x0f\n\x07\x04\x02\x03\x05\x02\x01\x01\x12\x04\x89\x01\x18'\n\
    \x0f\n\x07\x04\x02\x03\x05\x02\x01\x03\x12\x04\x89\x01*+\nq\n\x06\x04\
    \x02\x03\x05\x03\0\x12\x06\x8d\x01\x08\x97\x01\t\x1a_*\n\x20Structure\
    \x20representing\x20the\x20cosignatory\x20modification\x20for\x20aggrega\
    te\x20modification\x20transactions\n\n\x0f\n\x07\x04\x02\x03\x05\x03\0\
    \x01\x12\x04\x8d\x01\x10*\n4\n\x08\x04\x02\x03\x05\x03\0\x02\0\x12\x04\
    \x8e\x01\x0c2\"\"\x20Type\x20of\x20cosignatory\x20modification\n\n\x11\n\
    \t\x04\x02\x03\x05\x03\0\x02\0\x04\x12\x04\x8e\x01\x0c\x14\n\x11\n\t\x04\
    \x02\x03\x05\x03\0\x02\0\x06\x12\x04\x8e\x01\x15(\n\x11\n\t\x04\x02\x03\
    \x05\x03\0\x02\0\x01\x12\x04\x8e\x01)-\n\x11\n\t\x04\x02\x03\x05\x03\0\
    \x02\0\x03\x12\x04\x8e\x0101\n1\n\x08\x04\x02\x03\x05\x03\0\x02\x01\x12\
    \x04\x8f\x01\x0c*\"\x1f\x20Public\x20key\x20of\x20the\x20cosignatory\n\n\
    \x11\n\t\x04\x02\x03\x05\x03\0\x02\x01\x04\x12\x04\x8f\x01\x0c\x14\n\x11\
    \n\t\x04\x02\x03\x05\x03\0\x02\x01\x05\x12\x04\x8f\x01\x15\x1a\n\x11\n\t\
    \x04\x02\x03\x05\x03\0\x02\x01\x01\x12\x04\x8f\x01\x1b%\n\x11\n\t\x04\
    \x02\x03\x05\x03\0\x02\x01\x03\x12\x04\x8f\x01()\n8\n\x08\x04\x02\x03\
    \x05\x03\0\x04\0\x12\x06\x93\x01\x0c\x96\x01\r\x1a$*\n\x20Type\x20of\x20\
    cosignatory\x20modification\n\n\x11\n\t\x04\x02\x03\x05\x03\0\x04\0\x01\
    \x12\x04\x93\x01\x11$\n\x12\n\n\x04\x02\x03\x05\x03\0\x04\0\x02\0\x12\
    \x04\x94\x01\x100\n\x13\n\x0b\x04\x02\x03\x05\x03\0\x04\0\x02\0\x01\x12\
    \x04\x94\x01\x10+\n\x13\n\x0b\x04\x02\x03\x05\x03\0\x04\0\x02\0\x02\x12\
    \x04\x94\x01./\n\x12\n\n\x04\x02\x03\x05\x03\0\x04\0\x02\x01\x12\x04\x95\
    \x01\x103\n\x13\n\x0b\x04\x02\x03\x05\x03\0\x04\0\x02\x01\x01\x12\x04\
    \x95\x01\x10.\n\x13\n\x0b\x04\x02\x03\x05\x03\0\x04\0\x02\x01\x02\x12\
    \x04\x95\x0112\n\\\n\x04\x04\x02\x03\x06\x12\x06\x9c\x01\x04\xa6\x01\x05\
    \x1aL*\n\x20Structure\x20representing\x20the\x20importance\x20transfer\
    \x20part\x20for\x20NEM\x20transactions\n\n\r\n\x05\x04\x02\x03\x06\x01\
    \x12\x04\x9c\x01\x0c!\n-\n\x06\x04\x02\x03\x06\x02\0\x12\x04\x9d\x01\x08\
    4\"\x1d\x20Mode\x20of\x20importance\x20transfer\n\n\x0f\n\x07\x04\x02\
    \x03\x06\x02\0\x04\x12\x04\x9d\x01\x08\x10\n\x0f\n\x07\x04\x02\x03\x06\
    \x02\0\x06\x12\x04\x9d\x01\x11*\n\x0f\n\x07\x04\x02\x03\x06\x02\0\x01\
    \x12\x04\x9d\x01+/\n\x0f\n\x07\x04\x02\x03\x06\x02\0\x03\x12\x04\x9d\x01\
    23\n2\n\x06\x04\x02\x03\x06\x02\x01\x12\x04\x9e\x01\x08&\"\"\x20Public\
    \x20key\x20of\x20the\x20remote\x20account\n\n\x0f\n\x07\x04\x02\x03\x06\
    \x02\x01\x04\x12\x04\x9e\x01\x08\x10\n\x0f\n\x07\x04\x02\x03\x06\x02\x01\
    \x05\x12\x04\x9e\x01\x11\x16\n\x0f\n\x07\x04\x02\x03\x06\x02\x01\x01\x12\
    \x04\x9e\x01\x17!\n\x0f\n\x07\x04\x02\x03\x06\x02\x01\x03\x12\x04\x9e\
    \x01$%\n1\n\x06\x04\x02\x03\x06\x04\0\x12\x06\xa2\x01\x08\xa5\x01\t\x1a\
    \x1f*\n\x20Mode\x20of\x20importance\x20transfer\n\n\x0f\n\x07\x04\x02\
    \x03\x06\x04\0\x01\x12\x04\xa2\x01\r&\n\x10\n\x08\x04\x02\x03\x06\x04\0\
    \x02\0\x12\x04\xa3\x01\x0c,\n\x11\n\t\x04\x02\x03\x06\x04\0\x02\0\x01\
    \x12\x04\xa3\x01\x0c'\n\x11\n\t\x04\x02\x03\x06\x04\0\x02\0\x02\x12\x04\
    \xa3\x01*+\n\x10\n\x08\x04\x02\x03\x06\x04\0\x02\x01\x12\x04\xa4\x01\x0c\
    .\n\x11\n\t\x04\x02\x03\x06\x04\0\x02\x01\x01\x12\x04\xa4\x01\x0c)\n\x11\
    \n\t\x04\x02\x03\x06\x04\0\x02\x01\x02\x12\x04\xa4\x01,-\nM\n\x02\x04\
    \x03\x12\x06\xad\x01\0\xb0\x01\x01\x1a?*\n\x20Response:\x20Contains\x20N\
    EM\x20transaction\x20data\x20and\x20signature\n\x20@end\n\n\x0b\n\x03\
    \x04\x03\x01\x12\x04\xad\x01\x08\x13\n\x20\n\x04\x04\x03\x02\0\x12\x04\
    \xae\x01\x04\x1c\"\x12\x20Transaction\x20data\n\n\r\n\x05\x04\x03\x02\0\
    \x04\x12\x04\xae\x01\x04\x0c\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\xae\x01\
    \r\x12\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xae\x01\x13\x17\n\r\n\x05\x04\
    \x03\x02\0\x03\x12\x04\xae\x01\x1a\x1b\n-\n\x04\x04\x03\x02\x01\x12\x04\
    \xaf\x01\x04!\"\x1f\x20Signature\x20for\x20the\x20transaction\n\n\r\n\
    \x05\x04\x03\x02\x01\x04\x12\x04\xaf\x01\x04\x0c\n\r\n\x05\x04\x03\x02\
    \x01\x05\x12\x04\xaf\x01\r\x12\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\xaf\
    \x01\x13\x1c\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xaf\x01\x1f\x20\nz\n\
    \x02\x04\x04\x12\x06\xb8\x01\0\xbd\x01\x01\x1al*\n\x20Request:\x20Ask\
    \x20device\x20to\x20decrypt\x20NEM\x20transaction\x20payload\n\x20@start\
    \n\x20@next\x20NEMDecryptedMessage\n\x20@next\x20Failure\n\n\x0b\n\x03\
    \x04\x04\x01\x12\x04\xb8\x01\x08\x19\n>\n\x04\x04\x04\x02\0\x12\x04\xb9\
    \x01\x04\"\"0\x20BIP-32\x20path\x20to\x20derive\x20the\x20key\x20from\
    \x20master\x20node\n\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\xb9\x01\x04\x0c\
    \n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xb9\x01\r\x13\n\r\n\x05\x04\x04\x02\
    \0\x01\x12\x04\xb9\x01\x14\x1d\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xb9\
    \x01\x20!\nI\n\x04\x04\x04\x02\x01\x12\x04\xba\x01\x04\x20\";\x20Network\
    \x20ID\x20(0x68\x20=\x20Mainnet,\x200x98\x20=\x20Testnet,\x200x60\x20=\
    \x20Mijin)\n\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\xba\x01\x04\x0c\n\r\n\
    \x05\x04\x04\x02\x01\x05\x12\x04\xba\x01\r\x13\n\r\n\x05\x04\x04\x02\x01\
    \x01\x12\x04\xba\x01\x14\x1b\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xba\
    \x01\x1e\x1f\n-\n\x04\x04\x04\x02\x02\x12\x04\xbb\x01\x04\"\"\x1f\x20Pub\
    lic\x20key\x20of\x20the\x20other\x20party\n\n\r\n\x05\x04\x04\x02\x02\
    \x04\x12\x04\xbb\x01\x04\x0c\n\r\n\x05\x04\x04\x02\x02\x05\x12\x04\xbb\
    \x01\r\x12\n\r\n\x05\x04\x04\x02\x02\x01\x12\x04\xbb\x01\x13\x1d\n\r\n\
    \x05\x04\x04\x02\x02\x03\x12\x04\xbb\x01\x20!\n/\n\x04\x04\x04\x02\x03\
    \x12\x04\xbc\x01\x04\x1f\"!\x20Actual\x20message\x20data\x20(encrypted)\
    \n\n\r\n\x05\x04\x04\x02\x03\x04\x12\x04\xbc\x01\x04\x0c\n\r\n\x05\x04\
    \x04\x02\x03\x05\x12\x04\xbc\x01\r\x12\n\r\n\x05\x04\x04\x02\x03\x01\x12\
    \x04\xbc\x01\x13\x1a\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\xbc\x01\x1d\
    \x1e\nL\n\x02\x04\x05\x12\x06\xc3\x01\0\xc5\x01\x01\x1a>*\n\x20Response:\
    \x20Contains\x20decrypted\x20NEM\x20transaction\x20payload\n\x20@end\n\n\
    \x0b\n\x03\x04\x05\x01\x12\x04\xc3\x01\x08\x1b\n1\n\x04\x04\x05\x02\0\
    \x12\x04\xc4\x01\x04\x1f\"#\x20Actual\x20message\x20data\x20(unencrypted\
    )\n\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\xc4\x01\x04\x0c\n\r\n\x05\x04\
    \x05\x02\0\x05\x12\x04\xc4\x01\r\x12\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\
    \xc4\x01\x13\x1a\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xc4\x01\x1d\x1e\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
