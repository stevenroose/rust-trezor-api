// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `messages-monero.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSourceEntry {
    // message fields
    outputs: ::protobuf::RepeatedField<MoneroTransactionSourceEntry_MoneroOutputEntry>,
    real_output: ::std::option::Option<u64>,
    real_out_tx_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    real_out_additional_tx_keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    real_output_in_tx_index: ::std::option::Option<u64>,
    amount: ::std::option::Option<u64>,
    rct: ::std::option::Option<bool>,
    mask: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    multisig_kLRki: ::protobuf::SingularPtrField<MoneroTransactionSourceEntry_MoneroMultisigKLRki>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSourceEntry {
    fn default() -> &'a MoneroTransactionSourceEntry {
        <MoneroTransactionSourceEntry as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSourceEntry {
    pub fn new() -> MoneroTransactionSourceEntry {
        ::std::default::Default::default()
    }

    // repeated .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry outputs = 1;


    pub fn get_outputs(&self) -> &[MoneroTransactionSourceEntry_MoneroOutputEntry] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<MoneroTransactionSourceEntry_MoneroOutputEntry>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<MoneroTransactionSourceEntry_MoneroOutputEntry> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<MoneroTransactionSourceEntry_MoneroOutputEntry> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }

    // optional uint64 real_output = 2;


    pub fn get_real_output(&self) -> u64 {
        self.real_output.unwrap_or(0)
    }
    pub fn clear_real_output(&mut self) {
        self.real_output = ::std::option::Option::None;
    }

    pub fn has_real_output(&self) -> bool {
        self.real_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_output(&mut self, v: u64) {
        self.real_output = ::std::option::Option::Some(v);
    }

    // optional bytes real_out_tx_key = 3;


    pub fn get_real_out_tx_key(&self) -> &[u8] {
        match self.real_out_tx_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_real_out_tx_key(&mut self) {
        self.real_out_tx_key.clear();
    }

    pub fn has_real_out_tx_key(&self) -> bool {
        self.real_out_tx_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_out_tx_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.real_out_tx_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_real_out_tx_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.real_out_tx_key.is_none() {
            self.real_out_tx_key.set_default();
        }
        self.real_out_tx_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_real_out_tx_key(&mut self) -> ::std::vec::Vec<u8> {
        self.real_out_tx_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated bytes real_out_additional_tx_keys = 4;


    pub fn get_real_out_additional_tx_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.real_out_additional_tx_keys
    }
    pub fn clear_real_out_additional_tx_keys(&mut self) {
        self.real_out_additional_tx_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_real_out_additional_tx_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.real_out_additional_tx_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_real_out_additional_tx_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.real_out_additional_tx_keys
    }

    // Take field
    pub fn take_real_out_additional_tx_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.real_out_additional_tx_keys, ::protobuf::RepeatedField::new())
    }

    // optional uint64 real_output_in_tx_index = 5;


    pub fn get_real_output_in_tx_index(&self) -> u64 {
        self.real_output_in_tx_index.unwrap_or(0)
    }
    pub fn clear_real_output_in_tx_index(&mut self) {
        self.real_output_in_tx_index = ::std::option::Option::None;
    }

    pub fn has_real_output_in_tx_index(&self) -> bool {
        self.real_output_in_tx_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_output_in_tx_index(&mut self, v: u64) {
        self.real_output_in_tx_index = ::std::option::Option::Some(v);
    }

    // optional uint64 amount = 6;


    pub fn get_amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional bool rct = 7;


    pub fn get_rct(&self) -> bool {
        self.rct.unwrap_or(false)
    }
    pub fn clear_rct(&mut self) {
        self.rct = ::std::option::Option::None;
    }

    pub fn has_rct(&self) -> bool {
        self.rct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rct(&mut self, v: bool) {
        self.rct = ::std::option::Option::Some(v);
    }

    // optional bytes mask = 8;


    pub fn get_mask(&self) -> &[u8] {
        match self.mask.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: ::std::vec::Vec<u8>) {
        self.mask = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mask.is_none() {
            self.mask.set_default();
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> ::std::vec::Vec<u8> {
        self.mask.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRki multisig_kLRki = 9;


    pub fn get_multisig_kLRki(&self) -> &MoneroTransactionSourceEntry_MoneroMultisigKLRki {
        self.multisig_kLRki.as_ref().unwrap_or_else(|| MoneroTransactionSourceEntry_MoneroMultisigKLRki::default_instance())
    }
    pub fn clear_multisig_kLRki(&mut self) {
        self.multisig_kLRki.clear();
    }

    pub fn has_multisig_kLRki(&self) -> bool {
        self.multisig_kLRki.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multisig_kLRki(&mut self, v: MoneroTransactionSourceEntry_MoneroMultisigKLRki) {
        self.multisig_kLRki = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multisig_kLRki(&mut self) -> &mut MoneroTransactionSourceEntry_MoneroMultisigKLRki {
        if self.multisig_kLRki.is_none() {
            self.multisig_kLRki.set_default();
        }
        self.multisig_kLRki.as_mut().unwrap()
    }

    // Take field
    pub fn take_multisig_kLRki(&mut self) -> MoneroTransactionSourceEntry_MoneroMultisigKLRki {
        self.multisig_kLRki.take().unwrap_or_else(|| MoneroTransactionSourceEntry_MoneroMultisigKLRki::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSourceEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.multisig_kLRki {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.real_output = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.real_out_tx_key)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.real_out_additional_tx_keys)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.real_output_in_tx_index = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.rct = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.mask)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.multisig_kLRki)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.real_output {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.real_out_tx_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        for value in &self.real_out_additional_tx_keys {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        if let Some(v) = self.real_output_in_tx_index {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rct {
            my_size += 2;
        }
        if let Some(ref v) = self.mask.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(ref v) = self.multisig_kLRki.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.outputs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.real_output {
            os.write_uint64(2, v)?;
        }
        if let Some(ref v) = self.real_out_tx_key.as_ref() {
            os.write_bytes(3, &v)?;
        }
        for v in &self.real_out_additional_tx_keys {
            os.write_bytes(4, &v)?;
        };
        if let Some(v) = self.real_output_in_tx_index {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.rct {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.mask.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(ref v) = self.multisig_kLRki.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSourceEntry {
        MoneroTransactionSourceEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionSourceEntry_MoneroOutputEntry>>(
                    "outputs",
                    |m: &MoneroTransactionSourceEntry| { &m.outputs },
                    |m: &mut MoneroTransactionSourceEntry| { &mut m.outputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "real_output",
                    |m: &MoneroTransactionSourceEntry| { &m.real_output },
                    |m: &mut MoneroTransactionSourceEntry| { &mut m.real_output },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "real_out_tx_key",
                    |m: &MoneroTransactionSourceEntry| { &m.real_out_tx_key },
                    |m: &mut MoneroTransactionSourceEntry| { &mut m.real_out_tx_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "real_out_additional_tx_keys",
                    |m: &MoneroTransactionSourceEntry| { &m.real_out_additional_tx_keys },
                    |m: &mut MoneroTransactionSourceEntry| { &mut m.real_out_additional_tx_keys },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "real_output_in_tx_index",
                    |m: &MoneroTransactionSourceEntry| { &m.real_output_in_tx_index },
                    |m: &mut MoneroTransactionSourceEntry| { &mut m.real_output_in_tx_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "amount",
                    |m: &MoneroTransactionSourceEntry| { &m.amount },
                    |m: &mut MoneroTransactionSourceEntry| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "rct",
                    |m: &MoneroTransactionSourceEntry| { &m.rct },
                    |m: &mut MoneroTransactionSourceEntry| { &mut m.rct },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "mask",
                    |m: &MoneroTransactionSourceEntry| { &m.mask },
                    |m: &mut MoneroTransactionSourceEntry| { &mut m.mask },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionSourceEntry_MoneroMultisigKLRki>>(
                    "multisig_kLRki",
                    |m: &MoneroTransactionSourceEntry| { &m.multisig_kLRki },
                    |m: &mut MoneroTransactionSourceEntry| { &mut m.multisig_kLRki },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionSourceEntry>(
                    "MoneroTransactionSourceEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionSourceEntry {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionSourceEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionSourceEntry,
        };
        unsafe {
            instance.get(MoneroTransactionSourceEntry::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionSourceEntry {
    fn clear(&mut self) {
        self.outputs.clear();
        self.real_output = ::std::option::Option::None;
        self.real_out_tx_key.clear();
        self.real_out_additional_tx_keys.clear();
        self.real_output_in_tx_index = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.rct = ::std::option::Option::None;
        self.mask.clear();
        self.multisig_kLRki.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSourceEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSourceEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSourceEntry_MoneroOutputEntry {
    // message fields
    idx: ::std::option::Option<u64>,
    key: ::protobuf::SingularPtrField<MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSourceEntry_MoneroOutputEntry {
    fn default() -> &'a MoneroTransactionSourceEntry_MoneroOutputEntry {
        <MoneroTransactionSourceEntry_MoneroOutputEntry as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSourceEntry_MoneroOutputEntry {
    pub fn new() -> MoneroTransactionSourceEntry_MoneroOutputEntry {
        ::std::default::Default::default()
    }

    // optional uint64 idx = 1;


    pub fn get_idx(&self) -> u64 {
        self.idx.unwrap_or(0)
    }
    pub fn clear_idx(&mut self) {
        self.idx = ::std::option::Option::None;
    }

    pub fn has_idx(&self) -> bool {
        self.idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idx(&mut self, v: u64) {
        self.idx = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKey key = 2;


    pub fn get_key(&self) -> &MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey {
        self.key.as_ref().unwrap_or_else(|| MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey {
        self.key.take().unwrap_or_else(|| MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSourceEntry_MoneroOutputEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.idx = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.idx {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.idx {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSourceEntry_MoneroOutputEntry {
        MoneroTransactionSourceEntry_MoneroOutputEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "idx",
                    |m: &MoneroTransactionSourceEntry_MoneroOutputEntry| { &m.idx },
                    |m: &mut MoneroTransactionSourceEntry_MoneroOutputEntry| { &mut m.idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey>>(
                    "key",
                    |m: &MoneroTransactionSourceEntry_MoneroOutputEntry| { &m.key },
                    |m: &mut MoneroTransactionSourceEntry_MoneroOutputEntry| { &mut m.key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionSourceEntry_MoneroOutputEntry>(
                    "MoneroTransactionSourceEntry_MoneroOutputEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionSourceEntry_MoneroOutputEntry {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionSourceEntry_MoneroOutputEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionSourceEntry_MoneroOutputEntry,
        };
        unsafe {
            instance.get(MoneroTransactionSourceEntry_MoneroOutputEntry::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionSourceEntry_MoneroOutputEntry {
    fn clear(&mut self) {
        self.idx = ::std::option::Option::None;
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSourceEntry_MoneroOutputEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSourceEntry_MoneroOutputEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey {
    // message fields
    dest: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    mask: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey {
    fn default() -> &'a MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey {
        <MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey {
    pub fn new() -> MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey {
        ::std::default::Default::default()
    }

    // optional bytes dest = 1;


    pub fn get_dest(&self) -> &[u8] {
        match self.dest.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_dest(&mut self) {
        self.dest.clear();
    }

    pub fn has_dest(&self) -> bool {
        self.dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dest(&mut self, v: ::std::vec::Vec<u8>) {
        self.dest = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.dest.is_none() {
            self.dest.set_default();
        }
        self.dest.as_mut().unwrap()
    }

    // Take field
    pub fn take_dest(&mut self) -> ::std::vec::Vec<u8> {
        self.dest.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes mask = 2;


    pub fn get_mask(&self) -> &[u8] {
        match self.mask.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: ::std::vec::Vec<u8>) {
        self.mask = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mask.is_none() {
            self.mask.set_default();
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> ::std::vec::Vec<u8> {
        self.mask.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.dest)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dest.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.mask.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dest.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.mask.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey {
        MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dest",
                    |m: &MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey| { &m.dest },
                    |m: &mut MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey| { &mut m.dest },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "mask",
                    |m: &MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey| { &m.mask },
                    |m: &mut MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey| { &mut m.mask },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey>(
                    "MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey,
        };
        unsafe {
            instance.get(MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey {
    fn clear(&mut self) {
        self.dest.clear();
        self.mask.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSourceEntry_MoneroOutputEntry_MoneroRctKey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSourceEntry_MoneroMultisigKLRki {
    // message fields
    K: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    L: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    R: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ki: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSourceEntry_MoneroMultisigKLRki {
    fn default() -> &'a MoneroTransactionSourceEntry_MoneroMultisigKLRki {
        <MoneroTransactionSourceEntry_MoneroMultisigKLRki as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSourceEntry_MoneroMultisigKLRki {
    pub fn new() -> MoneroTransactionSourceEntry_MoneroMultisigKLRki {
        ::std::default::Default::default()
    }

    // optional bytes K = 1;


    pub fn get_K(&self) -> &[u8] {
        match self.K.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_K(&mut self) {
        self.K.clear();
    }

    pub fn has_K(&self) -> bool {
        self.K.is_some()
    }

    // Param is passed by value, moved
    pub fn set_K(&mut self, v: ::std::vec::Vec<u8>) {
        self.K = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_K(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.K.is_none() {
            self.K.set_default();
        }
        self.K.as_mut().unwrap()
    }

    // Take field
    pub fn take_K(&mut self) -> ::std::vec::Vec<u8> {
        self.K.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes L = 2;


    pub fn get_L(&self) -> &[u8] {
        match self.L.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_L(&mut self) {
        self.L.clear();
    }

    pub fn has_L(&self) -> bool {
        self.L.is_some()
    }

    // Param is passed by value, moved
    pub fn set_L(&mut self, v: ::std::vec::Vec<u8>) {
        self.L = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_L(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.L.is_none() {
            self.L.set_default();
        }
        self.L.as_mut().unwrap()
    }

    // Take field
    pub fn take_L(&mut self) -> ::std::vec::Vec<u8> {
        self.L.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes R = 3;


    pub fn get_R(&self) -> &[u8] {
        match self.R.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_R(&mut self) {
        self.R.clear();
    }

    pub fn has_R(&self) -> bool {
        self.R.is_some()
    }

    // Param is passed by value, moved
    pub fn set_R(&mut self, v: ::std::vec::Vec<u8>) {
        self.R = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_R(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.R.is_none() {
            self.R.set_default();
        }
        self.R.as_mut().unwrap()
    }

    // Take field
    pub fn take_R(&mut self) -> ::std::vec::Vec<u8> {
        self.R.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes ki = 4;


    pub fn get_ki(&self) -> &[u8] {
        match self.ki.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ki(&mut self) {
        self.ki.clear();
    }

    pub fn has_ki(&self) -> bool {
        self.ki.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ki(&mut self, v: ::std::vec::Vec<u8>) {
        self.ki = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ki(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ki.is_none() {
            self.ki.set_default();
        }
        self.ki.as_mut().unwrap()
    }

    // Take field
    pub fn take_ki(&mut self) -> ::std::vec::Vec<u8> {
        self.ki.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSourceEntry_MoneroMultisigKLRki {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.K)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.L)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.R)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ki)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.K.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.L.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.R.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.ki.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.K.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.L.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.R.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.ki.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSourceEntry_MoneroMultisigKLRki {
        MoneroTransactionSourceEntry_MoneroMultisigKLRki::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "K",
                    |m: &MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &m.K },
                    |m: &mut MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &mut m.K },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "L",
                    |m: &MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &m.L },
                    |m: &mut MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &mut m.L },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "R",
                    |m: &MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &m.R },
                    |m: &mut MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &mut m.R },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ki",
                    |m: &MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &m.ki },
                    |m: &mut MoneroTransactionSourceEntry_MoneroMultisigKLRki| { &mut m.ki },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionSourceEntry_MoneroMultisigKLRki>(
                    "MoneroTransactionSourceEntry_MoneroMultisigKLRki",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionSourceEntry_MoneroMultisigKLRki {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionSourceEntry_MoneroMultisigKLRki> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionSourceEntry_MoneroMultisigKLRki,
        };
        unsafe {
            instance.get(MoneroTransactionSourceEntry_MoneroMultisigKLRki::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionSourceEntry_MoneroMultisigKLRki {
    fn clear(&mut self) {
        self.K.clear();
        self.L.clear();
        self.R.clear();
        self.ki.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSourceEntry_MoneroMultisigKLRki {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSourceEntry_MoneroMultisigKLRki {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionDestinationEntry {
    // message fields
    amount: ::std::option::Option<u64>,
    addr: ::protobuf::SingularPtrField<MoneroTransactionDestinationEntry_MoneroAccountPublicAddress>,
    is_subaddress: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionDestinationEntry {
    fn default() -> &'a MoneroTransactionDestinationEntry {
        <MoneroTransactionDestinationEntry as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionDestinationEntry {
    pub fn new() -> MoneroTransactionDestinationEntry {
        ::std::default::Default::default()
    }

    // optional uint64 amount = 1;


    pub fn get_amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry.MoneroAccountPublicAddress addr = 2;


    pub fn get_addr(&self) -> &MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
        self.addr.as_ref().unwrap_or_else(|| MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::default_instance())
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    pub fn has_addr(&self) -> bool {
        self.addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: MoneroTransactionDestinationEntry_MoneroAccountPublicAddress) {
        self.addr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
        if self.addr.is_none() {
            self.addr.set_default();
        }
        self.addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_addr(&mut self) -> MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
        self.addr.take().unwrap_or_else(|| MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::new())
    }

    // optional bool is_subaddress = 3;


    pub fn get_is_subaddress(&self) -> bool {
        self.is_subaddress.unwrap_or(false)
    }
    pub fn clear_is_subaddress(&mut self) {
        self.is_subaddress = ::std::option::Option::None;
    }

    pub fn has_is_subaddress(&self) -> bool {
        self.is_subaddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_subaddress(&mut self, v: bool) {
        self.is_subaddress = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroTransactionDestinationEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.addr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addr)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_subaddress = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.addr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.is_subaddress {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.amount {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.addr.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.is_subaddress {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionDestinationEntry {
        MoneroTransactionDestinationEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "amount",
                    |m: &MoneroTransactionDestinationEntry| { &m.amount },
                    |m: &mut MoneroTransactionDestinationEntry| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionDestinationEntry_MoneroAccountPublicAddress>>(
                    "addr",
                    |m: &MoneroTransactionDestinationEntry| { &m.addr },
                    |m: &mut MoneroTransactionDestinationEntry| { &mut m.addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_subaddress",
                    |m: &MoneroTransactionDestinationEntry| { &m.is_subaddress },
                    |m: &mut MoneroTransactionDestinationEntry| { &mut m.is_subaddress },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionDestinationEntry>(
                    "MoneroTransactionDestinationEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionDestinationEntry {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionDestinationEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionDestinationEntry,
        };
        unsafe {
            instance.get(MoneroTransactionDestinationEntry::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionDestinationEntry {
    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.addr.clear();
        self.is_subaddress = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionDestinationEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionDestinationEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
    // message fields
    spend_public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    view_public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
    fn default() -> &'a MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
        <MoneroTransactionDestinationEntry_MoneroAccountPublicAddress as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
    pub fn new() -> MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
        ::std::default::Default::default()
    }

    // optional bytes spend_public_key = 1;


    pub fn get_spend_public_key(&self) -> &[u8] {
        match self.spend_public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_spend_public_key(&mut self) {
        self.spend_public_key.clear();
    }

    pub fn has_spend_public_key(&self) -> bool {
        self.spend_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spend_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.spend_public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spend_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.spend_public_key.is_none() {
            self.spend_public_key.set_default();
        }
        self.spend_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_spend_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.spend_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes view_public_key = 2;


    pub fn get_view_public_key(&self) -> &[u8] {
        match self.view_public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_view_public_key(&mut self) {
        self.view_public_key.clear();
    }

    pub fn has_view_public_key(&self) -> bool {
        self.view_public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.view_public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.view_public_key.is_none() {
            self.view_public_key.set_default();
        }
        self.view_public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_view_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.view_public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.spend_public_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.view_public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.spend_public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.view_public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.spend_public_key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.view_public_key.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
        MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "spend_public_key",
                    |m: &MoneroTransactionDestinationEntry_MoneroAccountPublicAddress| { &m.spend_public_key },
                    |m: &mut MoneroTransactionDestinationEntry_MoneroAccountPublicAddress| { &mut m.spend_public_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "view_public_key",
                    |m: &MoneroTransactionDestinationEntry_MoneroAccountPublicAddress| { &m.view_public_key },
                    |m: &mut MoneroTransactionDestinationEntry_MoneroAccountPublicAddress| { &mut m.view_public_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionDestinationEntry_MoneroAccountPublicAddress>(
                    "MoneroTransactionDestinationEntry_MoneroAccountPublicAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionDestinationEntry_MoneroAccountPublicAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionDestinationEntry_MoneroAccountPublicAddress,
        };
        unsafe {
            instance.get(MoneroTransactionDestinationEntry_MoneroAccountPublicAddress::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
    fn clear(&mut self) {
        self.spend_public_key.clear();
        self.view_public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionDestinationEntry_MoneroAccountPublicAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionRsigData {
    // message fields
    version: ::std::option::Option<u32>,
    rsig_type: ::std::option::Option<u32>,
    offload_type: ::std::option::Option<u32>,
    grouping: ::std::vec::Vec<u64>,
    step: ::std::option::Option<u32>,
    operation: ::std::option::Option<u64>,
    seed: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    mask: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    amount: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rsig: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rsig_parts: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    outputs: ::protobuf::RepeatedField<MoneroTransactionDestinationEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionRsigData {
    fn default() -> &'a MoneroTransactionRsigData {
        <MoneroTransactionRsigData as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionRsigData {
    pub fn new() -> MoneroTransactionRsigData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 rsig_type = 2;


    pub fn get_rsig_type(&self) -> u32 {
        self.rsig_type.unwrap_or(0)
    }
    pub fn clear_rsig_type(&mut self) {
        self.rsig_type = ::std::option::Option::None;
    }

    pub fn has_rsig_type(&self) -> bool {
        self.rsig_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_type(&mut self, v: u32) {
        self.rsig_type = ::std::option::Option::Some(v);
    }

    // optional uint32 offload_type = 3;


    pub fn get_offload_type(&self) -> u32 {
        self.offload_type.unwrap_or(0)
    }
    pub fn clear_offload_type(&mut self) {
        self.offload_type = ::std::option::Option::None;
    }

    pub fn has_offload_type(&self) -> bool {
        self.offload_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offload_type(&mut self, v: u32) {
        self.offload_type = ::std::option::Option::Some(v);
    }

    // repeated uint64 grouping = 4;


    pub fn get_grouping(&self) -> &[u64] {
        &self.grouping
    }
    pub fn clear_grouping(&mut self) {
        self.grouping.clear();
    }

    // Param is passed by value, moved
    pub fn set_grouping(&mut self, v: ::std::vec::Vec<u64>) {
        self.grouping = v;
    }

    // Mutable pointer to the field.
    pub fn mut_grouping(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.grouping
    }

    // Take field
    pub fn take_grouping(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.grouping, ::std::vec::Vec::new())
    }

    // optional uint32 step = 5;


    pub fn get_step(&self) -> u32 {
        self.step.unwrap_or(0)
    }
    pub fn clear_step(&mut self) {
        self.step = ::std::option::Option::None;
    }

    pub fn has_step(&self) -> bool {
        self.step.is_some()
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: u32) {
        self.step = ::std::option::Option::Some(v);
    }

    // optional uint64 operation = 6;


    pub fn get_operation(&self) -> u64 {
        self.operation.unwrap_or(0)
    }
    pub fn clear_operation(&mut self) {
        self.operation = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: u64) {
        self.operation = ::std::option::Option::Some(v);
    }

    // optional bytes seed = 7;


    pub fn get_seed(&self) -> &[u8] {
        match self.seed.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_seed(&mut self) {
        self.seed.clear();
    }

    pub fn has_seed(&self) -> bool {
        self.seed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seed(&mut self, v: ::std::vec::Vec<u8>) {
        self.seed = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seed(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.seed.is_none() {
            self.seed.set_default();
        }
        self.seed.as_mut().unwrap()
    }

    // Take field
    pub fn take_seed(&mut self) -> ::std::vec::Vec<u8> {
        self.seed.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes mask = 8;


    pub fn get_mask(&self) -> &[u8] {
        match self.mask.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: ::std::vec::Vec<u8>) {
        self.mask = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mask.is_none() {
            self.mask.set_default();
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> ::std::vec::Vec<u8> {
        self.mask.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes amount = 9;


    pub fn get_amount(&self) -> &[u8] {
        match self.amount.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::vec::Vec<u8>) {
        self.amount = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.amount.is_none() {
            self.amount.set_default();
        }
        self.amount.as_mut().unwrap()
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::vec::Vec<u8> {
        self.amount.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes rsig = 10;


    pub fn get_rsig(&self) -> &[u8] {
        match self.rsig.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_rsig(&mut self) {
        self.rsig.clear();
    }

    pub fn has_rsig(&self) -> bool {
        self.rsig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig(&mut self, v: ::std::vec::Vec<u8>) {
        self.rsig = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rsig.is_none() {
            self.rsig.set_default();
        }
        self.rsig.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig(&mut self) -> ::std::vec::Vec<u8> {
        self.rsig.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated bytes rsig_parts = 11;


    pub fn get_rsig_parts(&self) -> &[::std::vec::Vec<u8>] {
        &self.rsig_parts
    }
    pub fn clear_rsig_parts(&mut self) {
        self.rsig_parts.clear();
    }

    // Param is passed by value, moved
    pub fn set_rsig_parts(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.rsig_parts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rsig_parts(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.rsig_parts
    }

    // Take field
    pub fn take_rsig_parts(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.rsig_parts, ::protobuf::RepeatedField::new())
    }

    // repeated .hw.trezor.messages.monero.MoneroTransactionDestinationEntry outputs = 12;


    pub fn get_outputs(&self) -> &[MoneroTransactionDestinationEntry] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<MoneroTransactionDestinationEntry>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<MoneroTransactionDestinationEntry> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<MoneroTransactionDestinationEntry> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MoneroTransactionRsigData {
    fn is_initialized(&self) -> bool {
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rsig_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.offload_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.grouping)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.step = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.operation = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.seed)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.mask)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.amount)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.rsig)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.rsig_parts)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rsig_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.offload_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.grouping {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.step {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.operation {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.seed.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(ref v) = self.mask.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(ref v) = self.amount.as_ref() {
            my_size += ::protobuf::rt::bytes_size(9, &v);
        }
        if let Some(ref v) = self.rsig.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        for value in &self.rsig_parts {
            my_size += ::protobuf::rt::bytes_size(11, &value);
        };
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rsig_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.offload_type {
            os.write_uint32(3, v)?;
        }
        for v in &self.grouping {
            os.write_uint64(4, *v)?;
        };
        if let Some(v) = self.step {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.operation {
            os.write_uint64(6, v)?;
        }
        if let Some(ref v) = self.seed.as_ref() {
            os.write_bytes(7, &v)?;
        }
        if let Some(ref v) = self.mask.as_ref() {
            os.write_bytes(8, &v)?;
        }
        if let Some(ref v) = self.amount.as_ref() {
            os.write_bytes(9, &v)?;
        }
        if let Some(ref v) = self.rsig.as_ref() {
            os.write_bytes(10, &v)?;
        }
        for v in &self.rsig_parts {
            os.write_bytes(11, &v)?;
        };
        for v in &self.outputs {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionRsigData {
        MoneroTransactionRsigData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    |m: &MoneroTransactionRsigData| { &m.version },
                    |m: &mut MoneroTransactionRsigData| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rsig_type",
                    |m: &MoneroTransactionRsigData| { &m.rsig_type },
                    |m: &mut MoneroTransactionRsigData| { &mut m.rsig_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "offload_type",
                    |m: &MoneroTransactionRsigData| { &m.offload_type },
                    |m: &mut MoneroTransactionRsigData| { &mut m.offload_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "grouping",
                    |m: &MoneroTransactionRsigData| { &m.grouping },
                    |m: &mut MoneroTransactionRsigData| { &mut m.grouping },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "step",
                    |m: &MoneroTransactionRsigData| { &m.step },
                    |m: &mut MoneroTransactionRsigData| { &mut m.step },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "operation",
                    |m: &MoneroTransactionRsigData| { &m.operation },
                    |m: &mut MoneroTransactionRsigData| { &mut m.operation },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "seed",
                    |m: &MoneroTransactionRsigData| { &m.seed },
                    |m: &mut MoneroTransactionRsigData| { &mut m.seed },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "mask",
                    |m: &MoneroTransactionRsigData| { &m.mask },
                    |m: &mut MoneroTransactionRsigData| { &mut m.mask },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "amount",
                    |m: &MoneroTransactionRsigData| { &m.amount },
                    |m: &mut MoneroTransactionRsigData| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "rsig",
                    |m: &MoneroTransactionRsigData| { &m.rsig },
                    |m: &mut MoneroTransactionRsigData| { &mut m.rsig },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "rsig_parts",
                    |m: &MoneroTransactionRsigData| { &m.rsig_parts },
                    |m: &mut MoneroTransactionRsigData| { &mut m.rsig_parts },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionDestinationEntry>>(
                    "outputs",
                    |m: &MoneroTransactionRsigData| { &m.outputs },
                    |m: &mut MoneroTransactionRsigData| { &mut m.outputs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionRsigData>(
                    "MoneroTransactionRsigData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionRsigData {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionRsigData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionRsigData,
        };
        unsafe {
            instance.get(MoneroTransactionRsigData::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionRsigData {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.rsig_type = ::std::option::Option::None;
        self.offload_type = ::std::option::Option::None;
        self.grouping.clear();
        self.step = ::std::option::Option::None;
        self.operation = ::std::option::Option::None;
        self.seed.clear();
        self.mask.clear();
        self.amount.clear();
        self.rsig.clear();
        self.rsig_parts.clear();
        self.outputs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionRsigData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionRsigData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroGetAddress {
    // message fields
    address_n: ::std::vec::Vec<u32>,
    show_display: ::std::option::Option<bool>,
    network_type: ::std::option::Option<u32>,
    account: ::std::option::Option<u32>,
    minor: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroGetAddress {
    fn default() -> &'a MoneroGetAddress {
        <MoneroGetAddress as ::protobuf::Message>::default_instance()
    }
}

impl MoneroGetAddress {
    pub fn new() -> MoneroGetAddress {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional bool show_display = 2;


    pub fn get_show_display(&self) -> bool {
        self.show_display.unwrap_or(false)
    }
    pub fn clear_show_display(&mut self) {
        self.show_display = ::std::option::Option::None;
    }

    pub fn has_show_display(&self) -> bool {
        self.show_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_display(&mut self, v: bool) {
        self.show_display = ::std::option::Option::Some(v);
    }

    // optional uint32 network_type = 3;


    pub fn get_network_type(&self) -> u32 {
        self.network_type.unwrap_or(0)
    }
    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: u32) {
        self.network_type = ::std::option::Option::Some(v);
    }

    // optional uint32 account = 4;


    pub fn get_account(&self) -> u32 {
        self.account.unwrap_or(0)
    }
    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // optional uint32 minor = 5;


    pub fn get_minor(&self) -> u32 {
        self.minor.unwrap_or(0)
    }
    pub fn clear_minor(&mut self) {
        self.minor = ::std::option::Option::None;
    }

    pub fn has_minor(&self) -> bool {
        self.minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor(&mut self, v: u32) {
        self.minor = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroGetAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_display = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.minor = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.show_display {
            my_size += 2;
        }
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minor {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.show_display {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.network_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.account {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.minor {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroGetAddress {
        MoneroGetAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address_n",
                    |m: &MoneroGetAddress| { &m.address_n },
                    |m: &mut MoneroGetAddress| { &mut m.address_n },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "show_display",
                    |m: &MoneroGetAddress| { &m.show_display },
                    |m: &mut MoneroGetAddress| { &mut m.show_display },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "network_type",
                    |m: &MoneroGetAddress| { &m.network_type },
                    |m: &mut MoneroGetAddress| { &mut m.network_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account",
                    |m: &MoneroGetAddress| { &m.account },
                    |m: &mut MoneroGetAddress| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "minor",
                    |m: &MoneroGetAddress| { &m.minor },
                    |m: &mut MoneroGetAddress| { &mut m.minor },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroGetAddress>(
                    "MoneroGetAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroGetAddress {
        static mut instance: ::protobuf::lazy::Lazy<MoneroGetAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroGetAddress,
        };
        unsafe {
            instance.get(MoneroGetAddress::new)
        }
    }
}

impl ::protobuf::Clear for MoneroGetAddress {
    fn clear(&mut self) {
        self.address_n.clear();
        self.show_display = ::std::option::Option::None;
        self.network_type = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.minor = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroGetAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroGetAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroAddress {
    // message fields
    address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroAddress {
    fn default() -> &'a MoneroAddress {
        <MoneroAddress as ::protobuf::Message>::default_instance()
    }
}

impl MoneroAddress {
    pub fn new() -> MoneroAddress {
        ::std::default::Default::default()
    }

    // optional bytes address = 1;


    pub fn get_address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroAddress {
        MoneroAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &MoneroAddress| { &m.address },
                    |m: &mut MoneroAddress| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroAddress>(
                    "MoneroAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroAddress {
        static mut instance: ::protobuf::lazy::Lazy<MoneroAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroAddress,
        };
        unsafe {
            instance.get(MoneroAddress::new)
        }
    }
}

impl ::protobuf::Clear for MoneroAddress {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroGetWatchKey {
    // message fields
    address_n: ::std::vec::Vec<u32>,
    network_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroGetWatchKey {
    fn default() -> &'a MoneroGetWatchKey {
        <MoneroGetWatchKey as ::protobuf::Message>::default_instance()
    }
}

impl MoneroGetWatchKey {
    pub fn new() -> MoneroGetWatchKey {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional uint32 network_type = 2;


    pub fn get_network_type(&self) -> u32 {
        self.network_type.unwrap_or(0)
    }
    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: u32) {
        self.network_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroGetWatchKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroGetWatchKey {
        MoneroGetWatchKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address_n",
                    |m: &MoneroGetWatchKey| { &m.address_n },
                    |m: &mut MoneroGetWatchKey| { &mut m.address_n },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "network_type",
                    |m: &MoneroGetWatchKey| { &m.network_type },
                    |m: &mut MoneroGetWatchKey| { &mut m.network_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroGetWatchKey>(
                    "MoneroGetWatchKey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroGetWatchKey {
        static mut instance: ::protobuf::lazy::Lazy<MoneroGetWatchKey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroGetWatchKey,
        };
        unsafe {
            instance.get(MoneroGetWatchKey::new)
        }
    }
}

impl ::protobuf::Clear for MoneroGetWatchKey {
    fn clear(&mut self) {
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroGetWatchKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroGetWatchKey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroWatchKey {
    // message fields
    watch_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    address: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroWatchKey {
    fn default() -> &'a MoneroWatchKey {
        <MoneroWatchKey as ::protobuf::Message>::default_instance()
    }
}

impl MoneroWatchKey {
    pub fn new() -> MoneroWatchKey {
        ::std::default::Default::default()
    }

    // optional bytes watch_key = 1;


    pub fn get_watch_key(&self) -> &[u8] {
        match self.watch_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_watch_key(&mut self) {
        self.watch_key.clear();
    }

    pub fn has_watch_key(&self) -> bool {
        self.watch_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watch_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.watch_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_watch_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.watch_key.is_none() {
            self.watch_key.set_default();
        }
        self.watch_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_watch_key(&mut self) -> ::std::vec::Vec<u8> {
        self.watch_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes address = 2;


    pub fn get_address(&self) -> &[u8] {
        match self.address.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        self.address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroWatchKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.watch_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.watch_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.watch_key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroWatchKey {
        MoneroWatchKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "watch_key",
                    |m: &MoneroWatchKey| { &m.watch_key },
                    |m: &mut MoneroWatchKey| { &mut m.watch_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &MoneroWatchKey| { &m.address },
                    |m: &mut MoneroWatchKey| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroWatchKey>(
                    "MoneroWatchKey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroWatchKey {
        static mut instance: ::protobuf::lazy::Lazy<MoneroWatchKey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroWatchKey,
        };
        unsafe {
            instance.get(MoneroWatchKey::new)
        }
    }
}

impl ::protobuf::Clear for MoneroWatchKey {
    fn clear(&mut self) {
        self.watch_key.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroWatchKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroWatchKey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionInitRequest {
    // message fields
    version: ::std::option::Option<u32>,
    address_n: ::std::vec::Vec<u32>,
    network_type: ::std::option::Option<u32>,
    tsx_data: ::protobuf::SingularPtrField<MoneroTransactionInitRequest_MoneroTransactionData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInitRequest {
    fn default() -> &'a MoneroTransactionInitRequest {
        <MoneroTransactionInitRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInitRequest {
    pub fn new() -> MoneroTransactionInitRequest {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // repeated uint32 address_n = 2;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional uint32 network_type = 3;


    pub fn get_network_type(&self) -> u32 {
        self.network_type.unwrap_or(0)
    }
    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: u32) {
        self.network_type = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionInitRequest.MoneroTransactionData tsx_data = 4;


    pub fn get_tsx_data(&self) -> &MoneroTransactionInitRequest_MoneroTransactionData {
        self.tsx_data.as_ref().unwrap_or_else(|| MoneroTransactionInitRequest_MoneroTransactionData::default_instance())
    }
    pub fn clear_tsx_data(&mut self) {
        self.tsx_data.clear();
    }

    pub fn has_tsx_data(&self) -> bool {
        self.tsx_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tsx_data(&mut self, v: MoneroTransactionInitRequest_MoneroTransactionData) {
        self.tsx_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tsx_data(&mut self) -> &mut MoneroTransactionInitRequest_MoneroTransactionData {
        if self.tsx_data.is_none() {
            self.tsx_data.set_default();
        }
        self.tsx_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_tsx_data(&mut self) -> MoneroTransactionInitRequest_MoneroTransactionData {
        self.tsx_data.take().unwrap_or_else(|| MoneroTransactionInitRequest_MoneroTransactionData::new())
    }
}

impl ::protobuf::Message for MoneroTransactionInitRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.tsx_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tsx_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tsx_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.address_n {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.tsx_data.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionInitRequest {
        MoneroTransactionInitRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    |m: &MoneroTransactionInitRequest| { &m.version },
                    |m: &mut MoneroTransactionInitRequest| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address_n",
                    |m: &MoneroTransactionInitRequest| { &m.address_n },
                    |m: &mut MoneroTransactionInitRequest| { &mut m.address_n },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "network_type",
                    |m: &MoneroTransactionInitRequest| { &m.network_type },
                    |m: &mut MoneroTransactionInitRequest| { &mut m.network_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionInitRequest_MoneroTransactionData>>(
                    "tsx_data",
                    |m: &MoneroTransactionInitRequest| { &m.tsx_data },
                    |m: &mut MoneroTransactionInitRequest| { &mut m.tsx_data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionInitRequest>(
                    "MoneroTransactionInitRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionInitRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionInitRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionInitRequest,
        };
        unsafe {
            instance.get(MoneroTransactionInitRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionInitRequest {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.tsx_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionInitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInitRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionInitRequest_MoneroTransactionData {
    // message fields
    version: ::std::option::Option<u32>,
    payment_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    unlock_time: ::std::option::Option<u64>,
    outputs: ::protobuf::RepeatedField<MoneroTransactionDestinationEntry>,
    change_dts: ::protobuf::SingularPtrField<MoneroTransactionDestinationEntry>,
    num_inputs: ::std::option::Option<u32>,
    mixin: ::std::option::Option<u32>,
    fee: ::std::option::Option<u64>,
    account: ::std::option::Option<u32>,
    minor_indices: ::std::vec::Vec<u32>,
    is_multisig: ::std::option::Option<bool>,
    exp_tx_prefix_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    use_tx_keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    rsig_data: ::protobuf::SingularPtrField<MoneroTransactionRsigData>,
    integrated_indices: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInitRequest_MoneroTransactionData {
    fn default() -> &'a MoneroTransactionInitRequest_MoneroTransactionData {
        <MoneroTransactionInitRequest_MoneroTransactionData as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInitRequest_MoneroTransactionData {
    pub fn new() -> MoneroTransactionInitRequest_MoneroTransactionData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bytes payment_id = 2;


    pub fn get_payment_id(&self) -> &[u8] {
        match self.payment_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_payment_id(&mut self) {
        self.payment_id.clear();
    }

    pub fn has_payment_id(&self) -> bool {
        self.payment_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.payment_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payment_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payment_id.is_none() {
            self.payment_id.set_default();
        }
        self.payment_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_payment_id(&mut self) -> ::std::vec::Vec<u8> {
        self.payment_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 unlock_time = 3;


    pub fn get_unlock_time(&self) -> u64 {
        self.unlock_time.unwrap_or(0)
    }
    pub fn clear_unlock_time(&mut self) {
        self.unlock_time = ::std::option::Option::None;
    }

    pub fn has_unlock_time(&self) -> bool {
        self.unlock_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlock_time(&mut self, v: u64) {
        self.unlock_time = ::std::option::Option::Some(v);
    }

    // repeated .hw.trezor.messages.monero.MoneroTransactionDestinationEntry outputs = 4;


    pub fn get_outputs(&self) -> &[MoneroTransactionDestinationEntry] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<MoneroTransactionDestinationEntry>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<MoneroTransactionDestinationEntry> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<MoneroTransactionDestinationEntry> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry change_dts = 5;


    pub fn get_change_dts(&self) -> &MoneroTransactionDestinationEntry {
        self.change_dts.as_ref().unwrap_or_else(|| MoneroTransactionDestinationEntry::default_instance())
    }
    pub fn clear_change_dts(&mut self) {
        self.change_dts.clear();
    }

    pub fn has_change_dts(&self) -> bool {
        self.change_dts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_dts(&mut self, v: MoneroTransactionDestinationEntry) {
        self.change_dts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_change_dts(&mut self) -> &mut MoneroTransactionDestinationEntry {
        if self.change_dts.is_none() {
            self.change_dts.set_default();
        }
        self.change_dts.as_mut().unwrap()
    }

    // Take field
    pub fn take_change_dts(&mut self) -> MoneroTransactionDestinationEntry {
        self.change_dts.take().unwrap_or_else(|| MoneroTransactionDestinationEntry::new())
    }

    // optional uint32 num_inputs = 6;


    pub fn get_num_inputs(&self) -> u32 {
        self.num_inputs.unwrap_or(0)
    }
    pub fn clear_num_inputs(&mut self) {
        self.num_inputs = ::std::option::Option::None;
    }

    pub fn has_num_inputs(&self) -> bool {
        self.num_inputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_inputs(&mut self, v: u32) {
        self.num_inputs = ::std::option::Option::Some(v);
    }

    // optional uint32 mixin = 7;


    pub fn get_mixin(&self) -> u32 {
        self.mixin.unwrap_or(0)
    }
    pub fn clear_mixin(&mut self) {
        self.mixin = ::std::option::Option::None;
    }

    pub fn has_mixin(&self) -> bool {
        self.mixin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mixin(&mut self, v: u32) {
        self.mixin = ::std::option::Option::Some(v);
    }

    // optional uint64 fee = 8;


    pub fn get_fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }
    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }

    // optional uint32 account = 9;


    pub fn get_account(&self) -> u32 {
        self.account.unwrap_or(0)
    }
    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // repeated uint32 minor_indices = 10;


    pub fn get_minor_indices(&self) -> &[u32] {
        &self.minor_indices
    }
    pub fn clear_minor_indices(&mut self) {
        self.minor_indices.clear();
    }

    // Param is passed by value, moved
    pub fn set_minor_indices(&mut self, v: ::std::vec::Vec<u32>) {
        self.minor_indices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_minor_indices(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.minor_indices
    }

    // Take field
    pub fn take_minor_indices(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.minor_indices, ::std::vec::Vec::new())
    }

    // optional bool is_multisig = 11;


    pub fn get_is_multisig(&self) -> bool {
        self.is_multisig.unwrap_or(false)
    }
    pub fn clear_is_multisig(&mut self) {
        self.is_multisig = ::std::option::Option::None;
    }

    pub fn has_is_multisig(&self) -> bool {
        self.is_multisig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_multisig(&mut self, v: bool) {
        self.is_multisig = ::std::option::Option::Some(v);
    }

    // optional bytes exp_tx_prefix_hash = 12;


    pub fn get_exp_tx_prefix_hash(&self) -> &[u8] {
        match self.exp_tx_prefix_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_exp_tx_prefix_hash(&mut self) {
        self.exp_tx_prefix_hash.clear();
    }

    pub fn has_exp_tx_prefix_hash(&self) -> bool {
        self.exp_tx_prefix_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exp_tx_prefix_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.exp_tx_prefix_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exp_tx_prefix_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.exp_tx_prefix_hash.is_none() {
            self.exp_tx_prefix_hash.set_default();
        }
        self.exp_tx_prefix_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_exp_tx_prefix_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.exp_tx_prefix_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated bytes use_tx_keys = 13;


    pub fn get_use_tx_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.use_tx_keys
    }
    pub fn clear_use_tx_keys(&mut self) {
        self.use_tx_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_use_tx_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.use_tx_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_use_tx_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.use_tx_keys
    }

    // Take field
    pub fn take_use_tx_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.use_tx_keys, ::protobuf::RepeatedField::new())
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 14;


    pub fn get_rsig_data(&self) -> &MoneroTransactionRsigData {
        self.rsig_data.as_ref().unwrap_or_else(|| MoneroTransactionRsigData::default_instance())
    }
    pub fn clear_rsig_data(&mut self) {
        self.rsig_data.clear();
    }

    pub fn has_rsig_data(&self) -> bool {
        self.rsig_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_data(&mut self, v: MoneroTransactionRsigData) {
        self.rsig_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig_data(&mut self) -> &mut MoneroTransactionRsigData {
        if self.rsig_data.is_none() {
            self.rsig_data.set_default();
        }
        self.rsig_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig_data(&mut self) -> MoneroTransactionRsigData {
        self.rsig_data.take().unwrap_or_else(|| MoneroTransactionRsigData::new())
    }

    // repeated uint32 integrated_indices = 15;


    pub fn get_integrated_indices(&self) -> &[u32] {
        &self.integrated_indices
    }
    pub fn clear_integrated_indices(&mut self) {
        self.integrated_indices.clear();
    }

    // Param is passed by value, moved
    pub fn set_integrated_indices(&mut self, v: ::std::vec::Vec<u32>) {
        self.integrated_indices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_integrated_indices(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.integrated_indices
    }

    // Take field
    pub fn take_integrated_indices(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.integrated_indices, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionInitRequest_MoneroTransactionData {
    fn is_initialized(&self) -> bool {
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.change_dts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rsig_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.payment_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.unlock_time = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.change_dts)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.num_inputs = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mixin = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.minor_indices)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_multisig = ::std::option::Option::Some(tmp);
                },
                12 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.exp_tx_prefix_hash)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.use_tx_keys)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rsig_data)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.integrated_indices)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.payment_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.unlock_time {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.change_dts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.num_inputs {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.mixin {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.minor_indices {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.is_multisig {
            my_size += 2;
        }
        if let Some(ref v) = self.exp_tx_prefix_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(12, &v);
        }
        for value in &self.use_tx_keys {
            my_size += ::protobuf::rt::bytes_size(13, &value);
        };
        if let Some(ref v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.integrated_indices {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.payment_id.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.unlock_time {
            os.write_uint64(3, v)?;
        }
        for v in &self.outputs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.change_dts.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.num_inputs {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.mixin {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.account {
            os.write_uint32(9, v)?;
        }
        for v in &self.minor_indices {
            os.write_uint32(10, *v)?;
        };
        if let Some(v) = self.is_multisig {
            os.write_bool(11, v)?;
        }
        if let Some(ref v) = self.exp_tx_prefix_hash.as_ref() {
            os.write_bytes(12, &v)?;
        }
        for v in &self.use_tx_keys {
            os.write_bytes(13, &v)?;
        };
        if let Some(ref v) = self.rsig_data.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.integrated_indices {
            os.write_uint32(15, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionInitRequest_MoneroTransactionData {
        MoneroTransactionInitRequest_MoneroTransactionData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.version },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payment_id",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.payment_id },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.payment_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "unlock_time",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.unlock_time },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.unlock_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionDestinationEntry>>(
                    "outputs",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.outputs },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.outputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionDestinationEntry>>(
                    "change_dts",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.change_dts },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.change_dts },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "num_inputs",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.num_inputs },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.num_inputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "mixin",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.mixin },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.mixin },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fee",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.fee },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.account },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "minor_indices",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.minor_indices },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.minor_indices },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_multisig",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.is_multisig },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.is_multisig },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "exp_tx_prefix_hash",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.exp_tx_prefix_hash },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.exp_tx_prefix_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "use_tx_keys",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.use_tx_keys },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.use_tx_keys },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionRsigData>>(
                    "rsig_data",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.rsig_data },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.rsig_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "integrated_indices",
                    |m: &MoneroTransactionInitRequest_MoneroTransactionData| { &m.integrated_indices },
                    |m: &mut MoneroTransactionInitRequest_MoneroTransactionData| { &mut m.integrated_indices },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionInitRequest_MoneroTransactionData>(
                    "MoneroTransactionInitRequest_MoneroTransactionData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionInitRequest_MoneroTransactionData {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionInitRequest_MoneroTransactionData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionInitRequest_MoneroTransactionData,
        };
        unsafe {
            instance.get(MoneroTransactionInitRequest_MoneroTransactionData::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionInitRequest_MoneroTransactionData {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.payment_id.clear();
        self.unlock_time = ::std::option::Option::None;
        self.outputs.clear();
        self.change_dts.clear();
        self.num_inputs = ::std::option::Option::None;
        self.mixin = ::std::option::Option::None;
        self.fee = ::std::option::Option::None;
        self.account = ::std::option::Option::None;
        self.minor_indices.clear();
        self.is_multisig = ::std::option::Option::None;
        self.exp_tx_prefix_hash.clear();
        self.use_tx_keys.clear();
        self.rsig_data.clear();
        self.integrated_indices.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionInitRequest_MoneroTransactionData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInitRequest_MoneroTransactionData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionInitAck {
    // message fields
    version: ::std::option::Option<u32>,
    status: ::std::option::Option<u32>,
    in_memory: ::std::option::Option<bool>,
    hmacs: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    many_inputs: ::std::option::Option<bool>,
    many_outputs: ::std::option::Option<bool>,
    rsig_data: ::protobuf::SingularPtrField<MoneroTransactionRsigData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInitAck {
    fn default() -> &'a MoneroTransactionInitAck {
        <MoneroTransactionInitAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInitAck {
    pub fn new() -> MoneroTransactionInitAck {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 status = 2;


    pub fn get_status(&self) -> u32 {
        self.status.unwrap_or(0)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional bool in_memory = 3;


    pub fn get_in_memory(&self) -> bool {
        self.in_memory.unwrap_or(false)
    }
    pub fn clear_in_memory(&mut self) {
        self.in_memory = ::std::option::Option::None;
    }

    pub fn has_in_memory(&self) -> bool {
        self.in_memory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_memory(&mut self, v: bool) {
        self.in_memory = ::std::option::Option::Some(v);
    }

    // repeated bytes hmacs = 4;


    pub fn get_hmacs(&self) -> &[::std::vec::Vec<u8>] {
        &self.hmacs
    }
    pub fn clear_hmacs(&mut self) {
        self.hmacs.clear();
    }

    // Param is passed by value, moved
    pub fn set_hmacs(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.hmacs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hmacs(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.hmacs
    }

    // Take field
    pub fn take_hmacs(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.hmacs, ::protobuf::RepeatedField::new())
    }

    // optional bool many_inputs = 5;


    pub fn get_many_inputs(&self) -> bool {
        self.many_inputs.unwrap_or(false)
    }
    pub fn clear_many_inputs(&mut self) {
        self.many_inputs = ::std::option::Option::None;
    }

    pub fn has_many_inputs(&self) -> bool {
        self.many_inputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_many_inputs(&mut self, v: bool) {
        self.many_inputs = ::std::option::Option::Some(v);
    }

    // optional bool many_outputs = 6;


    pub fn get_many_outputs(&self) -> bool {
        self.many_outputs.unwrap_or(false)
    }
    pub fn clear_many_outputs(&mut self) {
        self.many_outputs = ::std::option::Option::None;
    }

    pub fn has_many_outputs(&self) -> bool {
        self.many_outputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_many_outputs(&mut self, v: bool) {
        self.many_outputs = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 7;


    pub fn get_rsig_data(&self) -> &MoneroTransactionRsigData {
        self.rsig_data.as_ref().unwrap_or_else(|| MoneroTransactionRsigData::default_instance())
    }
    pub fn clear_rsig_data(&mut self) {
        self.rsig_data.clear();
    }

    pub fn has_rsig_data(&self) -> bool {
        self.rsig_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_data(&mut self, v: MoneroTransactionRsigData) {
        self.rsig_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig_data(&mut self) -> &mut MoneroTransactionRsigData {
        if self.rsig_data.is_none() {
            self.rsig_data.set_default();
        }
        self.rsig_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig_data(&mut self) -> MoneroTransactionRsigData {
        self.rsig_data.take().unwrap_or_else(|| MoneroTransactionRsigData::new())
    }
}

impl ::protobuf::Message for MoneroTransactionInitAck {
    fn is_initialized(&self) -> bool {
        for v in &self.rsig_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_memory = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.hmacs)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.many_inputs = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.many_outputs = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rsig_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.in_memory {
            my_size += 2;
        }
        for value in &self.hmacs {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        if let Some(v) = self.many_inputs {
            my_size += 2;
        }
        if let Some(v) = self.many_outputs {
            my_size += 2;
        }
        if let Some(ref v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.status {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.in_memory {
            os.write_bool(3, v)?;
        }
        for v in &self.hmacs {
            os.write_bytes(4, &v)?;
        };
        if let Some(v) = self.many_inputs {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.many_outputs {
            os.write_bool(6, v)?;
        }
        if let Some(ref v) = self.rsig_data.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionInitAck {
        MoneroTransactionInitAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    |m: &MoneroTransactionInitAck| { &m.version },
                    |m: &mut MoneroTransactionInitAck| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "status",
                    |m: &MoneroTransactionInitAck| { &m.status },
                    |m: &mut MoneroTransactionInitAck| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "in_memory",
                    |m: &MoneroTransactionInitAck| { &m.in_memory },
                    |m: &mut MoneroTransactionInitAck| { &mut m.in_memory },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hmacs",
                    |m: &MoneroTransactionInitAck| { &m.hmacs },
                    |m: &mut MoneroTransactionInitAck| { &mut m.hmacs },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "many_inputs",
                    |m: &MoneroTransactionInitAck| { &m.many_inputs },
                    |m: &mut MoneroTransactionInitAck| { &mut m.many_inputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "many_outputs",
                    |m: &MoneroTransactionInitAck| { &m.many_outputs },
                    |m: &mut MoneroTransactionInitAck| { &mut m.many_outputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionRsigData>>(
                    "rsig_data",
                    |m: &MoneroTransactionInitAck| { &m.rsig_data },
                    |m: &mut MoneroTransactionInitAck| { &mut m.rsig_data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionInitAck>(
                    "MoneroTransactionInitAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionInitAck {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionInitAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionInitAck,
        };
        unsafe {
            instance.get(MoneroTransactionInitAck::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionInitAck {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.in_memory = ::std::option::Option::None;
        self.hmacs.clear();
        self.many_inputs = ::std::option::Option::None;
        self.many_outputs = ::std::option::Option::None;
        self.rsig_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionInitAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInitAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSetInputRequest {
    // message fields
    version: ::std::option::Option<u32>,
    src_entr: ::protobuf::SingularPtrField<MoneroTransactionSourceEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetInputRequest {
    fn default() -> &'a MoneroTransactionSetInputRequest {
        <MoneroTransactionSetInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetInputRequest {
    pub fn new() -> MoneroTransactionSetInputRequest {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version.unwrap_or(0)
    }
    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 2;


    pub fn get_src_entr(&self) -> &MoneroTransactionSourceEntry {
        self.src_entr.as_ref().unwrap_or_else(|| MoneroTransactionSourceEntry::default_instance())
    }
    pub fn clear_src_entr(&mut self) {
        self.src_entr.clear();
    }

    pub fn has_src_entr(&self) -> bool {
        self.src_entr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_entr(&mut self, v: MoneroTransactionSourceEntry) {
        self.src_entr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_entr(&mut self) -> &mut MoneroTransactionSourceEntry {
        if self.src_entr.is_none() {
            self.src_entr.set_default();
        }
        self.src_entr.as_mut().unwrap()
    }

    // Take field
    pub fn take_src_entr(&mut self) -> MoneroTransactionSourceEntry {
        self.src_entr.take().unwrap_or_else(|| MoneroTransactionSourceEntry::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSetInputRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.src_entr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.src_entr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.src_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.src_entr.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSetInputRequest {
        MoneroTransactionSetInputRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "version",
                    |m: &MoneroTransactionSetInputRequest| { &m.version },
                    |m: &mut MoneroTransactionSetInputRequest| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionSourceEntry>>(
                    "src_entr",
                    |m: &MoneroTransactionSetInputRequest| { &m.src_entr },
                    |m: &mut MoneroTransactionSetInputRequest| { &mut m.src_entr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionSetInputRequest>(
                    "MoneroTransactionSetInputRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionSetInputRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionSetInputRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionSetInputRequest,
        };
        unsafe {
            instance.get(MoneroTransactionSetInputRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionSetInputRequest {
    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.src_entr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSetInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetInputRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSetInputAck {
    // message fields
    vini: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    vini_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    alpha_enc: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    spend_enc: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetInputAck {
    fn default() -> &'a MoneroTransactionSetInputAck {
        <MoneroTransactionSetInputAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetInputAck {
    pub fn new() -> MoneroTransactionSetInputAck {
        ::std::default::Default::default()
    }

    // optional bytes vini = 1;


    pub fn get_vini(&self) -> &[u8] {
        match self.vini.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_vini(&mut self) {
        self.vini.clear();
    }

    pub fn has_vini(&self) -> bool {
        self.vini.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini.is_none() {
            self.vini.set_default();
        }
        self.vini.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini(&mut self) -> ::std::vec::Vec<u8> {
        self.vini.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vini_hmac = 2;


    pub fn get_vini_hmac(&self) -> &[u8] {
        match self.vini_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_vini_hmac(&mut self) {
        self.vini_hmac.clear();
    }

    pub fn has_vini_hmac(&self) -> bool {
        self.vini_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini_hmac.is_none() {
            self.vini_hmac.set_default();
        }
        self.vini_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vini_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out = 3;


    pub fn get_pseudo_out(&self) -> &[u8] {
        match self.pseudo_out.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out(&mut self) {
        self.pseudo_out.clear();
    }

    pub fn has_pseudo_out(&self) -> bool {
        self.pseudo_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out.is_none() {
            self.pseudo_out.set_default();
        }
        self.pseudo_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_hmac = 4;


    pub fn get_pseudo_out_hmac(&self) -> &[u8] {
        match self.pseudo_out_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out_hmac(&mut self) {
        self.pseudo_out_hmac.clear();
    }

    pub fn has_pseudo_out_hmac(&self) -> bool {
        self.pseudo_out_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_hmac.is_none() {
            self.pseudo_out_hmac.set_default();
        }
        self.pseudo_out_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes alpha_enc = 5;


    pub fn get_alpha_enc(&self) -> &[u8] {
        match self.alpha_enc.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_alpha_enc(&mut self) {
        self.alpha_enc.clear();
    }

    pub fn has_alpha_enc(&self) -> bool {
        self.alpha_enc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alpha_enc(&mut self, v: ::std::vec::Vec<u8>) {
        self.alpha_enc = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alpha_enc(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.alpha_enc.is_none() {
            self.alpha_enc.set_default();
        }
        self.alpha_enc.as_mut().unwrap()
    }

    // Take field
    pub fn take_alpha_enc(&mut self) -> ::std::vec::Vec<u8> {
        self.alpha_enc.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes spend_enc = 6;


    pub fn get_spend_enc(&self) -> &[u8] {
        match self.spend_enc.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_spend_enc(&mut self) {
        self.spend_enc.clear();
    }

    pub fn has_spend_enc(&self) -> bool {
        self.spend_enc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spend_enc(&mut self, v: ::std::vec::Vec<u8>) {
        self.spend_enc = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spend_enc(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.spend_enc.is_none() {
            self.spend_enc.set_default();
        }
        self.spend_enc.as_mut().unwrap()
    }

    // Take field
    pub fn take_spend_enc(&mut self) -> ::std::vec::Vec<u8> {
        self.spend_enc.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSetInputAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.vini)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.vini_hmac)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out_hmac)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.alpha_enc)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.spend_enc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vini.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.vini_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.pseudo_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.pseudo_out_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.alpha_enc.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.spend_enc.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vini.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.vini_hmac.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.pseudo_out.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.pseudo_out_hmac.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.alpha_enc.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.spend_enc.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSetInputAck {
        MoneroTransactionSetInputAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "vini",
                    |m: &MoneroTransactionSetInputAck| { &m.vini },
                    |m: &mut MoneroTransactionSetInputAck| { &mut m.vini },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "vini_hmac",
                    |m: &MoneroTransactionSetInputAck| { &m.vini_hmac },
                    |m: &mut MoneroTransactionSetInputAck| { &mut m.vini_hmac },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pseudo_out",
                    |m: &MoneroTransactionSetInputAck| { &m.pseudo_out },
                    |m: &mut MoneroTransactionSetInputAck| { &mut m.pseudo_out },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pseudo_out_hmac",
                    |m: &MoneroTransactionSetInputAck| { &m.pseudo_out_hmac },
                    |m: &mut MoneroTransactionSetInputAck| { &mut m.pseudo_out_hmac },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "alpha_enc",
                    |m: &MoneroTransactionSetInputAck| { &m.alpha_enc },
                    |m: &mut MoneroTransactionSetInputAck| { &mut m.alpha_enc },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "spend_enc",
                    |m: &MoneroTransactionSetInputAck| { &m.spend_enc },
                    |m: &mut MoneroTransactionSetInputAck| { &mut m.spend_enc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionSetInputAck>(
                    "MoneroTransactionSetInputAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionSetInputAck {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionSetInputAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionSetInputAck,
        };
        unsafe {
            instance.get(MoneroTransactionSetInputAck::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionSetInputAck {
    fn clear(&mut self) {
        self.vini.clear();
        self.vini_hmac.clear();
        self.pseudo_out.clear();
        self.pseudo_out_hmac.clear();
        self.alpha_enc.clear();
        self.spend_enc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSetInputAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetInputAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionInputsPermutationRequest {
    // message fields
    perm: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInputsPermutationRequest {
    fn default() -> &'a MoneroTransactionInputsPermutationRequest {
        <MoneroTransactionInputsPermutationRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInputsPermutationRequest {
    pub fn new() -> MoneroTransactionInputsPermutationRequest {
        ::std::default::Default::default()
    }

    // repeated uint32 perm = 1;


    pub fn get_perm(&self) -> &[u32] {
        &self.perm
    }
    pub fn clear_perm(&mut self) {
        self.perm.clear();
    }

    // Param is passed by value, moved
    pub fn set_perm(&mut self, v: ::std::vec::Vec<u32>) {
        self.perm = v;
    }

    // Mutable pointer to the field.
    pub fn mut_perm(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.perm
    }

    // Take field
    pub fn take_perm(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.perm, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionInputsPermutationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.perm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.perm {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.perm {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionInputsPermutationRequest {
        MoneroTransactionInputsPermutationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "perm",
                    |m: &MoneroTransactionInputsPermutationRequest| { &m.perm },
                    |m: &mut MoneroTransactionInputsPermutationRequest| { &mut m.perm },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionInputsPermutationRequest>(
                    "MoneroTransactionInputsPermutationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionInputsPermutationRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionInputsPermutationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionInputsPermutationRequest,
        };
        unsafe {
            instance.get(MoneroTransactionInputsPermutationRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionInputsPermutationRequest {
    fn clear(&mut self) {
        self.perm.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionInputsPermutationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInputsPermutationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionInputsPermutationAck {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInputsPermutationAck {
    fn default() -> &'a MoneroTransactionInputsPermutationAck {
        <MoneroTransactionInputsPermutationAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInputsPermutationAck {
    pub fn new() -> MoneroTransactionInputsPermutationAck {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroTransactionInputsPermutationAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionInputsPermutationAck {
        MoneroTransactionInputsPermutationAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionInputsPermutationAck>(
                    "MoneroTransactionInputsPermutationAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionInputsPermutationAck {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionInputsPermutationAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionInputsPermutationAck,
        };
        unsafe {
            instance.get(MoneroTransactionInputsPermutationAck::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionInputsPermutationAck {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionInputsPermutationAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInputsPermutationAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionInputViniRequest {
    // message fields
    src_entr: ::protobuf::SingularPtrField<MoneroTransactionSourceEntry>,
    vini: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    vini_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInputViniRequest {
    fn default() -> &'a MoneroTransactionInputViniRequest {
        <MoneroTransactionInputViniRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInputViniRequest {
    pub fn new() -> MoneroTransactionInputViniRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;


    pub fn get_src_entr(&self) -> &MoneroTransactionSourceEntry {
        self.src_entr.as_ref().unwrap_or_else(|| MoneroTransactionSourceEntry::default_instance())
    }
    pub fn clear_src_entr(&mut self) {
        self.src_entr.clear();
    }

    pub fn has_src_entr(&self) -> bool {
        self.src_entr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_entr(&mut self, v: MoneroTransactionSourceEntry) {
        self.src_entr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_entr(&mut self) -> &mut MoneroTransactionSourceEntry {
        if self.src_entr.is_none() {
            self.src_entr.set_default();
        }
        self.src_entr.as_mut().unwrap()
    }

    // Take field
    pub fn take_src_entr(&mut self) -> MoneroTransactionSourceEntry {
        self.src_entr.take().unwrap_or_else(|| MoneroTransactionSourceEntry::new())
    }

    // optional bytes vini = 2;


    pub fn get_vini(&self) -> &[u8] {
        match self.vini.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_vini(&mut self) {
        self.vini.clear();
    }

    pub fn has_vini(&self) -> bool {
        self.vini.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini.is_none() {
            self.vini.set_default();
        }
        self.vini.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini(&mut self) -> ::std::vec::Vec<u8> {
        self.vini.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vini_hmac = 3;


    pub fn get_vini_hmac(&self) -> &[u8] {
        match self.vini_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_vini_hmac(&mut self) {
        self.vini_hmac.clear();
    }

    pub fn has_vini_hmac(&self) -> bool {
        self.vini_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini_hmac.is_none() {
            self.vini_hmac.set_default();
        }
        self.vini_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vini_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out = 4;


    pub fn get_pseudo_out(&self) -> &[u8] {
        match self.pseudo_out.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out(&mut self) {
        self.pseudo_out.clear();
    }

    pub fn has_pseudo_out(&self) -> bool {
        self.pseudo_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out.is_none() {
            self.pseudo_out.set_default();
        }
        self.pseudo_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_hmac = 5;


    pub fn get_pseudo_out_hmac(&self) -> &[u8] {
        match self.pseudo_out_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out_hmac(&mut self) {
        self.pseudo_out_hmac.clear();
    }

    pub fn has_pseudo_out_hmac(&self) -> bool {
        self.pseudo_out_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_hmac.is_none() {
            self.pseudo_out_hmac.set_default();
        }
        self.pseudo_out_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionInputViniRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.src_entr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.src_entr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.vini)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.vini_hmac)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out_hmac)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vini.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.vini_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.pseudo_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.pseudo_out_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src_entr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vini.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.vini_hmac.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.pseudo_out.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.pseudo_out_hmac.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionInputViniRequest {
        MoneroTransactionInputViniRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionSourceEntry>>(
                    "src_entr",
                    |m: &MoneroTransactionInputViniRequest| { &m.src_entr },
                    |m: &mut MoneroTransactionInputViniRequest| { &mut m.src_entr },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "vini",
                    |m: &MoneroTransactionInputViniRequest| { &m.vini },
                    |m: &mut MoneroTransactionInputViniRequest| { &mut m.vini },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "vini_hmac",
                    |m: &MoneroTransactionInputViniRequest| { &m.vini_hmac },
                    |m: &mut MoneroTransactionInputViniRequest| { &mut m.vini_hmac },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pseudo_out",
                    |m: &MoneroTransactionInputViniRequest| { &m.pseudo_out },
                    |m: &mut MoneroTransactionInputViniRequest| { &mut m.pseudo_out },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pseudo_out_hmac",
                    |m: &MoneroTransactionInputViniRequest| { &m.pseudo_out_hmac },
                    |m: &mut MoneroTransactionInputViniRequest| { &mut m.pseudo_out_hmac },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionInputViniRequest>(
                    "MoneroTransactionInputViniRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionInputViniRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionInputViniRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionInputViniRequest,
        };
        unsafe {
            instance.get(MoneroTransactionInputViniRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionInputViniRequest {
    fn clear(&mut self) {
        self.src_entr.clear();
        self.vini.clear();
        self.vini_hmac.clear();
        self.pseudo_out.clear();
        self.pseudo_out_hmac.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionInputViniRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInputViniRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionInputViniAck {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionInputViniAck {
    fn default() -> &'a MoneroTransactionInputViniAck {
        <MoneroTransactionInputViniAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionInputViniAck {
    pub fn new() -> MoneroTransactionInputViniAck {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroTransactionInputViniAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionInputViniAck {
        MoneroTransactionInputViniAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionInputViniAck>(
                    "MoneroTransactionInputViniAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionInputViniAck {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionInputViniAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionInputViniAck,
        };
        unsafe {
            instance.get(MoneroTransactionInputViniAck::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionInputViniAck {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionInputViniAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionInputViniAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionAllInputsSetRequest {
    // message fields
    rsig_data: ::protobuf::SingularPtrField<MoneroTransactionRsigData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllInputsSetRequest {
    fn default() -> &'a MoneroTransactionAllInputsSetRequest {
        <MoneroTransactionAllInputsSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllInputsSetRequest {
    pub fn new() -> MoneroTransactionAllInputsSetRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;


    pub fn get_rsig_data(&self) -> &MoneroTransactionRsigData {
        self.rsig_data.as_ref().unwrap_or_else(|| MoneroTransactionRsigData::default_instance())
    }
    pub fn clear_rsig_data(&mut self) {
        self.rsig_data.clear();
    }

    pub fn has_rsig_data(&self) -> bool {
        self.rsig_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_data(&mut self, v: MoneroTransactionRsigData) {
        self.rsig_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig_data(&mut self) -> &mut MoneroTransactionRsigData {
        if self.rsig_data.is_none() {
            self.rsig_data.set_default();
        }
        self.rsig_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig_data(&mut self) -> MoneroTransactionRsigData {
        self.rsig_data.take().unwrap_or_else(|| MoneroTransactionRsigData::new())
    }
}

impl ::protobuf::Message for MoneroTransactionAllInputsSetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.rsig_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rsig_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rsig_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionAllInputsSetRequest {
        MoneroTransactionAllInputsSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionRsigData>>(
                    "rsig_data",
                    |m: &MoneroTransactionAllInputsSetRequest| { &m.rsig_data },
                    |m: &mut MoneroTransactionAllInputsSetRequest| { &mut m.rsig_data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionAllInputsSetRequest>(
                    "MoneroTransactionAllInputsSetRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionAllInputsSetRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionAllInputsSetRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionAllInputsSetRequest,
        };
        unsafe {
            instance.get(MoneroTransactionAllInputsSetRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionAllInputsSetRequest {
    fn clear(&mut self) {
        self.rsig_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionAllInputsSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllInputsSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionAllInputsSetAck {
    // message fields
    rsig_data: ::protobuf::SingularPtrField<MoneroTransactionRsigData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllInputsSetAck {
    fn default() -> &'a MoneroTransactionAllInputsSetAck {
        <MoneroTransactionAllInputsSetAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllInputsSetAck {
    pub fn new() -> MoneroTransactionAllInputsSetAck {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;


    pub fn get_rsig_data(&self) -> &MoneroTransactionRsigData {
        self.rsig_data.as_ref().unwrap_or_else(|| MoneroTransactionRsigData::default_instance())
    }
    pub fn clear_rsig_data(&mut self) {
        self.rsig_data.clear();
    }

    pub fn has_rsig_data(&self) -> bool {
        self.rsig_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_data(&mut self, v: MoneroTransactionRsigData) {
        self.rsig_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig_data(&mut self) -> &mut MoneroTransactionRsigData {
        if self.rsig_data.is_none() {
            self.rsig_data.set_default();
        }
        self.rsig_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig_data(&mut self) -> MoneroTransactionRsigData {
        self.rsig_data.take().unwrap_or_else(|| MoneroTransactionRsigData::new())
    }
}

impl ::protobuf::Message for MoneroTransactionAllInputsSetAck {
    fn is_initialized(&self) -> bool {
        for v in &self.rsig_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rsig_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rsig_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionAllInputsSetAck {
        MoneroTransactionAllInputsSetAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionRsigData>>(
                    "rsig_data",
                    |m: &MoneroTransactionAllInputsSetAck| { &m.rsig_data },
                    |m: &mut MoneroTransactionAllInputsSetAck| { &mut m.rsig_data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionAllInputsSetAck>(
                    "MoneroTransactionAllInputsSetAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionAllInputsSetAck {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionAllInputsSetAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionAllInputsSetAck,
        };
        unsafe {
            instance.get(MoneroTransactionAllInputsSetAck::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionAllInputsSetAck {
    fn clear(&mut self) {
        self.rsig_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionAllInputsSetAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllInputsSetAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSetOutputRequest {
    // message fields
    dst_entr: ::protobuf::SingularPtrField<MoneroTransactionDestinationEntry>,
    dst_entr_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rsig_data: ::protobuf::SingularPtrField<MoneroTransactionRsigData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetOutputRequest {
    fn default() -> &'a MoneroTransactionSetOutputRequest {
        <MoneroTransactionSetOutputRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetOutputRequest {
    pub fn new() -> MoneroTransactionSetOutputRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionDestinationEntry dst_entr = 1;


    pub fn get_dst_entr(&self) -> &MoneroTransactionDestinationEntry {
        self.dst_entr.as_ref().unwrap_or_else(|| MoneroTransactionDestinationEntry::default_instance())
    }
    pub fn clear_dst_entr(&mut self) {
        self.dst_entr.clear();
    }

    pub fn has_dst_entr(&self) -> bool {
        self.dst_entr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_entr(&mut self, v: MoneroTransactionDestinationEntry) {
        self.dst_entr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_entr(&mut self) -> &mut MoneroTransactionDestinationEntry {
        if self.dst_entr.is_none() {
            self.dst_entr.set_default();
        }
        self.dst_entr.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst_entr(&mut self) -> MoneroTransactionDestinationEntry {
        self.dst_entr.take().unwrap_or_else(|| MoneroTransactionDestinationEntry::new())
    }

    // optional bytes dst_entr_hmac = 2;


    pub fn get_dst_entr_hmac(&self) -> &[u8] {
        match self.dst_entr_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_dst_entr_hmac(&mut self) {
        self.dst_entr_hmac.clear();
    }

    pub fn has_dst_entr_hmac(&self) -> bool {
        self.dst_entr_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_entr_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.dst_entr_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_entr_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.dst_entr_hmac.is_none() {
            self.dst_entr_hmac.set_default();
        }
        self.dst_entr_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst_entr_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.dst_entr_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;


    pub fn get_rsig_data(&self) -> &MoneroTransactionRsigData {
        self.rsig_data.as_ref().unwrap_or_else(|| MoneroTransactionRsigData::default_instance())
    }
    pub fn clear_rsig_data(&mut self) {
        self.rsig_data.clear();
    }

    pub fn has_rsig_data(&self) -> bool {
        self.rsig_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_data(&mut self, v: MoneroTransactionRsigData) {
        self.rsig_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig_data(&mut self) -> &mut MoneroTransactionRsigData {
        if self.rsig_data.is_none() {
            self.rsig_data.set_default();
        }
        self.rsig_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig_data(&mut self) -> MoneroTransactionRsigData {
        self.rsig_data.take().unwrap_or_else(|| MoneroTransactionRsigData::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSetOutputRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.dst_entr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rsig_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dst_entr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.dst_entr_hmac)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rsig_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dst_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dst_entr_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dst_entr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dst_entr_hmac.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.rsig_data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSetOutputRequest {
        MoneroTransactionSetOutputRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionDestinationEntry>>(
                    "dst_entr",
                    |m: &MoneroTransactionSetOutputRequest| { &m.dst_entr },
                    |m: &mut MoneroTransactionSetOutputRequest| { &mut m.dst_entr },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "dst_entr_hmac",
                    |m: &MoneroTransactionSetOutputRequest| { &m.dst_entr_hmac },
                    |m: &mut MoneroTransactionSetOutputRequest| { &mut m.dst_entr_hmac },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionRsigData>>(
                    "rsig_data",
                    |m: &MoneroTransactionSetOutputRequest| { &m.rsig_data },
                    |m: &mut MoneroTransactionSetOutputRequest| { &mut m.rsig_data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionSetOutputRequest>(
                    "MoneroTransactionSetOutputRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionSetOutputRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionSetOutputRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionSetOutputRequest,
        };
        unsafe {
            instance.get(MoneroTransactionSetOutputRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionSetOutputRequest {
    fn clear(&mut self) {
        self.dst_entr.clear();
        self.dst_entr_hmac.clear();
        self.rsig_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSetOutputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetOutputRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSetOutputAck {
    // message fields
    tx_out: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    vouti_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rsig_data: ::protobuf::SingularPtrField<MoneroTransactionRsigData>,
    out_pk: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ecdh_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSetOutputAck {
    fn default() -> &'a MoneroTransactionSetOutputAck {
        <MoneroTransactionSetOutputAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSetOutputAck {
    pub fn new() -> MoneroTransactionSetOutputAck {
        ::std::default::Default::default()
    }

    // optional bytes tx_out = 1;


    pub fn get_tx_out(&self) -> &[u8] {
        match self.tx_out.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_tx_out(&mut self) {
        self.tx_out.clear();
    }

    pub fn has_tx_out(&self) -> bool {
        self.tx_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_out = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_out.is_none() {
            self.tx_out.set_default();
        }
        self.tx_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_out(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vouti_hmac = 2;


    pub fn get_vouti_hmac(&self) -> &[u8] {
        match self.vouti_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_vouti_hmac(&mut self) {
        self.vouti_hmac.clear();
    }

    pub fn has_vouti_hmac(&self) -> bool {
        self.vouti_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vouti_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vouti_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vouti_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vouti_hmac.is_none() {
            self.vouti_hmac.set_default();
        }
        self.vouti_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vouti_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vouti_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;


    pub fn get_rsig_data(&self) -> &MoneroTransactionRsigData {
        self.rsig_data.as_ref().unwrap_or_else(|| MoneroTransactionRsigData::default_instance())
    }
    pub fn clear_rsig_data(&mut self) {
        self.rsig_data.clear();
    }

    pub fn has_rsig_data(&self) -> bool {
        self.rsig_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_data(&mut self, v: MoneroTransactionRsigData) {
        self.rsig_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig_data(&mut self) -> &mut MoneroTransactionRsigData {
        if self.rsig_data.is_none() {
            self.rsig_data.set_default();
        }
        self.rsig_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig_data(&mut self) -> MoneroTransactionRsigData {
        self.rsig_data.take().unwrap_or_else(|| MoneroTransactionRsigData::new())
    }

    // optional bytes out_pk = 4;


    pub fn get_out_pk(&self) -> &[u8] {
        match self.out_pk.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_out_pk(&mut self) {
        self.out_pk.clear();
    }

    pub fn has_out_pk(&self) -> bool {
        self.out_pk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_pk(&mut self, v: ::std::vec::Vec<u8>) {
        self.out_pk = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out_pk(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.out_pk.is_none() {
            self.out_pk.set_default();
        }
        self.out_pk.as_mut().unwrap()
    }

    // Take field
    pub fn take_out_pk(&mut self) -> ::std::vec::Vec<u8> {
        self.out_pk.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes ecdh_info = 5;


    pub fn get_ecdh_info(&self) -> &[u8] {
        match self.ecdh_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ecdh_info(&mut self) {
        self.ecdh_info.clear();
    }

    pub fn has_ecdh_info(&self) -> bool {
        self.ecdh_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecdh_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.ecdh_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ecdh_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ecdh_info.is_none() {
            self.ecdh_info.set_default();
        }
        self.ecdh_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_ecdh_info(&mut self) -> ::std::vec::Vec<u8> {
        self.ecdh_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSetOutputAck {
    fn is_initialized(&self) -> bool {
        for v in &self.rsig_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tx_out)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.vouti_hmac)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rsig_data)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.out_pk)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ecdh_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tx_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.vouti_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.out_pk.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.ecdh_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tx_out.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.vouti_hmac.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.rsig_data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.out_pk.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.ecdh_info.as_ref() {
            os.write_bytes(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSetOutputAck {
        MoneroTransactionSetOutputAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "tx_out",
                    |m: &MoneroTransactionSetOutputAck| { &m.tx_out },
                    |m: &mut MoneroTransactionSetOutputAck| { &mut m.tx_out },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "vouti_hmac",
                    |m: &MoneroTransactionSetOutputAck| { &m.vouti_hmac },
                    |m: &mut MoneroTransactionSetOutputAck| { &mut m.vouti_hmac },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionRsigData>>(
                    "rsig_data",
                    |m: &MoneroTransactionSetOutputAck| { &m.rsig_data },
                    |m: &mut MoneroTransactionSetOutputAck| { &mut m.rsig_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "out_pk",
                    |m: &MoneroTransactionSetOutputAck| { &m.out_pk },
                    |m: &mut MoneroTransactionSetOutputAck| { &mut m.out_pk },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ecdh_info",
                    |m: &MoneroTransactionSetOutputAck| { &m.ecdh_info },
                    |m: &mut MoneroTransactionSetOutputAck| { &mut m.ecdh_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionSetOutputAck>(
                    "MoneroTransactionSetOutputAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionSetOutputAck {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionSetOutputAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionSetOutputAck,
        };
        unsafe {
            instance.get(MoneroTransactionSetOutputAck::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionSetOutputAck {
    fn clear(&mut self) {
        self.tx_out.clear();
        self.vouti_hmac.clear();
        self.rsig_data.clear();
        self.out_pk.clear();
        self.ecdh_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSetOutputAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSetOutputAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionAllOutSetRequest {
    // message fields
    rsig_data: ::protobuf::SingularPtrField<MoneroTransactionRsigData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllOutSetRequest {
    fn default() -> &'a MoneroTransactionAllOutSetRequest {
        <MoneroTransactionAllOutSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllOutSetRequest {
    pub fn new() -> MoneroTransactionAllOutSetRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 1;


    pub fn get_rsig_data(&self) -> &MoneroTransactionRsigData {
        self.rsig_data.as_ref().unwrap_or_else(|| MoneroTransactionRsigData::default_instance())
    }
    pub fn clear_rsig_data(&mut self) {
        self.rsig_data.clear();
    }

    pub fn has_rsig_data(&self) -> bool {
        self.rsig_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_data(&mut self, v: MoneroTransactionRsigData) {
        self.rsig_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig_data(&mut self) -> &mut MoneroTransactionRsigData {
        if self.rsig_data.is_none() {
            self.rsig_data.set_default();
        }
        self.rsig_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig_data(&mut self) -> MoneroTransactionRsigData {
        self.rsig_data.take().unwrap_or_else(|| MoneroTransactionRsigData::new())
    }
}

impl ::protobuf::Message for MoneroTransactionAllOutSetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.rsig_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rsig_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rsig_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionAllOutSetRequest {
        MoneroTransactionAllOutSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionRsigData>>(
                    "rsig_data",
                    |m: &MoneroTransactionAllOutSetRequest| { &m.rsig_data },
                    |m: &mut MoneroTransactionAllOutSetRequest| { &mut m.rsig_data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionAllOutSetRequest>(
                    "MoneroTransactionAllOutSetRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionAllOutSetRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionAllOutSetRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionAllOutSetRequest,
        };
        unsafe {
            instance.get(MoneroTransactionAllOutSetRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionAllOutSetRequest {
    fn clear(&mut self) {
        self.rsig_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionAllOutSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllOutSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionAllOutSetAck {
    // message fields
    extra: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    tx_prefix_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rsig_data: ::protobuf::SingularPtrField<MoneroTransactionRsigData>,
    rv: ::protobuf::SingularPtrField<MoneroTransactionAllOutSetAck_MoneroRingCtSig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllOutSetAck {
    fn default() -> &'a MoneroTransactionAllOutSetAck {
        <MoneroTransactionAllOutSetAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllOutSetAck {
    pub fn new() -> MoneroTransactionAllOutSetAck {
        ::std::default::Default::default()
    }

    // optional bytes extra = 1;


    pub fn get_extra(&self) -> &[u8] {
        match self.extra.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_extra(&mut self) {
        self.extra.clear();
    }

    pub fn has_extra(&self) -> bool {
        self.extra.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.extra.is_none() {
            self.extra.set_default();
        }
        self.extra.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra(&mut self) -> ::std::vec::Vec<u8> {
        self.extra.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_prefix_hash = 2;


    pub fn get_tx_prefix_hash(&self) -> &[u8] {
        match self.tx_prefix_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_tx_prefix_hash(&mut self) {
        self.tx_prefix_hash.clear();
    }

    pub fn has_tx_prefix_hash(&self) -> bool {
        self.tx_prefix_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_prefix_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_prefix_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_prefix_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_prefix_hash.is_none() {
            self.tx_prefix_hash.set_default();
        }
        self.tx_prefix_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_prefix_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_prefix_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionRsigData rsig_data = 3;


    pub fn get_rsig_data(&self) -> &MoneroTransactionRsigData {
        self.rsig_data.as_ref().unwrap_or_else(|| MoneroTransactionRsigData::default_instance())
    }
    pub fn clear_rsig_data(&mut self) {
        self.rsig_data.clear();
    }

    pub fn has_rsig_data(&self) -> bool {
        self.rsig_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rsig_data(&mut self, v: MoneroTransactionRsigData) {
        self.rsig_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsig_data(&mut self) -> &mut MoneroTransactionRsigData {
        if self.rsig_data.is_none() {
            self.rsig_data.set_default();
        }
        self.rsig_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_rsig_data(&mut self) -> MoneroTransactionRsigData {
        self.rsig_data.take().unwrap_or_else(|| MoneroTransactionRsigData::new())
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSig rv = 4;


    pub fn get_rv(&self) -> &MoneroTransactionAllOutSetAck_MoneroRingCtSig {
        self.rv.as_ref().unwrap_or_else(|| MoneroTransactionAllOutSetAck_MoneroRingCtSig::default_instance())
    }
    pub fn clear_rv(&mut self) {
        self.rv.clear();
    }

    pub fn has_rv(&self) -> bool {
        self.rv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rv(&mut self, v: MoneroTransactionAllOutSetAck_MoneroRingCtSig) {
        self.rv = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rv(&mut self) -> &mut MoneroTransactionAllOutSetAck_MoneroRingCtSig {
        if self.rv.is_none() {
            self.rv.set_default();
        }
        self.rv.as_mut().unwrap()
    }

    // Take field
    pub fn take_rv(&mut self) -> MoneroTransactionAllOutSetAck_MoneroRingCtSig {
        self.rv.take().unwrap_or_else(|| MoneroTransactionAllOutSetAck_MoneroRingCtSig::new())
    }
}

impl ::protobuf::Message for MoneroTransactionAllOutSetAck {
    fn is_initialized(&self) -> bool {
        for v in &self.rsig_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rv {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.extra)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tx_prefix_hash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rsig_data)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rv)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.extra.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.tx_prefix_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.rsig_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.extra.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.tx_prefix_hash.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.rsig_data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rv.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionAllOutSetAck {
        MoneroTransactionAllOutSetAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra",
                    |m: &MoneroTransactionAllOutSetAck| { &m.extra },
                    |m: &mut MoneroTransactionAllOutSetAck| { &mut m.extra },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "tx_prefix_hash",
                    |m: &MoneroTransactionAllOutSetAck| { &m.tx_prefix_hash },
                    |m: &mut MoneroTransactionAllOutSetAck| { &mut m.tx_prefix_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionRsigData>>(
                    "rsig_data",
                    |m: &MoneroTransactionAllOutSetAck| { &m.rsig_data },
                    |m: &mut MoneroTransactionAllOutSetAck| { &mut m.rsig_data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionAllOutSetAck_MoneroRingCtSig>>(
                    "rv",
                    |m: &MoneroTransactionAllOutSetAck| { &m.rv },
                    |m: &mut MoneroTransactionAllOutSetAck| { &mut m.rv },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionAllOutSetAck>(
                    "MoneroTransactionAllOutSetAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionAllOutSetAck {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionAllOutSetAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionAllOutSetAck,
        };
        unsafe {
            instance.get(MoneroTransactionAllOutSetAck::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionAllOutSetAck {
    fn clear(&mut self) {
        self.extra.clear();
        self.tx_prefix_hash.clear();
        self.rsig_data.clear();
        self.rv.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionAllOutSetAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllOutSetAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionAllOutSetAck_MoneroRingCtSig {
    // message fields
    txn_fee: ::std::option::Option<u64>,
    message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rv_type: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionAllOutSetAck_MoneroRingCtSig {
    fn default() -> &'a MoneroTransactionAllOutSetAck_MoneroRingCtSig {
        <MoneroTransactionAllOutSetAck_MoneroRingCtSig as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionAllOutSetAck_MoneroRingCtSig {
    pub fn new() -> MoneroTransactionAllOutSetAck_MoneroRingCtSig {
        ::std::default::Default::default()
    }

    // optional uint64 txn_fee = 1;


    pub fn get_txn_fee(&self) -> u64 {
        self.txn_fee.unwrap_or(0)
    }
    pub fn clear_txn_fee(&mut self) {
        self.txn_fee = ::std::option::Option::None;
    }

    pub fn has_txn_fee(&self) -> bool {
        self.txn_fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_fee(&mut self, v: u64) {
        self.txn_fee = ::std::option::Option::Some(v);
    }

    // optional bytes message = 2;


    pub fn get_message(&self) -> &[u8] {
        match self.message.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        self.message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 rv_type = 3;


    pub fn get_rv_type(&self) -> u32 {
        self.rv_type.unwrap_or(0)
    }
    pub fn clear_rv_type(&mut self) {
        self.rv_type = ::std::option::Option::None;
    }

    pub fn has_rv_type(&self) -> bool {
        self.rv_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rv_type(&mut self, v: u32) {
        self.rv_type = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroTransactionAllOutSetAck_MoneroRingCtSig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txn_fee = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rv_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.txn_fee {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.rv_type {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.txn_fee {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.rv_type {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionAllOutSetAck_MoneroRingCtSig {
        MoneroTransactionAllOutSetAck_MoneroRingCtSig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "txn_fee",
                    |m: &MoneroTransactionAllOutSetAck_MoneroRingCtSig| { &m.txn_fee },
                    |m: &mut MoneroTransactionAllOutSetAck_MoneroRingCtSig| { &mut m.txn_fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "message",
                    |m: &MoneroTransactionAllOutSetAck_MoneroRingCtSig| { &m.message },
                    |m: &mut MoneroTransactionAllOutSetAck_MoneroRingCtSig| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rv_type",
                    |m: &MoneroTransactionAllOutSetAck_MoneroRingCtSig| { &m.rv_type },
                    |m: &mut MoneroTransactionAllOutSetAck_MoneroRingCtSig| { &mut m.rv_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionAllOutSetAck_MoneroRingCtSig>(
                    "MoneroTransactionAllOutSetAck_MoneroRingCtSig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionAllOutSetAck_MoneroRingCtSig {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionAllOutSetAck_MoneroRingCtSig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionAllOutSetAck_MoneroRingCtSig,
        };
        unsafe {
            instance.get(MoneroTransactionAllOutSetAck_MoneroRingCtSig::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionAllOutSetAck_MoneroRingCtSig {
    fn clear(&mut self) {
        self.txn_fee = ::std::option::Option::None;
        self.message.clear();
        self.rv_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionAllOutSetAck_MoneroRingCtSig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionAllOutSetAck_MoneroRingCtSig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionMlsagDoneRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionMlsagDoneRequest {
    fn default() -> &'a MoneroTransactionMlsagDoneRequest {
        <MoneroTransactionMlsagDoneRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionMlsagDoneRequest {
    pub fn new() -> MoneroTransactionMlsagDoneRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroTransactionMlsagDoneRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionMlsagDoneRequest {
        MoneroTransactionMlsagDoneRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionMlsagDoneRequest>(
                    "MoneroTransactionMlsagDoneRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionMlsagDoneRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionMlsagDoneRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionMlsagDoneRequest,
        };
        unsafe {
            instance.get(MoneroTransactionMlsagDoneRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionMlsagDoneRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionMlsagDoneRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionMlsagDoneRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionMlsagDoneAck {
    // message fields
    full_message_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionMlsagDoneAck {
    fn default() -> &'a MoneroTransactionMlsagDoneAck {
        <MoneroTransactionMlsagDoneAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionMlsagDoneAck {
    pub fn new() -> MoneroTransactionMlsagDoneAck {
        ::std::default::Default::default()
    }

    // optional bytes full_message_hash = 1;


    pub fn get_full_message_hash(&self) -> &[u8] {
        match self.full_message_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_full_message_hash(&mut self) {
        self.full_message_hash.clear();
    }

    pub fn has_full_message_hash(&self) -> bool {
        self.full_message_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_message_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.full_message_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_message_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.full_message_hash.is_none() {
            self.full_message_hash.set_default();
        }
        self.full_message_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_full_message_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.full_message_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionMlsagDoneAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.full_message_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.full_message_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.full_message_hash.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionMlsagDoneAck {
        MoneroTransactionMlsagDoneAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "full_message_hash",
                    |m: &MoneroTransactionMlsagDoneAck| { &m.full_message_hash },
                    |m: &mut MoneroTransactionMlsagDoneAck| { &mut m.full_message_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionMlsagDoneAck>(
                    "MoneroTransactionMlsagDoneAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionMlsagDoneAck {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionMlsagDoneAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionMlsagDoneAck,
        };
        unsafe {
            instance.get(MoneroTransactionMlsagDoneAck::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionMlsagDoneAck {
    fn clear(&mut self) {
        self.full_message_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionMlsagDoneAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionMlsagDoneAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSignInputRequest {
    // message fields
    src_entr: ::protobuf::SingularPtrField<MoneroTransactionSourceEntry>,
    vini: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    vini_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pseudo_out_hmac: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    alpha_enc: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    spend_enc: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSignInputRequest {
    fn default() -> &'a MoneroTransactionSignInputRequest {
        <MoneroTransactionSignInputRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSignInputRequest {
    pub fn new() -> MoneroTransactionSignInputRequest {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.monero.MoneroTransactionSourceEntry src_entr = 1;


    pub fn get_src_entr(&self) -> &MoneroTransactionSourceEntry {
        self.src_entr.as_ref().unwrap_or_else(|| MoneroTransactionSourceEntry::default_instance())
    }
    pub fn clear_src_entr(&mut self) {
        self.src_entr.clear();
    }

    pub fn has_src_entr(&self) -> bool {
        self.src_entr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_entr(&mut self, v: MoneroTransactionSourceEntry) {
        self.src_entr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_entr(&mut self) -> &mut MoneroTransactionSourceEntry {
        if self.src_entr.is_none() {
            self.src_entr.set_default();
        }
        self.src_entr.as_mut().unwrap()
    }

    // Take field
    pub fn take_src_entr(&mut self) -> MoneroTransactionSourceEntry {
        self.src_entr.take().unwrap_or_else(|| MoneroTransactionSourceEntry::new())
    }

    // optional bytes vini = 2;


    pub fn get_vini(&self) -> &[u8] {
        match self.vini.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_vini(&mut self) {
        self.vini.clear();
    }

    pub fn has_vini(&self) -> bool {
        self.vini.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini.is_none() {
            self.vini.set_default();
        }
        self.vini.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini(&mut self) -> ::std::vec::Vec<u8> {
        self.vini.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes vini_hmac = 3;


    pub fn get_vini_hmac(&self) -> &[u8] {
        match self.vini_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_vini_hmac(&mut self) {
        self.vini_hmac.clear();
    }

    pub fn has_vini_hmac(&self) -> bool {
        self.vini_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vini_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.vini_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vini_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.vini_hmac.is_none() {
            self.vini_hmac.set_default();
        }
        self.vini_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_vini_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.vini_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out = 4;


    pub fn get_pseudo_out(&self) -> &[u8] {
        match self.pseudo_out.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out(&mut self) {
        self.pseudo_out.clear();
    }

    pub fn has_pseudo_out(&self) -> bool {
        self.pseudo_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out.is_none() {
            self.pseudo_out.set_default();
        }
        self.pseudo_out.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes pseudo_out_hmac = 5;


    pub fn get_pseudo_out_hmac(&self) -> &[u8] {
        match self.pseudo_out_hmac.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pseudo_out_hmac(&mut self) {
        self.pseudo_out_hmac.clear();
    }

    pub fn has_pseudo_out_hmac(&self) -> bool {
        self.pseudo_out_hmac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pseudo_out_hmac(&mut self, v: ::std::vec::Vec<u8>) {
        self.pseudo_out_hmac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pseudo_out_hmac(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pseudo_out_hmac.is_none() {
            self.pseudo_out_hmac.set_default();
        }
        self.pseudo_out_hmac.as_mut().unwrap()
    }

    // Take field
    pub fn take_pseudo_out_hmac(&mut self) -> ::std::vec::Vec<u8> {
        self.pseudo_out_hmac.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes alpha_enc = 6;


    pub fn get_alpha_enc(&self) -> &[u8] {
        match self.alpha_enc.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_alpha_enc(&mut self) {
        self.alpha_enc.clear();
    }

    pub fn has_alpha_enc(&self) -> bool {
        self.alpha_enc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alpha_enc(&mut self, v: ::std::vec::Vec<u8>) {
        self.alpha_enc = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alpha_enc(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.alpha_enc.is_none() {
            self.alpha_enc.set_default();
        }
        self.alpha_enc.as_mut().unwrap()
    }

    // Take field
    pub fn take_alpha_enc(&mut self) -> ::std::vec::Vec<u8> {
        self.alpha_enc.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes spend_enc = 7;


    pub fn get_spend_enc(&self) -> &[u8] {
        match self.spend_enc.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_spend_enc(&mut self) {
        self.spend_enc.clear();
    }

    pub fn has_spend_enc(&self) -> bool {
        self.spend_enc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spend_enc(&mut self, v: ::std::vec::Vec<u8>) {
        self.spend_enc = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spend_enc(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.spend_enc.is_none() {
            self.spend_enc.set_default();
        }
        self.spend_enc.as_mut().unwrap()
    }

    // Take field
    pub fn take_spend_enc(&mut self) -> ::std::vec::Vec<u8> {
        self.spend_enc.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSignInputRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.src_entr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.src_entr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.vini)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.vini_hmac)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pseudo_out_hmac)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.alpha_enc)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.spend_enc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src_entr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vini.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.vini_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.pseudo_out.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.pseudo_out_hmac.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.alpha_enc.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(ref v) = self.spend_enc.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src_entr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vini.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.vini_hmac.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.pseudo_out.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.pseudo_out_hmac.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.alpha_enc.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(ref v) = self.spend_enc.as_ref() {
            os.write_bytes(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSignInputRequest {
        MoneroTransactionSignInputRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroTransactionSourceEntry>>(
                    "src_entr",
                    |m: &MoneroTransactionSignInputRequest| { &m.src_entr },
                    |m: &mut MoneroTransactionSignInputRequest| { &mut m.src_entr },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "vini",
                    |m: &MoneroTransactionSignInputRequest| { &m.vini },
                    |m: &mut MoneroTransactionSignInputRequest| { &mut m.vini },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "vini_hmac",
                    |m: &MoneroTransactionSignInputRequest| { &m.vini_hmac },
                    |m: &mut MoneroTransactionSignInputRequest| { &mut m.vini_hmac },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pseudo_out",
                    |m: &MoneroTransactionSignInputRequest| { &m.pseudo_out },
                    |m: &mut MoneroTransactionSignInputRequest| { &mut m.pseudo_out },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pseudo_out_hmac",
                    |m: &MoneroTransactionSignInputRequest| { &m.pseudo_out_hmac },
                    |m: &mut MoneroTransactionSignInputRequest| { &mut m.pseudo_out_hmac },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "alpha_enc",
                    |m: &MoneroTransactionSignInputRequest| { &m.alpha_enc },
                    |m: &mut MoneroTransactionSignInputRequest| { &mut m.alpha_enc },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "spend_enc",
                    |m: &MoneroTransactionSignInputRequest| { &m.spend_enc },
                    |m: &mut MoneroTransactionSignInputRequest| { &mut m.spend_enc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionSignInputRequest>(
                    "MoneroTransactionSignInputRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionSignInputRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionSignInputRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionSignInputRequest,
        };
        unsafe {
            instance.get(MoneroTransactionSignInputRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionSignInputRequest {
    fn clear(&mut self) {
        self.src_entr.clear();
        self.vini.clear();
        self.vini_hmac.clear();
        self.pseudo_out.clear();
        self.pseudo_out_hmac.clear();
        self.alpha_enc.clear();
        self.spend_enc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSignInputRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSignInputRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionSignInputAck {
    // message fields
    signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    cout: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionSignInputAck {
    fn default() -> &'a MoneroTransactionSignInputAck {
        <MoneroTransactionSignInputAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionSignInputAck {
    pub fn new() -> MoneroTransactionSignInputAck {
        ::std::default::Default::default()
    }

    // optional bytes signature = 1;


    pub fn get_signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes cout = 2;


    pub fn get_cout(&self) -> &[u8] {
        match self.cout.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_cout(&mut self) {
        self.cout.clear();
    }

    pub fn has_cout(&self) -> bool {
        self.cout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cout(&mut self, v: ::std::vec::Vec<u8>) {
        self.cout = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cout(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.cout.is_none() {
            self.cout.set_default();
        }
        self.cout.as_mut().unwrap()
    }

    // Take field
    pub fn take_cout(&mut self) -> ::std::vec::Vec<u8> {
        self.cout.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionSignInputAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.signature)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.cout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.cout.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signature.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.cout.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionSignInputAck {
        MoneroTransactionSignInputAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "signature",
                    |m: &MoneroTransactionSignInputAck| { &m.signature },
                    |m: &mut MoneroTransactionSignInputAck| { &mut m.signature },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "cout",
                    |m: &MoneroTransactionSignInputAck| { &m.cout },
                    |m: &mut MoneroTransactionSignInputAck| { &mut m.cout },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionSignInputAck>(
                    "MoneroTransactionSignInputAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionSignInputAck {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionSignInputAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionSignInputAck,
        };
        unsafe {
            instance.get(MoneroTransactionSignInputAck::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionSignInputAck {
    fn clear(&mut self) {
        self.signature.clear();
        self.cout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionSignInputAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionSignInputAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionFinalRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionFinalRequest {
    fn default() -> &'a MoneroTransactionFinalRequest {
        <MoneroTransactionFinalRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionFinalRequest {
    pub fn new() -> MoneroTransactionFinalRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroTransactionFinalRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionFinalRequest {
        MoneroTransactionFinalRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionFinalRequest>(
                    "MoneroTransactionFinalRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionFinalRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionFinalRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionFinalRequest,
        };
        unsafe {
            instance.get(MoneroTransactionFinalRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionFinalRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionFinalRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionFinalRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroTransactionFinalAck {
    // message fields
    cout_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    salt: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rand_mult: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    tx_enc_keys: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroTransactionFinalAck {
    fn default() -> &'a MoneroTransactionFinalAck {
        <MoneroTransactionFinalAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroTransactionFinalAck {
    pub fn new() -> MoneroTransactionFinalAck {
        ::std::default::Default::default()
    }

    // optional bytes cout_key = 1;


    pub fn get_cout_key(&self) -> &[u8] {
        match self.cout_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_cout_key(&mut self) {
        self.cout_key.clear();
    }

    pub fn has_cout_key(&self) -> bool {
        self.cout_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cout_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.cout_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cout_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.cout_key.is_none() {
            self.cout_key.set_default();
        }
        self.cout_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_cout_key(&mut self) -> ::std::vec::Vec<u8> {
        self.cout_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes salt = 2;


    pub fn get_salt(&self) -> &[u8] {
        match self.salt.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_salt(&mut self) {
        self.salt.clear();
    }

    pub fn has_salt(&self) -> bool {
        self.salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_salt(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.salt.is_none() {
            self.salt.set_default();
        }
        self.salt.as_mut().unwrap()
    }

    // Take field
    pub fn take_salt(&mut self) -> ::std::vec::Vec<u8> {
        self.salt.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes rand_mult = 3;


    pub fn get_rand_mult(&self) -> &[u8] {
        match self.rand_mult.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_rand_mult(&mut self) {
        self.rand_mult.clear();
    }

    pub fn has_rand_mult(&self) -> bool {
        self.rand_mult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rand_mult(&mut self, v: ::std::vec::Vec<u8>) {
        self.rand_mult = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rand_mult(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.rand_mult.is_none() {
            self.rand_mult.set_default();
        }
        self.rand_mult.as_mut().unwrap()
    }

    // Take field
    pub fn take_rand_mult(&mut self) -> ::std::vec::Vec<u8> {
        self.rand_mult.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_enc_keys = 4;


    pub fn get_tx_enc_keys(&self) -> &[u8] {
        match self.tx_enc_keys.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_tx_enc_keys(&mut self) {
        self.tx_enc_keys.clear();
    }

    pub fn has_tx_enc_keys(&self) -> bool {
        self.tx_enc_keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_enc_keys(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_enc_keys = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_enc_keys(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_enc_keys.is_none() {
            self.tx_enc_keys.set_default();
        }
        self.tx_enc_keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_enc_keys(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_enc_keys.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroTransactionFinalAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.cout_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.salt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.rand_mult)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tx_enc_keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cout_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.salt.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.rand_mult.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.tx_enc_keys.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cout_key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.salt.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.rand_mult.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.tx_enc_keys.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroTransactionFinalAck {
        MoneroTransactionFinalAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "cout_key",
                    |m: &MoneroTransactionFinalAck| { &m.cout_key },
                    |m: &mut MoneroTransactionFinalAck| { &mut m.cout_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "salt",
                    |m: &MoneroTransactionFinalAck| { &m.salt },
                    |m: &mut MoneroTransactionFinalAck| { &mut m.salt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "rand_mult",
                    |m: &MoneroTransactionFinalAck| { &m.rand_mult },
                    |m: &mut MoneroTransactionFinalAck| { &mut m.rand_mult },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "tx_enc_keys",
                    |m: &MoneroTransactionFinalAck| { &m.tx_enc_keys },
                    |m: &mut MoneroTransactionFinalAck| { &mut m.tx_enc_keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroTransactionFinalAck>(
                    "MoneroTransactionFinalAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroTransactionFinalAck {
        static mut instance: ::protobuf::lazy::Lazy<MoneroTransactionFinalAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroTransactionFinalAck,
        };
        unsafe {
            instance.get(MoneroTransactionFinalAck::new)
        }
    }
}

impl ::protobuf::Clear for MoneroTransactionFinalAck {
    fn clear(&mut self) {
        self.cout_key.clear();
        self.salt.clear();
        self.rand_mult.clear();
        self.tx_enc_keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroTransactionFinalAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroTransactionFinalAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageExportInitRequest {
    // message fields
    num: ::std::option::Option<u64>,
    hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    address_n: ::std::vec::Vec<u32>,
    network_type: ::std::option::Option<u32>,
    subs: ::protobuf::RepeatedField<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageExportInitRequest {
    fn default() -> &'a MoneroKeyImageExportInitRequest {
        <MoneroKeyImageExportInitRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageExportInitRequest {
    pub fn new() -> MoneroKeyImageExportInitRequest {
        ::std::default::Default::default()
    }

    // optional uint64 num = 1;


    pub fn get_num(&self) -> u64 {
        self.num.unwrap_or(0)
    }
    pub fn clear_num(&mut self) {
        self.num = ::std::option::Option::None;
    }

    pub fn has_num(&self) -> bool {
        self.num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num(&mut self, v: u64) {
        self.num = ::std::option::Option::Some(v);
    }

    // optional bytes hash = 2;


    pub fn get_hash(&self) -> &[u8] {
        match self.hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hash.is_none() {
            self.hash.set_default();
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated uint32 address_n = 3;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional uint32 network_type = 4;


    pub fn get_network_type(&self) -> u32 {
        self.network_type.unwrap_or(0)
    }
    pub fn clear_network_type(&mut self) {
        self.network_type = ::std::option::Option::None;
    }

    pub fn has_network_type(&self) -> bool {
        self.network_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_type(&mut self, v: u32) {
        self.network_type = ::std::option::Option::Some(v);
    }

    // repeated .hw.trezor.messages.monero.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesList subs = 5;


    pub fn get_subs(&self) -> &[MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList] {
        &self.subs
    }
    pub fn clear_subs(&mut self) {
        self.subs.clear();
    }

    // Param is passed by value, moved
    pub fn set_subs(&mut self, v: ::protobuf::RepeatedField<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList>) {
        self.subs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subs(&mut self) -> &mut ::protobuf::RepeatedField<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList> {
        &mut self.subs
    }

    // Take field
    pub fn take_subs(&mut self) -> ::protobuf::RepeatedField<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList> {
        ::std::mem::replace(&mut self.subs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MoneroKeyImageExportInitRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.subs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.num = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.hash)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.network_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.num {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.network_type {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.subs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.num {
            os.write_uint64(1, v)?;
        }
        if let Some(ref v) = self.hash.as_ref() {
            os.write_bytes(2, &v)?;
        }
        for v in &self.address_n {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.network_type {
            os.write_uint32(4, v)?;
        }
        for v in &self.subs {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageExportInitRequest {
        MoneroKeyImageExportInitRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "num",
                    |m: &MoneroKeyImageExportInitRequest| { &m.num },
                    |m: &mut MoneroKeyImageExportInitRequest| { &mut m.num },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &MoneroKeyImageExportInitRequest| { &m.hash },
                    |m: &mut MoneroKeyImageExportInitRequest| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address_n",
                    |m: &MoneroKeyImageExportInitRequest| { &m.address_n },
                    |m: &mut MoneroKeyImageExportInitRequest| { &mut m.address_n },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "network_type",
                    |m: &MoneroKeyImageExportInitRequest| { &m.network_type },
                    |m: &mut MoneroKeyImageExportInitRequest| { &mut m.network_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList>>(
                    "subs",
                    |m: &MoneroKeyImageExportInitRequest| { &m.subs },
                    |m: &mut MoneroKeyImageExportInitRequest| { &mut m.subs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroKeyImageExportInitRequest>(
                    "MoneroKeyImageExportInitRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroKeyImageExportInitRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoneroKeyImageExportInitRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroKeyImageExportInitRequest,
        };
        unsafe {
            instance.get(MoneroKeyImageExportInitRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoneroKeyImageExportInitRequest {
    fn clear(&mut self) {
        self.num = ::std::option::Option::None;
        self.hash.clear();
        self.address_n.clear();
        self.network_type = ::std::option::Option::None;
        self.subs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageExportInitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageExportInitRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
    // message fields
    account: ::std::option::Option<u32>,
    minor_indices: ::std::vec::Vec<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
    fn default() -> &'a MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
        <MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
    pub fn new() -> MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
        ::std::default::Default::default()
    }

    // optional uint32 account = 1;


    pub fn get_account(&self) -> u32 {
        self.account.unwrap_or(0)
    }
    pub fn clear_account(&mut self) {
        self.account = ::std::option::Option::None;
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: u32) {
        self.account = ::std::option::Option::Some(v);
    }

    // repeated uint32 minor_indices = 2;


    pub fn get_minor_indices(&self) -> &[u32] {
        &self.minor_indices
    }
    pub fn clear_minor_indices(&mut self) {
        self.minor_indices.clear();
    }

    // Param is passed by value, moved
    pub fn set_minor_indices(&mut self, v: ::std::vec::Vec<u32>) {
        self.minor_indices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_minor_indices(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.minor_indices
    }

    // Take field
    pub fn take_minor_indices(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.minor_indices, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.account = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.minor_indices)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.account {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.minor_indices {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.account {
            os.write_uint32(1, v)?;
        }
        for v in &self.minor_indices {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
        MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "account",
                    |m: &MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList| { &m.account },
                    |m: &mut MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "minor_indices",
                    |m: &MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList| { &m.minor_indices },
                    |m: &mut MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList| { &mut m.minor_indices },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList>(
                    "MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
        static mut instance: ::protobuf::lazy::Lazy<MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList,
        };
        unsafe {
            instance.get(MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList::new)
        }
    }
}

impl ::protobuf::Clear for MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
    fn clear(&mut self) {
        self.account = ::std::option::Option::None;
        self.minor_indices.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageExportInitRequest_MoneroSubAddressIndicesList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageExportInitAck {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageExportInitAck {
    fn default() -> &'a MoneroKeyImageExportInitAck {
        <MoneroKeyImageExportInitAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageExportInitAck {
    pub fn new() -> MoneroKeyImageExportInitAck {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroKeyImageExportInitAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageExportInitAck {
        MoneroKeyImageExportInitAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<MoneroKeyImageExportInitAck>(
                    "MoneroKeyImageExportInitAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroKeyImageExportInitAck {
        static mut instance: ::protobuf::lazy::Lazy<MoneroKeyImageExportInitAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroKeyImageExportInitAck,
        };
        unsafe {
            instance.get(MoneroKeyImageExportInitAck::new)
        }
    }
}

impl ::protobuf::Clear for MoneroKeyImageExportInitAck {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageExportInitAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageExportInitAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageSyncStepRequest {
    // message fields
    tdis: ::protobuf::RepeatedField<MoneroKeyImageSyncStepRequest_MoneroTransferDetails>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncStepRequest {
    fn default() -> &'a MoneroKeyImageSyncStepRequest {
        <MoneroKeyImageSyncStepRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncStepRequest {
    pub fn new() -> MoneroKeyImageSyncStepRequest {
        ::std::default::Default::default()
    }

    // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetails tdis = 1;


    pub fn get_tdis(&self) -> &[MoneroKeyImageSyncStepRequest_MoneroTransferDetails] {
        &self.tdis
    }
    pub fn clear_tdis(&mut self) {
        self.tdis.clear();
    }

    // Param is passed by value, moved
    pub fn set_tdis(&mut self, v: ::protobuf::RepeatedField<MoneroKeyImageSyncStepRequest_MoneroTransferDetails>) {
        self.tdis = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tdis(&mut self) -> &mut ::protobuf::RepeatedField<MoneroKeyImageSyncStepRequest_MoneroTransferDetails> {
        &mut self.tdis
    }

    // Take field
    pub fn take_tdis(&mut self) -> ::protobuf::RepeatedField<MoneroKeyImageSyncStepRequest_MoneroTransferDetails> {
        ::std::mem::replace(&mut self.tdis, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncStepRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.tdis {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tdis)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tdis {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tdis {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageSyncStepRequest {
        MoneroKeyImageSyncStepRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroKeyImageSyncStepRequest_MoneroTransferDetails>>(
                    "tdis",
                    |m: &MoneroKeyImageSyncStepRequest| { &m.tdis },
                    |m: &mut MoneroKeyImageSyncStepRequest| { &mut m.tdis },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroKeyImageSyncStepRequest>(
                    "MoneroKeyImageSyncStepRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroKeyImageSyncStepRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoneroKeyImageSyncStepRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroKeyImageSyncStepRequest,
        };
        unsafe {
            instance.get(MoneroKeyImageSyncStepRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoneroKeyImageSyncStepRequest {
    fn clear(&mut self) {
        self.tdis.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageSyncStepRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncStepRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
    // message fields
    out_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    tx_pub_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    additional_tx_pub_keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    internal_output_index: ::std::option::Option<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
    fn default() -> &'a MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
        <MoneroKeyImageSyncStepRequest_MoneroTransferDetails as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
    pub fn new() -> MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
        ::std::default::Default::default()
    }

    // optional bytes out_key = 1;


    pub fn get_out_key(&self) -> &[u8] {
        match self.out_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_out_key(&mut self) {
        self.out_key.clear();
    }

    pub fn has_out_key(&self) -> bool {
        self.out_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.out_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.out_key.is_none() {
            self.out_key.set_default();
        }
        self.out_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_out_key(&mut self) -> ::std::vec::Vec<u8> {
        self.out_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tx_pub_key = 2;


    pub fn get_tx_pub_key(&self) -> &[u8] {
        match self.tx_pub_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_tx_pub_key(&mut self) {
        self.tx_pub_key.clear();
    }

    pub fn has_tx_pub_key(&self) -> bool {
        self.tx_pub_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_pub_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.tx_pub_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx_pub_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tx_pub_key.is_none() {
            self.tx_pub_key.set_default();
        }
        self.tx_pub_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx_pub_key(&mut self) -> ::std::vec::Vec<u8> {
        self.tx_pub_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated bytes additional_tx_pub_keys = 3;


    pub fn get_additional_tx_pub_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.additional_tx_pub_keys
    }
    pub fn clear_additional_tx_pub_keys(&mut self) {
        self.additional_tx_pub_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_additional_tx_pub_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.additional_tx_pub_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_additional_tx_pub_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.additional_tx_pub_keys
    }

    // Take field
    pub fn take_additional_tx_pub_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.additional_tx_pub_keys, ::protobuf::RepeatedField::new())
    }

    // optional uint64 internal_output_index = 4;


    pub fn get_internal_output_index(&self) -> u64 {
        self.internal_output_index.unwrap_or(0)
    }
    pub fn clear_internal_output_index(&mut self) {
        self.internal_output_index = ::std::option::Option::None;
    }

    pub fn has_internal_output_index(&self) -> bool {
        self.internal_output_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_internal_output_index(&mut self, v: u64) {
        self.internal_output_index = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.out_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tx_pub_key)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.additional_tx_pub_keys)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.internal_output_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.out_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.tx_pub_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.additional_tx_pub_keys {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        if let Some(v) = self.internal_output_index {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.out_key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.tx_pub_key.as_ref() {
            os.write_bytes(2, &v)?;
        }
        for v in &self.additional_tx_pub_keys {
            os.write_bytes(3, &v)?;
        };
        if let Some(v) = self.internal_output_index {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
        MoneroKeyImageSyncStepRequest_MoneroTransferDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "out_key",
                    |m: &MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &m.out_key },
                    |m: &mut MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &mut m.out_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "tx_pub_key",
                    |m: &MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &m.tx_pub_key },
                    |m: &mut MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &mut m.tx_pub_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "additional_tx_pub_keys",
                    |m: &MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &m.additional_tx_pub_keys },
                    |m: &mut MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &mut m.additional_tx_pub_keys },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "internal_output_index",
                    |m: &MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &m.internal_output_index },
                    |m: &mut MoneroKeyImageSyncStepRequest_MoneroTransferDetails| { &mut m.internal_output_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroKeyImageSyncStepRequest_MoneroTransferDetails>(
                    "MoneroKeyImageSyncStepRequest_MoneroTransferDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
        static mut instance: ::protobuf::lazy::Lazy<MoneroKeyImageSyncStepRequest_MoneroTransferDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroKeyImageSyncStepRequest_MoneroTransferDetails,
        };
        unsafe {
            instance.get(MoneroKeyImageSyncStepRequest_MoneroTransferDetails::new)
        }
    }
}

impl ::protobuf::Clear for MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
    fn clear(&mut self) {
        self.out_key.clear();
        self.tx_pub_key.clear();
        self.additional_tx_pub_keys.clear();
        self.internal_output_index = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncStepRequest_MoneroTransferDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageSyncStepAck {
    // message fields
    kis: ::protobuf::RepeatedField<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncStepAck {
    fn default() -> &'a MoneroKeyImageSyncStepAck {
        <MoneroKeyImageSyncStepAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncStepAck {
    pub fn new() -> MoneroKeyImageSyncStepAck {
        ::std::default::Default::default()
    }

    // repeated .hw.trezor.messages.monero.MoneroKeyImageSyncStepAck.MoneroExportedKeyImage kis = 1;


    pub fn get_kis(&self) -> &[MoneroKeyImageSyncStepAck_MoneroExportedKeyImage] {
        &self.kis
    }
    pub fn clear_kis(&mut self) {
        self.kis.clear();
    }

    // Param is passed by value, moved
    pub fn set_kis(&mut self, v: ::protobuf::RepeatedField<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage>) {
        self.kis = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kis(&mut self) -> &mut ::protobuf::RepeatedField<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage> {
        &mut self.kis
    }

    // Take field
    pub fn take_kis(&mut self) -> ::protobuf::RepeatedField<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage> {
        ::std::mem::replace(&mut self.kis, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncStepAck {
    fn is_initialized(&self) -> bool {
        for v in &self.kis {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.kis)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.kis {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.kis {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageSyncStepAck {
        MoneroKeyImageSyncStepAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage>>(
                    "kis",
                    |m: &MoneroKeyImageSyncStepAck| { &m.kis },
                    |m: &mut MoneroKeyImageSyncStepAck| { &mut m.kis },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroKeyImageSyncStepAck>(
                    "MoneroKeyImageSyncStepAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroKeyImageSyncStepAck {
        static mut instance: ::protobuf::lazy::Lazy<MoneroKeyImageSyncStepAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroKeyImageSyncStepAck,
        };
        unsafe {
            instance.get(MoneroKeyImageSyncStepAck::new)
        }
    }
}

impl ::protobuf::Clear for MoneroKeyImageSyncStepAck {
    fn clear(&mut self) {
        self.kis.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageSyncStepAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncStepAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
    // message fields
    iv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    tag: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    blob: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
    fn default() -> &'a MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
        <MoneroKeyImageSyncStepAck_MoneroExportedKeyImage as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
    pub fn new() -> MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
        ::std::default::Default::default()
    }

    // optional bytes iv = 1;


    pub fn get_iv(&self) -> &[u8] {
        match self.iv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_iv(&mut self) {
        self.iv.clear();
    }

    pub fn has_iv(&self) -> bool {
        self.iv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iv(&mut self, v: ::std::vec::Vec<u8>) {
        self.iv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iv(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.iv.is_none() {
            self.iv.set_default();
        }
        self.iv.as_mut().unwrap()
    }

    // Take field
    pub fn take_iv(&mut self) -> ::std::vec::Vec<u8> {
        self.iv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes tag = 2;


    pub fn get_tag(&self) -> &[u8] {
        match self.tag.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::vec::Vec<u8>) {
        self.tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tag.is_none() {
            self.tag.set_default();
        }
        self.tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::vec::Vec<u8> {
        self.tag.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes blob = 3;


    pub fn get_blob(&self) -> &[u8] {
        match self.blob.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_blob(&mut self) {
        self.blob.clear();
    }

    pub fn has_blob(&self) -> bool {
        self.blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.blob = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.blob.is_none() {
            self.blob.set_default();
        }
        self.blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_blob(&mut self) -> ::std::vec::Vec<u8> {
        self.blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.iv)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.tag)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.blob)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.iv.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.blob.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.iv.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.tag.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.blob.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
        MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "iv",
                    |m: &MoneroKeyImageSyncStepAck_MoneroExportedKeyImage| { &m.iv },
                    |m: &mut MoneroKeyImageSyncStepAck_MoneroExportedKeyImage| { &mut m.iv },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "tag",
                    |m: &MoneroKeyImageSyncStepAck_MoneroExportedKeyImage| { &m.tag },
                    |m: &mut MoneroKeyImageSyncStepAck_MoneroExportedKeyImage| { &mut m.tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blob",
                    |m: &MoneroKeyImageSyncStepAck_MoneroExportedKeyImage| { &m.blob },
                    |m: &mut MoneroKeyImageSyncStepAck_MoneroExportedKeyImage| { &mut m.blob },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage>(
                    "MoneroKeyImageSyncStepAck_MoneroExportedKeyImage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
        static mut instance: ::protobuf::lazy::Lazy<MoneroKeyImageSyncStepAck_MoneroExportedKeyImage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroKeyImageSyncStepAck_MoneroExportedKeyImage,
        };
        unsafe {
            instance.get(MoneroKeyImageSyncStepAck_MoneroExportedKeyImage::new)
        }
    }
}

impl ::protobuf::Clear for MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
    fn clear(&mut self) {
        self.iv.clear();
        self.tag.clear();
        self.blob.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncStepAck_MoneroExportedKeyImage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageSyncFinalRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncFinalRequest {
    fn default() -> &'a MoneroKeyImageSyncFinalRequest {
        <MoneroKeyImageSyncFinalRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncFinalRequest {
    pub fn new() -> MoneroKeyImageSyncFinalRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncFinalRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageSyncFinalRequest {
        MoneroKeyImageSyncFinalRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<MoneroKeyImageSyncFinalRequest>(
                    "MoneroKeyImageSyncFinalRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroKeyImageSyncFinalRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoneroKeyImageSyncFinalRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroKeyImageSyncFinalRequest,
        };
        unsafe {
            instance.get(MoneroKeyImageSyncFinalRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoneroKeyImageSyncFinalRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageSyncFinalRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncFinalRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoneroKeyImageSyncFinalAck {
    // message fields
    enc_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoneroKeyImageSyncFinalAck {
    fn default() -> &'a MoneroKeyImageSyncFinalAck {
        <MoneroKeyImageSyncFinalAck as ::protobuf::Message>::default_instance()
    }
}

impl MoneroKeyImageSyncFinalAck {
    pub fn new() -> MoneroKeyImageSyncFinalAck {
        ::std::default::Default::default()
    }

    // optional bytes enc_key = 1;


    pub fn get_enc_key(&self) -> &[u8] {
        match self.enc_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_enc_key(&mut self) {
        self.enc_key.clear();
    }

    pub fn has_enc_key(&self) -> bool {
        self.enc_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enc_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.enc_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enc_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.enc_key.is_none() {
            self.enc_key.set_default();
        }
        self.enc_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_enc_key(&mut self) -> ::std::vec::Vec<u8> {
        self.enc_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MoneroKeyImageSyncFinalAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.enc_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.enc_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.enc_key.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoneroKeyImageSyncFinalAck {
        MoneroKeyImageSyncFinalAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "enc_key",
                    |m: &MoneroKeyImageSyncFinalAck| { &m.enc_key },
                    |m: &mut MoneroKeyImageSyncFinalAck| { &mut m.enc_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoneroKeyImageSyncFinalAck>(
                    "MoneroKeyImageSyncFinalAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoneroKeyImageSyncFinalAck {
        static mut instance: ::protobuf::lazy::Lazy<MoneroKeyImageSyncFinalAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoneroKeyImageSyncFinalAck,
        };
        unsafe {
            instance.get(MoneroKeyImageSyncFinalAck::new)
        }
    }
}

impl ::protobuf::Clear for MoneroKeyImageSyncFinalAck {
    fn clear(&mut self) {
        self.enc_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoneroKeyImageSyncFinalAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoneroKeyImageSyncFinalAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugMoneroDiagRequest {
    // message fields
    ins: ::std::option::Option<u64>,
    p1: ::std::option::Option<u64>,
    p2: ::std::option::Option<u64>,
    pd: ::std::vec::Vec<u64>,
    data1: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    data2: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugMoneroDiagRequest {
    fn default() -> &'a DebugMoneroDiagRequest {
        <DebugMoneroDiagRequest as ::protobuf::Message>::default_instance()
    }
}

impl DebugMoneroDiagRequest {
    pub fn new() -> DebugMoneroDiagRequest {
        ::std::default::Default::default()
    }

    // optional uint64 ins = 1;


    pub fn get_ins(&self) -> u64 {
        self.ins.unwrap_or(0)
    }
    pub fn clear_ins(&mut self) {
        self.ins = ::std::option::Option::None;
    }

    pub fn has_ins(&self) -> bool {
        self.ins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ins(&mut self, v: u64) {
        self.ins = ::std::option::Option::Some(v);
    }

    // optional uint64 p1 = 2;


    pub fn get_p1(&self) -> u64 {
        self.p1.unwrap_or(0)
    }
    pub fn clear_p1(&mut self) {
        self.p1 = ::std::option::Option::None;
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: u64) {
        self.p1 = ::std::option::Option::Some(v);
    }

    // optional uint64 p2 = 3;


    pub fn get_p2(&self) -> u64 {
        self.p2.unwrap_or(0)
    }
    pub fn clear_p2(&mut self) {
        self.p2 = ::std::option::Option::None;
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: u64) {
        self.p2 = ::std::option::Option::Some(v);
    }

    // repeated uint64 pd = 4;


    pub fn get_pd(&self) -> &[u64] {
        &self.pd
    }
    pub fn clear_pd(&mut self) {
        self.pd.clear();
    }

    // Param is passed by value, moved
    pub fn set_pd(&mut self, v: ::std::vec::Vec<u64>) {
        self.pd = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pd(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.pd
    }

    // Take field
    pub fn take_pd(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.pd, ::std::vec::Vec::new())
    }

    // optional bytes data1 = 5;


    pub fn get_data1(&self) -> &[u8] {
        match self.data1.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data1(&mut self) {
        self.data1.clear();
    }

    pub fn has_data1(&self) -> bool {
        self.data1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data1(&mut self, v: ::std::vec::Vec<u8>) {
        self.data1 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data1(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data1.is_none() {
            self.data1.set_default();
        }
        self.data1.as_mut().unwrap()
    }

    // Take field
    pub fn take_data1(&mut self) -> ::std::vec::Vec<u8> {
        self.data1.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes data2 = 6;


    pub fn get_data2(&self) -> &[u8] {
        match self.data2.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data2(&mut self) {
        self.data2.clear();
    }

    pub fn has_data2(&self) -> bool {
        self.data2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data2(&mut self, v: ::std::vec::Vec<u8>) {
        self.data2 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data2.is_none() {
            self.data2.set_default();
        }
        self.data2.as_mut().unwrap()
    }

    // Take field
    pub fn take_data2(&mut self) -> ::std::vec::Vec<u8> {
        self.data2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DebugMoneroDiagRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ins = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.p1 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.p2 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.pd)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data1)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ins {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.p1 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.p2 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pd {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.data1.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.data2.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ins {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.p1 {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.p2 {
            os.write_uint64(3, v)?;
        }
        for v in &self.pd {
            os.write_uint64(4, *v)?;
        };
        if let Some(ref v) = self.data1.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.data2.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugMoneroDiagRequest {
        DebugMoneroDiagRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ins",
                    |m: &DebugMoneroDiagRequest| { &m.ins },
                    |m: &mut DebugMoneroDiagRequest| { &mut m.ins },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "p1",
                    |m: &DebugMoneroDiagRequest| { &m.p1 },
                    |m: &mut DebugMoneroDiagRequest| { &mut m.p1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "p2",
                    |m: &DebugMoneroDiagRequest| { &m.p2 },
                    |m: &mut DebugMoneroDiagRequest| { &mut m.p2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "pd",
                    |m: &DebugMoneroDiagRequest| { &m.pd },
                    |m: &mut DebugMoneroDiagRequest| { &mut m.pd },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data1",
                    |m: &DebugMoneroDiagRequest| { &m.data1 },
                    |m: &mut DebugMoneroDiagRequest| { &mut m.data1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data2",
                    |m: &DebugMoneroDiagRequest| { &m.data2 },
                    |m: &mut DebugMoneroDiagRequest| { &mut m.data2 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DebugMoneroDiagRequest>(
                    "DebugMoneroDiagRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DebugMoneroDiagRequest {
        static mut instance: ::protobuf::lazy::Lazy<DebugMoneroDiagRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DebugMoneroDiagRequest,
        };
        unsafe {
            instance.get(DebugMoneroDiagRequest::new)
        }
    }
}

impl ::protobuf::Clear for DebugMoneroDiagRequest {
    fn clear(&mut self) {
        self.ins = ::std::option::Option::None;
        self.p1 = ::std::option::Option::None;
        self.p2 = ::std::option::Option::None;
        self.pd.clear();
        self.data1.clear();
        self.data2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugMoneroDiagRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugMoneroDiagRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugMoneroDiagAck {
    // message fields
    ins: ::std::option::Option<u64>,
    p1: ::std::option::Option<u64>,
    p2: ::std::option::Option<u64>,
    pd: ::std::vec::Vec<u64>,
    data1: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    data2: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugMoneroDiagAck {
    fn default() -> &'a DebugMoneroDiagAck {
        <DebugMoneroDiagAck as ::protobuf::Message>::default_instance()
    }
}

impl DebugMoneroDiagAck {
    pub fn new() -> DebugMoneroDiagAck {
        ::std::default::Default::default()
    }

    // optional uint64 ins = 1;


    pub fn get_ins(&self) -> u64 {
        self.ins.unwrap_or(0)
    }
    pub fn clear_ins(&mut self) {
        self.ins = ::std::option::Option::None;
    }

    pub fn has_ins(&self) -> bool {
        self.ins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ins(&mut self, v: u64) {
        self.ins = ::std::option::Option::Some(v);
    }

    // optional uint64 p1 = 2;


    pub fn get_p1(&self) -> u64 {
        self.p1.unwrap_or(0)
    }
    pub fn clear_p1(&mut self) {
        self.p1 = ::std::option::Option::None;
    }

    pub fn has_p1(&self) -> bool {
        self.p1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p1(&mut self, v: u64) {
        self.p1 = ::std::option::Option::Some(v);
    }

    // optional uint64 p2 = 3;


    pub fn get_p2(&self) -> u64 {
        self.p2.unwrap_or(0)
    }
    pub fn clear_p2(&mut self) {
        self.p2 = ::std::option::Option::None;
    }

    pub fn has_p2(&self) -> bool {
        self.p2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2(&mut self, v: u64) {
        self.p2 = ::std::option::Option::Some(v);
    }

    // repeated uint64 pd = 4;


    pub fn get_pd(&self) -> &[u64] {
        &self.pd
    }
    pub fn clear_pd(&mut self) {
        self.pd.clear();
    }

    // Param is passed by value, moved
    pub fn set_pd(&mut self, v: ::std::vec::Vec<u64>) {
        self.pd = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pd(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.pd
    }

    // Take field
    pub fn take_pd(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.pd, ::std::vec::Vec::new())
    }

    // optional bytes data1 = 5;


    pub fn get_data1(&self) -> &[u8] {
        match self.data1.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data1(&mut self) {
        self.data1.clear();
    }

    pub fn has_data1(&self) -> bool {
        self.data1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data1(&mut self, v: ::std::vec::Vec<u8>) {
        self.data1 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data1(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data1.is_none() {
            self.data1.set_default();
        }
        self.data1.as_mut().unwrap()
    }

    // Take field
    pub fn take_data1(&mut self) -> ::std::vec::Vec<u8> {
        self.data1.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes data2 = 6;


    pub fn get_data2(&self) -> &[u8] {
        match self.data2.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data2(&mut self) {
        self.data2.clear();
    }

    pub fn has_data2(&self) -> bool {
        self.data2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data2(&mut self, v: ::std::vec::Vec<u8>) {
        self.data2 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data2.is_none() {
            self.data2.set_default();
        }
        self.data2.as_mut().unwrap()
    }

    // Take field
    pub fn take_data2(&mut self) -> ::std::vec::Vec<u8> {
        self.data2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DebugMoneroDiagAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ins = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.p1 = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.p2 = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.pd)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data1)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data2)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ins {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.p1 {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.p2 {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.pd {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.data1.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(ref v) = self.data2.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ins {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.p1 {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.p2 {
            os.write_uint64(3, v)?;
        }
        for v in &self.pd {
            os.write_uint64(4, *v)?;
        };
        if let Some(ref v) = self.data1.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(ref v) = self.data2.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugMoneroDiagAck {
        DebugMoneroDiagAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ins",
                    |m: &DebugMoneroDiagAck| { &m.ins },
                    |m: &mut DebugMoneroDiagAck| { &mut m.ins },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "p1",
                    |m: &DebugMoneroDiagAck| { &m.p1 },
                    |m: &mut DebugMoneroDiagAck| { &mut m.p1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "p2",
                    |m: &DebugMoneroDiagAck| { &m.p2 },
                    |m: &mut DebugMoneroDiagAck| { &mut m.p2 },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "pd",
                    |m: &DebugMoneroDiagAck| { &m.pd },
                    |m: &mut DebugMoneroDiagAck| { &mut m.pd },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data1",
                    |m: &DebugMoneroDiagAck| { &m.data1 },
                    |m: &mut DebugMoneroDiagAck| { &mut m.data1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data2",
                    |m: &DebugMoneroDiagAck| { &m.data2 },
                    |m: &mut DebugMoneroDiagAck| { &mut m.data2 },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DebugMoneroDiagAck>(
                    "DebugMoneroDiagAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DebugMoneroDiagAck {
        static mut instance: ::protobuf::lazy::Lazy<DebugMoneroDiagAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DebugMoneroDiagAck,
        };
        unsafe {
            instance.get(DebugMoneroDiagAck::new)
        }
    }
}

impl ::protobuf::Clear for DebugMoneroDiagAck {
    fn clear(&mut self) {
        self.ins = ::std::option::Option::None;
        self.p1 = ::std::option::Option::None;
        self.p2 = ::std::option::Option::None;
        self.pd.clear();
        self.data1.clear();
        self.data2.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugMoneroDiagAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugMoneroDiagAck {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15messages-monero.proto\x12\x19hw.trezor.messages.monero\"\x8c\x06\n\
    \x1cMoneroTransactionSourceEntry\x12c\n\x07outputs\x18\x01\x20\x03(\x0b2\
    I.hw.trezor.messages.monero.MoneroTransactionSourceEntry.MoneroOutputEnt\
    ryR\x07outputs\x12\x1f\n\x0breal_output\x18\x02\x20\x01(\x04R\nrealOutpu\
    t\x12%\n\x0freal_out_tx_key\x18\x03\x20\x01(\x0cR\x0crealOutTxKey\x12<\n\
    \x1breal_out_additional_tx_keys\x18\x04\x20\x03(\x0cR\x17realOutAddition\
    alTxKeys\x124\n\x17real_output_in_tx_index\x18\x05\x20\x01(\x04R\x13real\
    OutputInTxIndex\x12\x16\n\x06amount\x18\x06\x20\x01(\x04R\x06amount\x12\
    \x10\n\x03rct\x18\x07\x20\x01(\x08R\x03rct\x12\x12\n\x04mask\x18\x08\x20\
    \x01(\x0cR\x04mask\x12r\n\x0emultisig_kLRki\x18\t\x20\x01(\x0b2K.hw.trez\
    or.messages.monero.MoneroTransactionSourceEntry.MoneroMultisigKLRkiR\rmu\
    ltisigKLRki\x1a\xc7\x01\n\x11MoneroOutputEntry\x12\x10\n\x03idx\x18\x01\
    \x20\x01(\x04R\x03idx\x12h\n\x03key\x18\x02\x20\x01(\x0b2V.hw.trezor.mes\
    sages.monero.MoneroTransactionSourceEntry.MoneroOutputEntry.MoneroRctKey\
    R\x03key\x1a6\n\x0cMoneroRctKey\x12\x12\n\x04dest\x18\x01\x20\x01(\x0cR\
    \x04dest\x12\x12\n\x04mask\x18\x02\x20\x01(\x0cR\x04mask\x1aO\n\x13Moner\
    oMultisigKLRki\x12\x0c\n\x01K\x18\x01\x20\x01(\x0cR\x01K\x12\x0c\n\x01L\
    \x18\x02\x20\x01(\x0cR\x01L\x12\x0c\n\x01R\x18\x03\x20\x01(\x0cR\x01R\
    \x12\x0e\n\x02ki\x18\x04\x20\x01(\x0cR\x02ki\"\xbd\x02\n!MoneroTransacti\
    onDestinationEntry\x12\x16\n\x06amount\x18\x01\x20\x01(\x04R\x06amount\
    \x12k\n\x04addr\x18\x02\x20\x01(\x0b2W.hw.trezor.messages.monero.MoneroT\
    ransactionDestinationEntry.MoneroAccountPublicAddressR\x04addr\x12#\n\ri\
    s_subaddress\x18\x03\x20\x01(\x08R\x0cisSubaddress\x1an\n\x1aMoneroAccou\
    ntPublicAddress\x12(\n\x10spend_public_key\x18\x01\x20\x01(\x0cR\x0espen\
    dPublicKey\x12&\n\x0fview_public_key\x18\x02\x20\x01(\x0cR\rviewPublicKe\
    y\"\x8e\x03\n\x19MoneroTransactionRsigData\x12\x18\n\x07version\x18\x01\
    \x20\x01(\rR\x07version\x12\x1b\n\trsig_type\x18\x02\x20\x01(\rR\x08rsig\
    Type\x12!\n\x0coffload_type\x18\x03\x20\x01(\rR\x0boffloadType\x12\x1a\n\
    \x08grouping\x18\x04\x20\x03(\x04R\x08grouping\x12\x12\n\x04step\x18\x05\
    \x20\x01(\rR\x04step\x12\x1c\n\toperation\x18\x06\x20\x01(\x04R\toperati\
    on\x12\x12\n\x04seed\x18\x07\x20\x01(\x0cR\x04seed\x12\x12\n\x04mask\x18\
    \x08\x20\x01(\x0cR\x04mask\x12\x16\n\x06amount\x18\t\x20\x01(\x0cR\x06am\
    ount\x12\x12\n\x04rsig\x18\n\x20\x01(\x0cR\x04rsig\x12\x1d\n\nrsig_parts\
    \x18\x0b\x20\x03(\x0cR\trsigParts\x12V\n\x07outputs\x18\x0c\x20\x03(\x0b\
    2<.hw.trezor.messages.monero.MoneroTransactionDestinationEntryR\x07outpu\
    ts\"\xa5\x01\n\x10MoneroGetAddress\x12\x1b\n\taddress_n\x18\x01\x20\x03(\
    \rR\x08addressN\x12!\n\x0cshow_display\x18\x02\x20\x01(\x08R\x0bshowDisp\
    lay\x12!\n\x0cnetwork_type\x18\x03\x20\x01(\rR\x0bnetworkType\x12\x18\n\
    \x07account\x18\x04\x20\x01(\rR\x07account\x12\x14\n\x05minor\x18\x05\
    \x20\x01(\rR\x05minor\")\n\rMoneroAddress\x12\x18\n\x07address\x18\x01\
    \x20\x01(\x0cR\x07address\"S\n\x11MoneroGetWatchKey\x12\x1b\n\taddress_n\
    \x18\x01\x20\x03(\rR\x08addressN\x12!\n\x0cnetwork_type\x18\x02\x20\x01(\
    \rR\x0bnetworkType\"G\n\x0eMoneroWatchKey\x12\x1b\n\twatch_key\x18\x01\
    \x20\x01(\x0cR\x08watchKey\x12\x18\n\x07address\x18\x02\x20\x01(\x0cR\
    \x07address\"\x81\x07\n\x1cMoneroTransactionInitRequest\x12\x18\n\x07ver\
    sion\x18\x01\x20\x01(\rR\x07version\x12\x1b\n\taddress_n\x18\x02\x20\x03\
    (\rR\x08addressN\x12!\n\x0cnetwork_type\x18\x03\x20\x01(\rR\x0bnetworkTy\
    pe\x12h\n\x08tsx_data\x18\x04\x20\x01(\x0b2M.hw.trezor.messages.monero.M\
    oneroTransactionInitRequest.MoneroTransactionDataR\x07tsxData\x1a\x9c\
    \x05\n\x15MoneroTransactionData\x12\x18\n\x07version\x18\x01\x20\x01(\rR\
    \x07version\x12\x1d\n\npayment_id\x18\x02\x20\x01(\x0cR\tpaymentId\x12\
    \x1f\n\x0bunlock_time\x18\x03\x20\x01(\x04R\nunlockTime\x12V\n\x07output\
    s\x18\x04\x20\x03(\x0b2<.hw.trezor.messages.monero.MoneroTransactionDest\
    inationEntryR\x07outputs\x12[\n\nchange_dts\x18\x05\x20\x01(\x0b2<.hw.tr\
    ezor.messages.monero.MoneroTransactionDestinationEntryR\tchangeDts\x12\
    \x1d\n\nnum_inputs\x18\x06\x20\x01(\rR\tnumInputs\x12\x14\n\x05mixin\x18\
    \x07\x20\x01(\rR\x05mixin\x12\x10\n\x03fee\x18\x08\x20\x01(\x04R\x03fee\
    \x12\x18\n\x07account\x18\t\x20\x01(\rR\x07account\x12#\n\rminor_indices\
    \x18\n\x20\x03(\rR\x0cminorIndices\x12\x1f\n\x0bis_multisig\x18\x0b\x20\
    \x01(\x08R\nisMultisig\x12+\n\x12exp_tx_prefix_hash\x18\x0c\x20\x01(\x0c\
    R\x0fexpTxPrefixHash\x12\x1e\n\x0buse_tx_keys\x18\r\x20\x03(\x0cR\tuseTx\
    Keys\x12Q\n\trsig_data\x18\x0e\x20\x01(\x0b24.hw.trezor.messages.monero.\
    MoneroTransactionRsigDataR\x08rsigData\x12-\n\x12integrated_indices\x18\
    \x0f\x20\x03(\rR\x11integratedIndices\"\x96\x02\n\x18MoneroTransactionIn\
    itAck\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12\x16\n\x06s\
    tatus\x18\x02\x20\x01(\rR\x06status\x12\x1b\n\tin_memory\x18\x03\x20\x01\
    (\x08R\x08inMemory\x12\x14\n\x05hmacs\x18\x04\x20\x03(\x0cR\x05hmacs\x12\
    \x1f\n\x0bmany_inputs\x18\x05\x20\x01(\x08R\nmanyInputs\x12!\n\x0cmany_o\
    utputs\x18\x06\x20\x01(\x08R\x0bmanyOutputs\x12Q\n\trsig_data\x18\x07\
    \x20\x01(\x0b24.hw.trezor.messages.monero.MoneroTransactionRsigDataR\x08\
    rsigData\"\x90\x01\n\x20MoneroTransactionSetInputRequest\x12\x18\n\x07ve\
    rsion\x18\x01\x20\x01(\rR\x07version\x12R\n\x08src_entr\x18\x02\x20\x01(\
    \x0b27.hw.trezor.messages.monero.MoneroTransactionSourceEntryR\x07srcEnt\
    r\"\xd0\x01\n\x1cMoneroTransactionSetInputAck\x12\x12\n\x04vini\x18\x01\
    \x20\x01(\x0cR\x04vini\x12\x1b\n\tvini_hmac\x18\x02\x20\x01(\x0cR\x08vin\
    iHmac\x12\x1d\n\npseudo_out\x18\x03\x20\x01(\x0cR\tpseudoOut\x12&\n\x0fp\
    seudo_out_hmac\x18\x04\x20\x01(\x0cR\rpseudoOutHmac\x12\x1b\n\talpha_enc\
    \x18\x05\x20\x01(\x0cR\x08alphaEnc\x12\x1b\n\tspend_enc\x18\x06\x20\x01(\
    \x0cR\x08spendEnc\"?\n)MoneroTransactionInputsPermutationRequest\x12\x12\
    \n\x04perm\x18\x01\x20\x03(\rR\x04perm\"'\n%MoneroTransactionInputsPermu\
    tationAck\"\xef\x01\n!MoneroTransactionInputViniRequest\x12R\n\x08src_en\
    tr\x18\x01\x20\x01(\x0b27.hw.trezor.messages.monero.MoneroTransactionSou\
    rceEntryR\x07srcEntr\x12\x12\n\x04vini\x18\x02\x20\x01(\x0cR\x04vini\x12\
    \x1b\n\tvini_hmac\x18\x03\x20\x01(\x0cR\x08viniHmac\x12\x1d\n\npseudo_ou\
    t\x18\x04\x20\x01(\x0cR\tpseudoOut\x12&\n\x0fpseudo_out_hmac\x18\x05\x20\
    \x01(\x0cR\rpseudoOutHmac\"\x1f\n\x1dMoneroTransactionInputViniAck\"y\n$\
    MoneroTransactionAllInputsSetRequest\x12Q\n\trsig_data\x18\x01\x20\x01(\
    \x0b24.hw.trezor.messages.monero.MoneroTransactionRsigDataR\x08rsigData\
    \"u\n\x20MoneroTransactionAllInputsSetAck\x12Q\n\trsig_data\x18\x01\x20\
    \x01(\x0b24.hw.trezor.messages.monero.MoneroTransactionRsigDataR\x08rsig\
    Data\"\xf3\x01\n!MoneroTransactionSetOutputRequest\x12W\n\x08dst_entr\
    \x18\x01\x20\x01(\x0b2<.hw.trezor.messages.monero.MoneroTransactionDesti\
    nationEntryR\x07dstEntr\x12\"\n\rdst_entr_hmac\x18\x02\x20\x01(\x0cR\x0b\
    dstEntrHmac\x12Q\n\trsig_data\x18\x03\x20\x01(\x0b24.hw.trezor.messages.\
    monero.MoneroTransactionRsigDataR\x08rsigData\"\xdc\x01\n\x1dMoneroTrans\
    actionSetOutputAck\x12\x15\n\x06tx_out\x18\x01\x20\x01(\x0cR\x05txOut\
    \x12\x1d\n\nvouti_hmac\x18\x02\x20\x01(\x0cR\tvoutiHmac\x12Q\n\trsig_dat\
    a\x18\x03\x20\x01(\x0b24.hw.trezor.messages.monero.MoneroTransactionRsig\
    DataR\x08rsigData\x12\x15\n\x06out_pk\x18\x04\x20\x01(\x0cR\x05outPk\x12\
    \x1b\n\tecdh_info\x18\x05\x20\x01(\x0cR\x08ecdhInfo\"v\n!MoneroTransacti\
    onAllOutSetRequest\x12Q\n\trsig_data\x18\x01\x20\x01(\x0b24.hw.trezor.me\
    ssages.monero.MoneroTransactionRsigDataR\x08rsigData\"\xe7\x02\n\x1dMone\
    roTransactionAllOutSetAck\x12\x14\n\x05extra\x18\x01\x20\x01(\x0cR\x05ex\
    tra\x12$\n\x0etx_prefix_hash\x18\x02\x20\x01(\x0cR\x0ctxPrefixHash\x12Q\
    \n\trsig_data\x18\x03\x20\x01(\x0b24.hw.trezor.messages.monero.MoneroTra\
    nsactionRsigDataR\x08rsigData\x12X\n\x02rv\x18\x04\x20\x01(\x0b2H.hw.tre\
    zor.messages.monero.MoneroTransactionAllOutSetAck.MoneroRingCtSigR\x02rv\
    \x1a]\n\x0fMoneroRingCtSig\x12\x17\n\x07txn_fee\x18\x01\x20\x01(\x04R\
    \x06txnFee\x12\x18\n\x07message\x18\x02\x20\x01(\x0cR\x07message\x12\x17\
    \n\x07rv_type\x18\x03\x20\x01(\rR\x06rvType\"#\n!MoneroTransactionMlsagD\
    oneRequest\"K\n\x1dMoneroTransactionMlsagDoneAck\x12*\n\x11full_message_\
    hash\x18\x01\x20\x01(\x0cR\x0ffullMessageHash\"\xa9\x02\n!MoneroTransact\
    ionSignInputRequest\x12R\n\x08src_entr\x18\x01\x20\x01(\x0b27.hw.trezor.\
    messages.monero.MoneroTransactionSourceEntryR\x07srcEntr\x12\x12\n\x04vi\
    ni\x18\x02\x20\x01(\x0cR\x04vini\x12\x1b\n\tvini_hmac\x18\x03\x20\x01(\
    \x0cR\x08viniHmac\x12\x1d\n\npseudo_out\x18\x04\x20\x01(\x0cR\tpseudoOut\
    \x12&\n\x0fpseudo_out_hmac\x18\x05\x20\x01(\x0cR\rpseudoOutHmac\x12\x1b\
    \n\talpha_enc\x18\x06\x20\x01(\x0cR\x08alphaEnc\x12\x1b\n\tspend_enc\x18\
    \x07\x20\x01(\x0cR\x08spendEnc\"Q\n\x1dMoneroTransactionSignInputAck\x12\
    \x1c\n\tsignature\x18\x01\x20\x01(\x0cR\tsignature\x12\x12\n\x04cout\x18\
    \x02\x20\x01(\x0cR\x04cout\"\x1f\n\x1dMoneroTransactionFinalRequest\"\
    \x87\x01\n\x19MoneroTransactionFinalAck\x12\x19\n\x08cout_key\x18\x01\
    \x20\x01(\x0cR\x07coutKey\x12\x12\n\x04salt\x18\x02\x20\x01(\x0cR\x04sal\
    t\x12\x1b\n\trand_mult\x18\x03\x20\x01(\x0cR\x08randMult\x12\x1e\n\x0btx\
    _enc_keys\x18\x04\x20\x01(\x0cR\ttxEncKeys\"\xd1\x02\n\x1fMoneroKeyImage\
    ExportInitRequest\x12\x10\n\x03num\x18\x01\x20\x01(\x04R\x03num\x12\x12\
    \n\x04hash\x18\x02\x20\x01(\x0cR\x04hash\x12\x1b\n\taddress_n\x18\x03\
    \x20\x03(\rR\x08addressN\x12!\n\x0cnetwork_type\x18\x04\x20\x01(\rR\x0bn\
    etworkType\x12j\n\x04subs\x18\x05\x20\x03(\x0b2V.hw.trezor.messages.mone\
    ro.MoneroKeyImageExportInitRequest.MoneroSubAddressIndicesListR\x04subs\
    \x1a\\\n\x1bMoneroSubAddressIndicesList\x12\x18\n\x07account\x18\x01\x20\
    \x01(\rR\x07account\x12#\n\rminor_indices\x18\x02\x20\x03(\rR\x0cminorIn\
    dices\"\x1d\n\x1bMoneroKeyImageExportInitAck\"\xbd\x02\n\x1dMoneroKeyIma\
    geSyncStepRequest\x12b\n\x04tdis\x18\x01\x20\x03(\x0b2N.hw.trezor.messag\
    es.monero.MoneroKeyImageSyncStepRequest.MoneroTransferDetailsR\x04tdis\
    \x1a\xb7\x01\n\x15MoneroTransferDetails\x12\x17\n\x07out_key\x18\x01\x20\
    \x01(\x0cR\x06outKey\x12\x1c\n\ntx_pub_key\x18\x02\x20\x01(\x0cR\x08txPu\
    bKey\x123\n\x16additional_tx_pub_keys\x18\x03\x20\x03(\x0cR\x13additiona\
    lTxPubKeys\x122\n\x15internal_output_index\x18\x04\x20\x01(\x04R\x13inte\
    rnalOutputIndex\"\xca\x01\n\x19MoneroKeyImageSyncStepAck\x12]\n\x03kis\
    \x18\x01\x20\x03(\x0b2K.hw.trezor.messages.monero.MoneroKeyImageSyncStep\
    Ack.MoneroExportedKeyImageR\x03kis\x1aN\n\x16MoneroExportedKeyImage\x12\
    \x0e\n\x02iv\x18\x01\x20\x01(\x0cR\x02iv\x12\x10\n\x03tag\x18\x02\x20\
    \x01(\x0cR\x03tag\x12\x12\n\x04blob\x18\x03\x20\x01(\x0cR\x04blob\"\x20\
    \n\x1eMoneroKeyImageSyncFinalRequest\"5\n\x1aMoneroKeyImageSyncFinalAck\
    \x12\x17\n\x07enc_key\x18\x01\x20\x01(\x0cR\x06encKey\"\x86\x01\n\x16Deb\
    ugMoneroDiagRequest\x12\x10\n\x03ins\x18\x01\x20\x01(\x04R\x03ins\x12\
    \x0e\n\x02p1\x18\x02\x20\x01(\x04R\x02p1\x12\x0e\n\x02p2\x18\x03\x20\x01\
    (\x04R\x02p2\x12\x0e\n\x02pd\x18\x04\x20\x03(\x04R\x02pd\x12\x14\n\x05da\
    ta1\x18\x05\x20\x01(\x0cR\x05data1\x12\x14\n\x05data2\x18\x06\x20\x01(\
    \x0cR\x05data2\"\x82\x01\n\x12DebugMoneroDiagAck\x12\x10\n\x03ins\x18\
    \x01\x20\x01(\x04R\x03ins\x12\x0e\n\x02p1\x18\x02\x20\x01(\x04R\x02p1\
    \x12\x0e\n\x02p2\x18\x03\x20\x01(\x04R\x02p2\x12\x0e\n\x02pd\x18\x04\x20\
    \x03(\x04R\x02pd\x12\x14\n\x05data1\x18\x05\x20\x01(\x0cR\x05data1\x12\
    \x14\n\x05data2\x18\x06\x20\x01(\x0cR\x05data2B:\n#com.satoshilabs.trezo\
    r.lib.protobufB\x13TrezorMessageMoneroJ\xa8\x87\x01\n\x07\x12\x05\0\0\
    \xbb\x03\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\
    \x08!\n\x08\n\x01\x08\x12\x03\x04\0<\n.\n\x02\x08\x01\x12\x03\x04\0<\x1a\
    #\x20Sugar\x20for\x20easier\x20handling\x20in\x20Java\n\n\x08\n\x01\x08\
    \x12\x03\x05\04\n\t\n\x02\x08\x08\x12\x03\x05\04\nT\n\x02\x04\0\x12\x04\
    \x0b\0#\x01\x1aH*\n\x20Structure\x20representing\x20Monero\x20transactio\
    n\x20source\x20entry,\x20UTXO\n\x20@embed\n\n\n\n\x03\x04\0\x01\x12\x03\
    \x0b\x08$\n\x0b\n\x04\x04\0\x02\0\x12\x03\x0c\x04+\n\x0c\n\x05\x04\0\x02\
    \0\x04\x12\x03\x0c\x04\x0c\n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x0c\r\x1e\
    \n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x0c\x1f&\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03\x0c)*\n\x0b\n\x04\x04\0\x02\x01\x12\x03\r\x04$\n\x0c\n\x05\
    \x04\0\x02\x01\x04\x12\x03\r\x04\x0c\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x03\r\r\x13\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\r\x14\x1f\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03\r\"#\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x0e\
    \x04'\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\x0e\x04\x0c\n\x0c\n\x05\x04\
    \0\x02\x02\x05\x12\x03\x0e\r\x12\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\
    \x0e\x13\"\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x0e%&\n\x0b\n\x04\x04\0\
    \x02\x03\x12\x03\x0f\x043\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\x0f\x04\
    \x0c\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x0f\r\x12\n\x0c\n\x05\x04\0\
    \x02\x03\x01\x12\x03\x0f\x13.\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x0f1\
    2\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x10\x040\n\x0c\n\x05\x04\0\x02\x04\
    \x04\x12\x03\x10\x04\x0c\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\x10\r\x13\
    \n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x10\x14+\n\x0c\n\x05\x04\0\x02\
    \x04\x03\x12\x03\x10./\n\x0b\n\x04\x04\0\x02\x05\x12\x03\x11\x04\x1f\n\
    \x0c\n\x05\x04\0\x02\x05\x04\x12\x03\x11\x04\x0c\n\x0c\n\x05\x04\0\x02\
    \x05\x05\x12\x03\x11\r\x13\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\x11\x14\
    \x1a\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x11\x1d\x1e\n\x0b\n\x04\x04\0\
    \x02\x06\x12\x03\x12\x04\x1a\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03\x12\
    \x04\x0c\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x12\r\x11\n\x0c\n\x05\x04\
    \0\x02\x06\x01\x12\x03\x12\x12\x15\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\
    \x12\x18\x19\n\x0b\n\x04\x04\0\x02\x07\x12\x03\x13\x04\x1c\n\x0c\n\x05\
    \x04\0\x02\x07\x04\x12\x03\x13\x04\x0c\n\x0c\n\x05\x04\0\x02\x07\x05\x12\
    \x03\x13\r\x12\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03\x13\x13\x17\n\x0c\n\
    \x05\x04\0\x02\x07\x03\x12\x03\x13\x1a\x1b\n\x0b\n\x04\x04\0\x02\x08\x12\
    \x03\x14\x044\n\x0c\n\x05\x04\0\x02\x08\x04\x12\x03\x14\x04\x0c\n\x0c\n\
    \x05\x04\0\x02\x08\x06\x12\x03\x14\r\x20\n\x0c\n\x05\x04\0\x02\x08\x01\
    \x12\x03\x14!/\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03\x1423\n\x0c\n\x04\
    \x04\0\x03\0\x12\x04\x15\x04\x1c\x05\n\x0c\n\x05\x04\0\x03\0\x01\x12\x03\
    \x15\x0c\x1d\n\r\n\x06\x04\0\x03\0\x02\0\x12\x03\x16\x08\x20\n\x0e\n\x07\
    \x04\0\x03\0\x02\0\x04\x12\x03\x16\x08\x10\n\x0e\n\x07\x04\0\x03\0\x02\0\
    \x05\x12\x03\x16\x11\x17\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x03\x16\
    \x18\x1b\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03\x16\x1e\x1f\n\r\n\x06\
    \x04\0\x03\0\x02\x01\x12\x03\x17\x08&\n\x0e\n\x07\x04\0\x03\0\x02\x01\
    \x04\x12\x03\x17\x08\x10\n\x0e\n\x07\x04\0\x03\0\x02\x01\x06\x12\x03\x17\
    \x11\x1d\n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x03\x17\x1e!\n\x0e\n\
    \x07\x04\0\x03\0\x02\x01\x03\x12\x03\x17$%\n\x0e\n\x06\x04\0\x03\0\x03\0\
    \x12\x04\x18\x08\x1b\t\n\x0e\n\x07\x04\0\x03\0\x03\0\x01\x12\x03\x18\x10\
    \x1c\n\x0f\n\x08\x04\0\x03\0\x03\0\x02\0\x12\x03\x19\x0c$\n\x10\n\t\x04\
    \0\x03\0\x03\0\x02\0\x04\x12\x03\x19\x0c\x14\n\x10\n\t\x04\0\x03\0\x03\0\
    \x02\0\x05\x12\x03\x19\x15\x1a\n\x10\n\t\x04\0\x03\0\x03\0\x02\0\x01\x12\
    \x03\x19\x1b\x1f\n\x10\n\t\x04\0\x03\0\x03\0\x02\0\x03\x12\x03\x19\"#\n\
    \x0f\n\x08\x04\0\x03\0\x03\0\x02\x01\x12\x03\x1a\x0c$\n\x10\n\t\x04\0\
    \x03\0\x03\0\x02\x01\x04\x12\x03\x1a\x0c\x14\n\x10\n\t\x04\0\x03\0\x03\0\
    \x02\x01\x05\x12\x03\x1a\x15\x1a\n\x10\n\t\x04\0\x03\0\x03\0\x02\x01\x01\
    \x12\x03\x1a\x1b\x1f\n\x10\n\t\x04\0\x03\0\x03\0\x02\x01\x03\x12\x03\x1a\
    \"#\n\x0c\n\x04\x04\0\x03\x01\x12\x04\x1d\x04\"\x05\n\x0c\n\x05\x04\0\
    \x03\x01\x01\x12\x03\x1d\x0c\x1f\n\r\n\x06\x04\0\x03\x01\x02\0\x12\x03\
    \x1e\x08\x1d\n\x0e\n\x07\x04\0\x03\x01\x02\0\x04\x12\x03\x1e\x08\x10\n\
    \x0e\n\x07\x04\0\x03\x01\x02\0\x05\x12\x03\x1e\x11\x16\n\x0e\n\x07\x04\0\
    \x03\x01\x02\0\x01\x12\x03\x1e\x17\x18\n\x0e\n\x07\x04\0\x03\x01\x02\0\
    \x03\x12\x03\x1e\x1b\x1c\n\r\n\x06\x04\0\x03\x01\x02\x01\x12\x03\x1f\x08\
    \x1d\n\x0e\n\x07\x04\0\x03\x01\x02\x01\x04\x12\x03\x1f\x08\x10\n\x0e\n\
    \x07\x04\0\x03\x01\x02\x01\x05\x12\x03\x1f\x11\x16\n\x0e\n\x07\x04\0\x03\
    \x01\x02\x01\x01\x12\x03\x1f\x17\x18\n\x0e\n\x07\x04\0\x03\x01\x02\x01\
    \x03\x12\x03\x1f\x1b\x1c\n\r\n\x06\x04\0\x03\x01\x02\x02\x12\x03\x20\x08\
    \x1d\n\x0e\n\x07\x04\0\x03\x01\x02\x02\x04\x12\x03\x20\x08\x10\n\x0e\n\
    \x07\x04\0\x03\x01\x02\x02\x05\x12\x03\x20\x11\x16\n\x0e\n\x07\x04\0\x03\
    \x01\x02\x02\x01\x12\x03\x20\x17\x18\n\x0e\n\x07\x04\0\x03\x01\x02\x02\
    \x03\x12\x03\x20\x1b\x1c\n\r\n\x06\x04\0\x03\x01\x02\x03\x12\x03!\x08\
    \x1e\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x04\x12\x03!\x08\x10\n\x0e\n\x07\
    \x04\0\x03\x01\x02\x03\x05\x12\x03!\x11\x16\n\x0e\n\x07\x04\0\x03\x01\
    \x02\x03\x01\x12\x03!\x17\x19\n\x0e\n\x07\x04\0\x03\x01\x02\x03\x03\x12\
    \x03!\x1c\x1d\nS\n\x02\x04\x01\x12\x04)\04\x01\x1aG*\n\x20Structure\x20r\
    epresenting\x20Monero\x20transaction\x20destination\x20entry\n\x20@embed\
    \n\n\n\n\x03\x04\x01\x01\x12\x03)\x08)\n\x0b\n\x04\x04\x01\x02\0\x12\x03\
    *\x04\x1f\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03*\x04\x0c\n\x0c\n\x05\x04\
    \x01\x02\0\x05\x12\x03*\r\x13\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03*\x14\
    \x1a\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03*\x1d\x1e\n\x0b\n\x04\x04\x01\
    \x02\x01\x12\x03+\x041\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03+\x04\x0c\
    \n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03+\r'\n\x0c\n\x05\x04\x01\x02\x01\
    \x01\x12\x03+(,\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03+/0\n\x0b\n\x04\
    \x04\x01\x02\x02\x12\x03,\x04$\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03,\
    \x04\x0c\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03,\r\x11\n\x0c\n\x05\x04\
    \x01\x02\x02\x01\x12\x03,\x12\x1f\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\
    \x03,\"#\n>\n\x04\x04\x01\x03\0\x12\x040\x043\x05\x1a0*\n\x20Structure\
    \x20representing\x20Monero\x20public\x20address\n\n\x0c\n\x05\x04\x01\
    \x03\0\x01\x12\x030\x0c&\n\r\n\x06\x04\x01\x03\0\x02\0\x12\x031\x08,\n\
    \x0e\n\x07\x04\x01\x03\0\x02\0\x04\x12\x031\x08\x10\n\x0e\n\x07\x04\x01\
    \x03\0\x02\0\x05\x12\x031\x11\x16\n\x0e\n\x07\x04\x01\x03\0\x02\0\x01\
    \x12\x031\x17'\n\x0e\n\x07\x04\x01\x03\0\x02\0\x03\x12\x031*+\n\r\n\x06\
    \x04\x01\x03\0\x02\x01\x12\x032\x08+\n\x0e\n\x07\x04\x01\x03\0\x02\x01\
    \x04\x12\x032\x08\x10\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x05\x12\x032\x11\
    \x16\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x01\x12\x032\x17&\n\x0e\n\x07\x04\
    \x01\x03\0\x02\x01\x03\x12\x032)*\n,\n\x02\x04\x02\x12\x049\0G\x01\x1a\
    \x20*\n\x20Range\x20sig\x20parameters\x20/\x20data.\n\n\n\n\x03\x04\x02\
    \x01\x12\x039\x08!\n\x0b\n\x04\x04\x02\x02\0\x12\x03:\x04\x20\n\x0c\n\
    \x05\x04\x02\x02\0\x04\x12\x03:\x04\x0c\n\x0c\n\x05\x04\x02\x02\0\x05\
    \x12\x03:\r\x13\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03:\x14\x1b\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x03:\x1e\x1f\n\x0b\n\x04\x04\x02\x02\x01\x12\
    \x03;\x04\"\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03;\x04\x0c\n\x0c\n\x05\
    \x04\x02\x02\x01\x05\x12\x03;\r\x13\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\
    \x03;\x14\x1d\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03;\x20!\n\x0b\n\x04\
    \x04\x02\x02\x02\x12\x03<\x04%\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03<\
    \x04\x0c\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03<\r\x13\n\x0c\n\x05\x04\
    \x02\x02\x02\x01\x12\x03<\x14\x20\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\
    \x03<#$\n(\n\x04\x04\x02\x02\x03\x12\x03=\x04!\"\x1b\x20aggregation\x20s\
    cheme\x20for\x20BP\n\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03=\x04\x0c\n\
    \x0c\n\x05\x04\x02\x02\x03\x05\x12\x03=\r\x13\n\x0c\n\x05\x04\x02\x02\
    \x03\x01\x12\x03=\x14\x1c\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03=\x1f\
    \x20\n\x0b\n\x04\x04\x02\x02\x04\x12\x03?\x04\x1d\n\x0c\n\x05\x04\x02\
    \x02\x04\x04\x12\x03?\x04\x0c\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03?\r\
    \x13\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03?\x14\x18\n\x0c\n\x05\x04\
    \x02\x02\x04\x03\x12\x03?\x1b\x1c\n\x0b\n\x04\x04\x02\x02\x05\x12\x03@\
    \x04\"\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x03@\x04\x0c\n\x0c\n\x05\x04\
    \x02\x02\x05\x05\x12\x03@\r\x13\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03@\
    \x14\x1d\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03@\x20!\n\x20\n\x04\x04\
    \x02\x02\x06\x12\x03A\x04\x1c\"\x13\x20determ.\x20mask\x20seed\n\n\x0c\n\
    \x05\x04\x02\x02\x06\x04\x12\x03A\x04\x0c\n\x0c\n\x05\x04\x02\x02\x06\
    \x05\x12\x03A\r\x12\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03A\x13\x17\n\
    \x0c\n\x05\x04\x02\x02\x06\x03\x12\x03A\x1a\x1b\n\x1a\n\x04\x04\x02\x02\
    \x07\x12\x03B\x04\x1c\"\r\x20mask\x20vector\n\n\x0c\n\x05\x04\x02\x02\
    \x07\x04\x12\x03B\x04\x0c\n\x0c\n\x05\x04\x02\x02\x07\x05\x12\x03B\r\x12\
    \n\x0c\n\x05\x04\x02\x02\x07\x01\x12\x03B\x13\x17\n\x0c\n\x05\x04\x02\
    \x02\x07\x03\x12\x03B\x1a\x1b\n\x1c\n\x04\x04\x02\x02\x08\x12\x03C\x04\
    \x1e\"\x0f\x20amount\x20vector\n\n\x0c\n\x05\x04\x02\x02\x08\x04\x12\x03\
    C\x04\x0c\n\x0c\n\x05\x04\x02\x02\x08\x05\x12\x03C\r\x12\n\x0c\n\x05\x04\
    \x02\x02\x08\x01\x12\x03C\x13\x19\n\x0c\n\x05\x04\x02\x02\x08\x03\x12\
    \x03C\x1c\x1d\n)\n\x04\x04\x02\x02\t\x12\x03D\x04\x1d\"\x1c\x20range\x20\
    sig,\x20full\x20or\x20partial\n\n\x0c\n\x05\x04\x02\x02\t\x04\x12\x03D\
    \x04\x0c\n\x0c\n\x05\x04\x02\x02\t\x05\x12\x03D\r\x12\n\x0c\n\x05\x04\
    \x02\x02\t\x01\x12\x03D\x13\x17\n\x0c\n\x05\x04\x02\x02\t\x03\x12\x03D\
    \x1a\x1c\n\x0b\n\x04\x04\x02\x02\n\x12\x03E\x04#\n\x0c\n\x05\x04\x02\x02\
    \n\x04\x12\x03E\x04\x0c\n\x0c\n\x05\x04\x02\x02\n\x05\x12\x03E\r\x12\n\
    \x0c\n\x05\x04\x02\x02\n\x01\x12\x03E\x13\x1d\n\x0c\n\x05\x04\x02\x02\n\
    \x03\x12\x03E\x20\"\n\x0b\n\x04\x04\x02\x02\x0b\x12\x03F\x04<\n\x0c\n\
    \x05\x04\x02\x02\x0b\x04\x12\x03F\x04\x0c\n\x0c\n\x05\x04\x02\x02\x0b\
    \x06\x12\x03F\r.\n\x0c\n\x05\x04\x02\x02\x0b\x01\x12\x03F/6\n\x0c\n\x05\
    \x04\x02\x02\x0b\x03\x12\x03F9;\n\x82\x01\n\x02\x04\x03\x12\x04O\0U\x01\
    \x1av*\n\x20Request:\x20Ask\x20device\x20for\x20public\x20address\x20der\
    ived\x20from\x20seed\x20and\x20address_n\n\x20@start\n\x20@next\x20Moner\
    oAddress\n\x20@next\x20Failure\n\n\n\n\x03\x04\x03\x01\x12\x03O\x08\x18\
    \n=\n\x04\x04\x03\x02\0\x12\x03P\x04\"\"0\x20BIP-32\x20path\x20to\x20der\
    ive\x20the\x20key\x20from\x20master\x20node\n\n\x0c\n\x05\x04\x03\x02\0\
    \x04\x12\x03P\x04\x0c\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03P\r\x13\n\x0c\
    \n\x05\x04\x03\x02\0\x01\x12\x03P\x14\x1d\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x03P\x20!\nC\n\x04\x04\x03\x02\x01\x12\x03Q\x04#\"6\x20Optionally\
    \x20show\x20on\x20display\x20before\x20sending\x20the\x20result\n\n\x0c\
    \n\x05\x04\x03\x02\x01\x04\x12\x03Q\x04\x0c\n\x0c\n\x05\x04\x03\x02\x01\
    \x05\x12\x03Q\r\x11\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03Q\x12\x1e\n\
    \x0c\n\x05\x04\x03\x02\x01\x03\x12\x03Q!\"\n,\n\x04\x04\x03\x02\x02\x12\
    \x03R\x04%\"\x1f\x20Main-net\x20/\x20testnet\x20/\x20stagenet\n\n\x0c\n\
    \x05\x04\x03\x02\x02\x04\x12\x03R\x04\x0c\n\x0c\n\x05\x04\x03\x02\x02\
    \x05\x12\x03R\r\x13\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03R\x14\x20\n\
    \x0c\n\x05\x04\x03\x02\x02\x03\x12\x03R#$\n\"\n\x04\x04\x03\x02\x03\x12\
    \x03S\x04\x20\"\x15\x20Major\x20subaddr\x20index\n\n\x0c\n\x05\x04\x03\
    \x02\x03\x04\x12\x03S\x04\x0c\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03S\r\
    \x13\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03S\x14\x1b\n\x0c\n\x05\x04\
    \x03\x02\x03\x03\x12\x03S\x1e\x1f\n\"\n\x04\x04\x03\x02\x04\x12\x03T\x04\
    \x1e\"\x15\x20Minor\x20subaddr\x20index\n\n\x0c\n\x05\x04\x03\x02\x04\
    \x04\x12\x03T\x04\x0c\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03T\r\x13\n\
    \x0c\n\x05\x04\x03\x02\x04\x01\x12\x03T\x14\x19\n\x0c\n\x05\x04\x03\x02\
    \x04\x03\x12\x03T\x1c\x1d\ng\n\x02\x04\x04\x12\x04[\0]\x01\x1a[*\n\x20Re\
    sponse:\x20Contains\x20Monero\x20watch-only\x20credentials\x20derived\
    \x20from\x20device\x20private\x20seed\n\x20@end\n\n\n\n\x03\x04\x04\x01\
    \x12\x03[\x08\x15\n\x0b\n\x04\x04\x04\x02\0\x12\x03\\\x04\x1f\n\x0c\n\
    \x05\x04\x04\x02\0\x04\x12\x03\\\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x05\
    \x12\x03\\\r\x12\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03\\\x13\x1a\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x03\\\x1d\x1e\nk\n\x02\x04\x05\x12\x04e\0h\
    \x01\x1a_*\n\x20Request:\x20Ask\x20device\x20for\x20watch\x20only\x20cre\
    dentials\n\x20@start\n\x20@next\x20MoneroWatchKey\n\x20@next\x20Failure\
    \n\n\n\n\x03\x04\x05\x01\x12\x03e\x08\x19\n=\n\x04\x04\x05\x02\0\x12\x03\
    f\x04\"\"0\x20BIP-32\x20path\x20to\x20derive\x20the\x20key\x20from\x20ma\
    ster\x20node\n\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03f\x04\x0c\n\x0c\n\
    \x05\x04\x05\x02\0\x05\x12\x03f\r\x13\n\x0c\n\x05\x04\x05\x02\0\x01\x12\
    \x03f\x14\x1d\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03f\x20!\n,\n\x04\x04\
    \x05\x02\x01\x12\x03g\x04%\"\x1f\x20Main-net\x20/\x20testnet\x20/\x20sta\
    genet\n\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x03g\x04\x0c\n\x0c\n\x05\x04\
    \x05\x02\x01\x05\x12\x03g\r\x13\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03g\
    \x14\x20\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03g#$\ng\n\x02\x04\x06\x12\
    \x04n\0q\x01\x1a[*\n\x20Response:\x20Contains\x20Monero\x20watch-only\
    \x20credentials\x20derived\x20from\x20device\x20private\x20seed\n\x20@en\
    d\n\n\n\n\x03\x04\x06\x01\x12\x03n\x08\x16\n\x0b\n\x04\x04\x06\x02\0\x12\
    \x03o\x04!\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03o\x04\x0c\n\x0c\n\x05\
    \x04\x06\x02\0\x05\x12\x03o\r\x12\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03o\
    \x13\x1c\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03o\x1f\x20\n\x0b\n\x04\x04\
    \x06\x02\x01\x12\x03p\x04\x1f\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03p\
    \x04\x0c\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03p\r\x12\n\x0c\n\x05\x04\
    \x06\x02\x01\x01\x12\x03p\x13\x1a\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\
    \x03p\x1d\x1e\n\x88\x01\n\x02\x04\x07\x12\x05x\0\x91\x01\x01\x1a{*\n\x20\
    Request:\x20Sub\x20request\x20of\x20MoneroTransactionSign.\x20Initialize\
    s\x20transaction\x20signing.\n\x20@start\n\x20@next\x20MoneroTransaction\
    InitAck\n\n\n\n\x03\x04\x07\x01\x12\x03x\x08$\n\x0b\n\x04\x04\x07\x02\0\
    \x12\x03y\x04\x20\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03y\x04\x0c\n\x0c\n\
    \x05\x04\x07\x02\0\x05\x12\x03y\r\x13\n\x0c\n\x05\x04\x07\x02\0\x01\x12\
    \x03y\x14\x1b\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03y\x1e\x1f\n\x0b\n\x04\
    \x04\x07\x02\x01\x12\x03z\x04\"\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03z\
    \x04\x0c\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03z\r\x13\n\x0c\n\x05\x04\
    \x07\x02\x01\x01\x12\x03z\x14\x1d\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\
    \x03z\x20!\n,\n\x04\x04\x07\x02\x02\x12\x03{\x04%\"\x1f\x20Main-net\x20/\
    \x20testnet\x20/\x20stagenet\n\n\x0c\n\x05\x04\x07\x02\x02\x04\x12\x03{\
    \x04\x0c\n\x0c\n\x05\x04\x07\x02\x02\x05\x12\x03{\r\x13\n\x0c\n\x05\x04\
    \x07\x02\x02\x01\x12\x03{\x14\x20\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\
    \x03{#$\n\x0b\n\x04\x04\x07\x02\x03\x12\x03|\x040\n\x0c\n\x05\x04\x07\
    \x02\x03\x04\x12\x03|\x04\x0c\n\x0c\n\x05\x04\x07\x02\x03\x06\x12\x03|\r\
    \"\n\x0c\n\x05\x04\x07\x02\x03\x01\x12\x03|#+\n\x0c\n\x05\x04\x07\x02\
    \x03\x03\x12\x03|./\nQ\n\x04\x04\x07\x03\0\x12\x06\x80\x01\x04\x90\x01\
    \x05\x1aA*\n\x20Structure\x20representing\x20Monero\x20initial\x20transa\
    ction\x20information\n\n\r\n\x05\x04\x07\x03\0\x01\x12\x04\x80\x01\x0c!\
    \n\x0e\n\x06\x04\x07\x03\0\x02\0\x12\x04\x81\x01\x08$\n\x0f\n\x07\x04\
    \x07\x03\0\x02\0\x04\x12\x04\x81\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\
    \x02\0\x05\x12\x04\x81\x01\x11\x17\n\x0f\n\x07\x04\x07\x03\0\x02\0\x01\
    \x12\x04\x81\x01\x18\x1f\n\x0f\n\x07\x04\x07\x03\0\x02\0\x03\x12\x04\x81\
    \x01\"#\n\x0e\n\x06\x04\x07\x03\0\x02\x01\x12\x04\x82\x01\x08&\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x01\x04\x12\x04\x82\x01\x08\x10\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x01\x05\x12\x04\x82\x01\x11\x16\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x01\x01\x12\x04\x82\x01\x17!\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x03\
    \x12\x04\x82\x01$%\n\x0e\n\x06\x04\x07\x03\0\x02\x02\x12\x04\x83\x01\x08\
    (\n\x0f\n\x07\x04\x07\x03\0\x02\x02\x04\x12\x04\x83\x01\x08\x10\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x02\x05\x12\x04\x83\x01\x11\x17\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x02\x01\x12\x04\x83\x01\x18#\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x02\x03\x12\x04\x83\x01&'\n\x0e\n\x06\x04\x07\x03\0\x02\x03\x12\x04\
    \x84\x01\x08?\n\x0f\n\x07\x04\x07\x03\0\x02\x03\x04\x12\x04\x84\x01\x08\
    \x10\n\x0f\n\x07\x04\x07\x03\0\x02\x03\x06\x12\x04\x84\x01\x112\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x03\x01\x12\x04\x84\x013:\n\x0f\n\x07\x04\x07\x03\
    \0\x02\x03\x03\x12\x04\x84\x01=>\n\x0e\n\x06\x04\x07\x03\0\x02\x04\x12\
    \x04\x85\x01\x08B\n\x0f\n\x07\x04\x07\x03\0\x02\x04\x04\x12\x04\x85\x01\
    \x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x04\x06\x12\x04\x85\x01\x112\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x04\x01\x12\x04\x85\x013=\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x04\x03\x12\x04\x85\x01@A\n\x0e\n\x06\x04\x07\x03\0\x02\
    \x05\x12\x04\x86\x01\x08'\n\x0f\n\x07\x04\x07\x03\0\x02\x05\x04\x12\x04\
    \x86\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x05\x05\x12\x04\x86\x01\
    \x11\x17\n\x0f\n\x07\x04\x07\x03\0\x02\x05\x01\x12\x04\x86\x01\x18\"\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x05\x03\x12\x04\x86\x01%&\n\x0e\n\x06\x04\
    \x07\x03\0\x02\x06\x12\x04\x87\x01\x08\"\n\x0f\n\x07\x04\x07\x03\0\x02\
    \x06\x04\x12\x04\x87\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x06\x05\
    \x12\x04\x87\x01\x11\x17\n\x0f\n\x07\x04\x07\x03\0\x02\x06\x01\x12\x04\
    \x87\x01\x18\x1d\n\x0f\n\x07\x04\x07\x03\0\x02\x06\x03\x12\x04\x87\x01\
    \x20!\n\x0e\n\x06\x04\x07\x03\0\x02\x07\x12\x04\x88\x01\x08\x20\n\x0f\n\
    \x07\x04\x07\x03\0\x02\x07\x04\x12\x04\x88\x01\x08\x10\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x07\x05\x12\x04\x88\x01\x11\x17\n\x0f\n\x07\x04\x07\x03\0\
    \x02\x07\x01\x12\x04\x88\x01\x18\x1b\n\x0f\n\x07\x04\x07\x03\0\x02\x07\
    \x03\x12\x04\x88\x01\x1e\x1f\n\x0e\n\x06\x04\x07\x03\0\x02\x08\x12\x04\
    \x89\x01\x08$\n\x0f\n\x07\x04\x07\x03\0\x02\x08\x04\x12\x04\x89\x01\x08\
    \x10\n\x0f\n\x07\x04\x07\x03\0\x02\x08\x05\x12\x04\x89\x01\x11\x17\n\x0f\
    \n\x07\x04\x07\x03\0\x02\x08\x01\x12\x04\x89\x01\x18\x1f\n\x0f\n\x07\x04\
    \x07\x03\0\x02\x08\x03\x12\x04\x89\x01\"#\n\x0e\n\x06\x04\x07\x03\0\x02\
    \t\x12\x04\x8a\x01\x08+\n\x0f\n\x07\x04\x07\x03\0\x02\t\x04\x12\x04\x8a\
    \x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\t\x05\x12\x04\x8a\x01\x11\x17\
    \n\x0f\n\x07\x04\x07\x03\0\x02\t\x01\x12\x04\x8a\x01\x18%\n\x0f\n\x07\
    \x04\x07\x03\0\x02\t\x03\x12\x04\x8a\x01(*\n\x0e\n\x06\x04\x07\x03\0\x02\
    \n\x12\x04\x8b\x01\x08'\n\x0f\n\x07\x04\x07\x03\0\x02\n\x04\x12\x04\x8b\
    \x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\n\x05\x12\x04\x8b\x01\x11\x15\
    \n\x0f\n\x07\x04\x07\x03\0\x02\n\x01\x12\x04\x8b\x01\x16!\n\x0f\n\x07\
    \x04\x07\x03\0\x02\n\x03\x12\x04\x8b\x01$&\n\x0e\n\x06\x04\x07\x03\0\x02\
    \x0b\x12\x04\x8c\x01\x08/\n\x0f\n\x07\x04\x07\x03\0\x02\x0b\x04\x12\x04\
    \x8c\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x0b\x05\x12\x04\x8c\x01\
    \x11\x16\n\x0f\n\x07\x04\x07\x03\0\x02\x0b\x01\x12\x04\x8c\x01\x17)\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x0b\x03\x12\x04\x8c\x01,.\n\x0e\n\x06\x04\
    \x07\x03\0\x02\x0c\x12\x04\x8d\x01\x08(\n\x0f\n\x07\x04\x07\x03\0\x02\
    \x0c\x04\x12\x04\x8d\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x0c\x05\
    \x12\x04\x8d\x01\x11\x16\n\x0f\n\x07\x04\x07\x03\0\x02\x0c\x01\x12\x04\
    \x8d\x01\x17\"\n\x0f\n\x07\x04\x07\x03\0\x02\x0c\x03\x12\x04\x8d\x01%'\n\
    \x0e\n\x06\x04\x07\x03\0\x02\r\x12\x04\x8e\x01\x08:\n\x0f\n\x07\x04\x07\
    \x03\0\x02\r\x04\x12\x04\x8e\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\r\
    \x06\x12\x04\x8e\x01\x11*\n\x0f\n\x07\x04\x07\x03\0\x02\r\x01\x12\x04\
    \x8e\x01+4\n\x0f\n\x07\x04\x07\x03\0\x02\r\x03\x12\x04\x8e\x0179\n\x0e\n\
    \x06\x04\x07\x03\0\x02\x0e\x12\x04\x8f\x01\x080\n\x0f\n\x07\x04\x07\x03\
    \0\x02\x0e\x04\x12\x04\x8f\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x0e\
    \x05\x12\x04\x8f\x01\x11\x17\n\x0f\n\x07\x04\x07\x03\0\x02\x0e\x01\x12\
    \x04\x8f\x01\x18*\n\x0f\n\x07\x04\x07\x03\0\x02\x0e\x03\x12\x04\x8f\x01-\
    /\ns\n\x02\x04\x08\x12\x06\x97\x01\0\x9f\x01\x01\x1ae*\n\x20Response:\
    \x20Response\x20to\x20transaction\x20signing\x20initialization.\n\x20@ne\
    xt\x20MoneroTransactionSetInputRequest\n\n\x0b\n\x03\x04\x08\x01\x12\x04\
    \x97\x01\x08\x20\n\x0c\n\x04\x04\x08\x02\0\x12\x04\x98\x01\x04\x20\n\r\n\
    \x05\x04\x08\x02\0\x04\x12\x04\x98\x01\x04\x0c\n\r\n\x05\x04\x08\x02\0\
    \x05\x12\x04\x98\x01\r\x13\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x98\x01\
    \x14\x1b\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x98\x01\x1e\x1f\n\x0c\n\x04\
    \x04\x08\x02\x01\x12\x04\x99\x01\x04\x1f\n\r\n\x05\x04\x08\x02\x01\x04\
    \x12\x04\x99\x01\x04\x0c\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\x99\x01\r\
    \x13\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\x99\x01\x14\x1a\n\r\n\x05\x04\
    \x08\x02\x01\x03\x12\x04\x99\x01\x1d\x1e\n\x0c\n\x04\x04\x08\x02\x02\x12\
    \x04\x9a\x01\x04\x20\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\x9a\x01\x04\
    \x0c\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\x9a\x01\r\x11\n\r\n\x05\x04\
    \x08\x02\x02\x01\x12\x04\x9a\x01\x12\x1b\n\r\n\x05\x04\x08\x02\x02\x03\
    \x12\x04\x9a\x01\x1e\x1f\n\x0c\n\x04\x04\x08\x02\x03\x12\x04\x9b\x01\x04\
    \x1d\n\r\n\x05\x04\x08\x02\x03\x04\x12\x04\x9b\x01\x04\x0c\n\r\n\x05\x04\
    \x08\x02\x03\x05\x12\x04\x9b\x01\r\x12\n\r\n\x05\x04\x08\x02\x03\x01\x12\
    \x04\x9b\x01\x13\x18\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\x9b\x01\x1b\
    \x1c\n\x0c\n\x04\x04\x08\x02\x04\x12\x04\x9c\x01\x04\"\n\r\n\x05\x04\x08\
    \x02\x04\x04\x12\x04\x9c\x01\x04\x0c\n\r\n\x05\x04\x08\x02\x04\x05\x12\
    \x04\x9c\x01\r\x11\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\x9c\x01\x12\x1d\
    \n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\x9c\x01\x20!\n\x0c\n\x04\x04\x08\
    \x02\x05\x12\x04\x9d\x01\x04#\n\r\n\x05\x04\x08\x02\x05\x04\x12\x04\x9d\
    \x01\x04\x0c\n\r\n\x05\x04\x08\x02\x05\x05\x12\x04\x9d\x01\r\x11\n\r\n\
    \x05\x04\x08\x02\x05\x01\x12\x04\x9d\x01\x12\x1e\n\r\n\x05\x04\x08\x02\
    \x05\x03\x12\x04\x9d\x01!\"\n\x0c\n\x04\x04\x08\x02\x06\x12\x04\x9e\x01\
    \x045\n\r\n\x05\x04\x08\x02\x06\x04\x12\x04\x9e\x01\x04\x0c\n\r\n\x05\
    \x04\x08\x02\x06\x06\x12\x04\x9e\x01\r&\n\r\n\x05\x04\x08\x02\x06\x01\
    \x12\x04\x9e\x01'0\n\r\n\x05\x04\x08\x02\x06\x03\x12\x04\x9e\x0134\n}\n\
    \x02\x04\t\x12\x06\xa5\x01\0\xa8\x01\x01\x1ao*\n\x20Request:\x20Sub\x20r\
    equest\x20of\x20MoneroTransactionSign.\x20Sends\x20one\x20UTXO\x20to\x20\
    device\n\x20@next\x20MoneroTransactionSetInputAck\n\n\x0b\n\x03\x04\t\
    \x01\x12\x04\xa5\x01\x08(\n\x0c\n\x04\x04\t\x02\0\x12\x04\xa6\x01\x04\
    \x20\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xa6\x01\x04\x0c\n\r\n\x05\x04\t\
    \x02\0\x05\x12\x04\xa6\x01\r\x13\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xa6\
    \x01\x14\x1b\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xa6\x01\x1e\x1f\n\x0c\n\
    \x04\x04\t\x02\x01\x12\x04\xa7\x01\x047\n\r\n\x05\x04\t\x02\x01\x04\x12\
    \x04\xa7\x01\x04\x0c\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\xa7\x01\r)\n\r\
    \n\x05\x04\t\x02\x01\x01\x12\x04\xa7\x01*2\n\r\n\x05\x04\t\x02\x01\x03\
    \x12\x04\xa7\x0156\n\xd3\x01\n\x02\x04\n\x12\x06\xaf\x01\0\xb6\x01\x01\
    \x1a\xc4\x01*\n\x20Response:\x20Response\x20to\x20setting\x20UTXO\x20for\
    \x20signature.\x20Contains\x20sealed\x20values\x20needed\x20for\x20furth\
    er\x20protocol\x20steps.\n\x20@next\x20MoneroTransactionSetInputAck\n\
    \x20@next\x20MoneroTransactionInputsPermutationRequest\n\n\x0b\n\x03\x04\
    \n\x01\x12\x04\xaf\x01\x08$\n\"\n\x04\x04\n\x02\0\x12\x04\xb0\x01\x04\
    \x1c\"\x14\x20xmrtypes.TxinToKey\n\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xb0\
    \x01\x04\x0c\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xb0\x01\r\x12\n\r\n\x05\
    \x04\n\x02\0\x01\x12\x04\xb0\x01\x13\x17\n\r\n\x05\x04\n\x02\0\x03\x12\
    \x04\xb0\x01\x1a\x1b\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xb1\x01\x04!\n\r\
    \n\x05\x04\n\x02\x01\x04\x12\x04\xb1\x01\x04\x0c\n\r\n\x05\x04\n\x02\x01\
    \x05\x12\x04\xb1\x01\r\x12\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xb1\x01\
    \x13\x1c\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xb1\x01\x1f\x20\n\x0c\n\x04\
    \x04\n\x02\x02\x12\x04\xb2\x01\x04\"\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\
    \xb2\x01\x04\x0c\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\xb2\x01\r\x12\n\r\n\
    \x05\x04\n\x02\x02\x01\x12\x04\xb2\x01\x13\x1d\n\r\n\x05\x04\n\x02\x02\
    \x03\x12\x04\xb2\x01\x20!\n\x0c\n\x04\x04\n\x02\x03\x12\x04\xb3\x01\x04'\
    \n\r\n\x05\x04\n\x02\x03\x04\x12\x04\xb3\x01\x04\x0c\n\r\n\x05\x04\n\x02\
    \x03\x05\x12\x04\xb3\x01\r\x12\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xb3\
    \x01\x13\"\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\xb3\x01%&\n\x0c\n\x04\x04\
    \n\x02\x04\x12\x04\xb4\x01\x04!\n\r\n\x05\x04\n\x02\x04\x04\x12\x04\xb4\
    \x01\x04\x0c\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\xb4\x01\r\x12\n\r\n\x05\
    \x04\n\x02\x04\x01\x12\x04\xb4\x01\x13\x1c\n\r\n\x05\x04\n\x02\x04\x03\
    \x12\x04\xb4\x01\x1f\x20\n\x0c\n\x04\x04\n\x02\x05\x12\x04\xb5\x01\x04!\
    \n\r\n\x05\x04\n\x02\x05\x04\x12\x04\xb5\x01\x04\x0c\n\r\n\x05\x04\n\x02\
    \x05\x05\x12\x04\xb5\x01\r\x12\n\r\n\x05\x04\n\x02\x05\x01\x12\x04\xb5\
    \x01\x13\x1c\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\xb5\x01\x1f\x20\n\x88\
    \x01\n\x02\x04\x0b\x12\x06\xbc\x01\0\xbe\x01\x01\x1az*\n\x20Request:\x20\
    Sub\x20request\x20of\x20MoneroTransactionSign.\x20Permutation\x20on\x20k\
    ey\x20images.\n\x20@next\x20MoneroTransactionInputsPermutationAck\n\n\
    \x0b\n\x03\x04\x0b\x01\x12\x04\xbc\x01\x081\n\x0c\n\x04\x04\x0b\x02\0\
    \x12\x04\xbd\x01\x04\x1d\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xbd\x01\x04\
    \x0c\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xbd\x01\r\x13\n\r\n\x05\x04\x0b\
    \x02\0\x01\x12\x04\xbd\x01\x14\x18\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\
    \xbd\x01\x1b\x1c\nr\n\x02\x04\x0c\x12\x06\xc4\x01\0\xc5\x01\x01\x1ad*\n\
    \x20Response:\x20Response\x20to\x20setting\x20permutation\x20on\x20key\
    \x20images\n\x20@next\x20MoneroTransactionInputViniRequest\n\n\x0b\n\x03\
    \x04\x0c\x01\x12\x04\xc4\x01\x08-\n\x9c\x01\n\x02\x04\r\x12\x06\xcb\x01\
    \0\xd1\x01\x01\x1a\x8d\x01*\n\x20Request:\x20Sub\x20request\x20of\x20Mon\
    eroTransactionSign.\x20Sends\x20one\x20UTXO\x20to\x20device\x20together\
    \x20with\x20sealed\x20values.\n\x20@next\x20MoneroTransactionInputViniAc\
    k\n\n\x0b\n\x03\x04\r\x01\x12\x04\xcb\x01\x08)\n\x0c\n\x04\x04\r\x02\0\
    \x12\x04\xcc\x01\x047\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xcc\x01\x04\x0c\
    \n\r\n\x05\x04\r\x02\0\x06\x12\x04\xcc\x01\r)\n\r\n\x05\x04\r\x02\0\x01\
    \x12\x04\xcc\x01*2\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xcc\x0156\n\"\n\x04\
    \x04\r\x02\x01\x12\x04\xcd\x01\x04\x1c\"\x14\x20xmrtypes.TxinToKey\n\n\r\
    \n\x05\x04\r\x02\x01\x04\x12\x04\xcd\x01\x04\x0c\n\r\n\x05\x04\r\x02\x01\
    \x05\x12\x04\xcd\x01\r\x12\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xcd\x01\
    \x13\x17\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xcd\x01\x1a\x1b\n\x0c\n\x04\
    \x04\r\x02\x02\x12\x04\xce\x01\x04!\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\
    \xce\x01\x04\x0c\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xce\x01\r\x12\n\r\n\
    \x05\x04\r\x02\x02\x01\x12\x04\xce\x01\x13\x1c\n\r\n\x05\x04\r\x02\x02\
    \x03\x12\x04\xce\x01\x1f\x20\n\x0c\n\x04\x04\r\x02\x03\x12\x04\xcf\x01\
    \x04\"\n\r\n\x05\x04\r\x02\x03\x04\x12\x04\xcf\x01\x04\x0c\n\r\n\x05\x04\
    \r\x02\x03\x05\x12\x04\xcf\x01\r\x12\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\
    \xcf\x01\x13\x1d\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xcf\x01\x20!\n\x0c\
    \n\x04\x04\r\x02\x04\x12\x04\xd0\x01\x04'\n\r\n\x05\x04\r\x02\x04\x04\
    \x12\x04\xd0\x01\x04\x0c\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\xd0\x01\r\
    \x12\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\xd0\x01\x13\"\n\r\n\x05\x04\r\
    \x02\x04\x03\x12\x04\xd0\x01%&\n\x98\x01\n\x02\x04\x0e\x12\x06\xd8\x01\0\
    \xd9\x01\x01\x1a\x89\x01*\n\x20Response:\x20Response\x20to\x20setting\
    \x20UTXO\x20to\x20the\x20device\n\x20@next\x20MoneroTransactionInputVini\
    Request\n\x20@next\x20MoneroTransactionAllInputsSetRequest\n\n\x0b\n\x03\
    \x04\x0e\x01\x12\x04\xd8\x01\x08%\n\xaf\x01\n\x02\x04\x0f\x12\x06\xdf\
    \x01\0\xe1\x01\x01\x1a\xa0\x01*\n\x20Request:\x20Sub\x20request\x20of\
    \x20MoneroTransactionSign.\x20Sent\x20after\x20all\x20inputs\x20have\x20\
    been\x20sent.\x20Useful\x20for\x20rangeisg\x20offloading.\n\x20@next\x20\
    MoneroTransactionAllInputsSetAck\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xdf\
    \x01\x08,\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xe0\x01\x045\n\r\n\x05\x04\
    \x0f\x02\0\x04\x12\x04\xe0\x01\x04\x0c\n\r\n\x05\x04\x0f\x02\0\x06\x12\
    \x04\xe0\x01\r&\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xe0\x01'0\n\r\n\x05\
    \x04\x0f\x02\0\x03\x12\x04\xe0\x0134\np\n\x02\x04\x10\x12\x06\xe7\x01\0\
    \xe9\x01\x01\x1ab*\n\x20Response:\x20Response\x20to\x20after\x20all\x20i\
    nputs\x20have\x20been\x20set.\n\x20@next\x20MoneroTransactionSetOutputRe\
    quest\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xe7\x01\x08(\n\x0c\n\x04\x04\x10\
    \x02\0\x12\x04\xe8\x01\x045\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xe8\x01\
    \x04\x0c\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xe8\x01\r&\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\xe8\x01'0\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xe8\
    \x0134\n\x9b\x01\n\x02\x04\x11\x12\x06\xef\x01\0\xf3\x01\x01\x1a\x8c\x01\
    *\n\x20Request:\x20Sub\x20request\x20of\x20MoneroTransactionSign.\x20Sen\
    ds\x20one\x20transaction\x20destination\x20to\x20device\x20(HMACed)\n\
    \x20@next\x20MoneroTransactionSetOutputAck\n\n\x0b\n\x03\x04\x11\x01\x12\
    \x04\xef\x01\x08)\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xf0\x01\x04<\n\r\n\
    \x05\x04\x11\x02\0\x04\x12\x04\xf0\x01\x04\x0c\n\r\n\x05\x04\x11\x02\0\
    \x06\x12\x04\xf0\x01\r.\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xf0\x01/7\n\
    \r\n\x05\x04\x11\x02\0\x03\x12\x04\xf0\x01:;\n\x0c\n\x04\x04\x11\x02\x01\
    \x12\x04\xf1\x01\x04%\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xf1\x01\x04\
    \x0c\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xf1\x01\r\x12\n\r\n\x05\x04\
    \x11\x02\x01\x01\x12\x04\xf1\x01\x13\x20\n\r\n\x05\x04\x11\x02\x01\x03\
    \x12\x04\xf1\x01#$\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xf2\x01\x045\n\r\
    \n\x05\x04\x11\x02\x02\x04\x12\x04\xf2\x01\x04\x0c\n\r\n\x05\x04\x11\x02\
    \x02\x06\x12\x04\xf2\x01\r&\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xf2\
    \x01'0\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xf2\x0134\n\xd5\x01\n\x02\
    \x04\x12\x12\x06\xfa\x01\0\x80\x02\x01\x1a\xc6\x01*\n\x20Response:\x20Re\
    sponse\x20to\x20setting\x20transaction\x20destination.\x20Contains\x20se\
    aled\x20values\x20needed\x20for\x20further\x20protocol\x20steps.\n\x20@n\
    ext\x20MoneroTransactionSetOutputRequest\n\x20@next\x20MoneroTransaction\
    AllOutSetRequest\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xfa\x01\x08%\n\x1e\n\
    \x04\x04\x12\x02\0\x12\x04\xfb\x01\x04\x1e\"\x10\x20xmrtypes.TxOut\n\n\r\
    \n\x05\x04\x12\x02\0\x04\x12\x04\xfb\x01\x04\x0c\n\r\n\x05\x04\x12\x02\0\
    \x05\x12\x04\xfb\x01\r\x12\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xfb\x01\
    \x13\x19\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xfb\x01\x1c\x1d\n\x0c\n\x04\
    \x04\x12\x02\x01\x12\x04\xfc\x01\x04\"\n\r\n\x05\x04\x12\x02\x01\x04\x12\
    \x04\xfc\x01\x04\x0c\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xfc\x01\r\x12\
    \n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xfc\x01\x13\x1d\n\r\n\x05\x04\x12\
    \x02\x01\x03\x12\x04\xfc\x01\x20!\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\
    \xfd\x01\x045\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\xfd\x01\x04\x0c\n\r\
    \n\x05\x04\x12\x02\x02\x06\x12\x04\xfd\x01\r&\n\r\n\x05\x04\x12\x02\x02\
    \x01\x12\x04\xfd\x01'0\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xfd\x0134\n\
    \x0c\n\x04\x04\x12\x02\x03\x12\x04\xfe\x01\x04\x1e\n\r\n\x05\x04\x12\x02\
    \x03\x04\x12\x04\xfe\x01\x04\x0c\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\
    \xfe\x01\r\x12\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xfe\x01\x13\x19\n\r\
    \n\x05\x04\x12\x02\x03\x03\x12\x04\xfe\x01\x1c\x1d\n\x0c\n\x04\x04\x12\
    \x02\x04\x12\x04\xff\x01\x04!\n\r\n\x05\x04\x12\x02\x04\x04\x12\x04\xff\
    \x01\x04\x0c\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\xff\x01\r\x12\n\r\n\
    \x05\x04\x12\x02\x04\x01\x12\x04\xff\x01\x13\x1c\n\r\n\x05\x04\x12\x02\
    \x04\x03\x12\x04\xff\x01\x1f\x20\n\x86\x01\n\x02\x04\x13\x12\x06\x86\x02\
    \0\x88\x02\x01\x1ax*\n\x20Request:\x20Sub\x20request\x20of\x20MoneroTran\
    sactionSign.\x20Sent\x20after\x20all\x20outputs\x20are\x20sent.\n\x20@ne\
    xt\x20MoneroTransactionAllOutSetAck\n\n\x0b\n\x03\x04\x13\x01\x12\x04\
    \x86\x02\x08)\n\x0c\n\x04\x04\x13\x02\0\x12\x04\x87\x02\x045\n\r\n\x05\
    \x04\x13\x02\0\x04\x12\x04\x87\x02\x04\x0c\n\r\n\x05\x04\x13\x02\0\x06\
    \x12\x04\x87\x02\r&\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x87\x02'0\n\r\n\
    \x05\x04\x13\x02\0\x03\x12\x04\x87\x0234\n\x8a\x01\n\x02\x04\x14\x12\x06\
    \x8e\x02\0\x9b\x02\x01\x1a|*\n\x20Response:\x20After\x20all\x20outputs\
    \x20are\x20sent\x20the\x20initial\x20RCT\x20signature\x20fields\x20are\
    \x20sent.\n\x20@next\x20MoneroTransactionMlsagDoneRequest\n\n\x0b\n\x03\
    \x04\x14\x01\x12\x04\x8e\x02\x08%\n\x0c\n\x04\x04\x14\x02\0\x12\x04\x8f\
    \x02\x04\x1d\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\x8f\x02\x04\x0c\n\r\n\
    \x05\x04\x14\x02\0\x05\x12\x04\x8f\x02\r\x12\n\r\n\x05\x04\x14\x02\0\x01\
    \x12\x04\x8f\x02\x13\x18\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x8f\x02\x1b\
    \x1c\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\x90\x02\x04&\n\r\n\x05\x04\x14\
    \x02\x01\x04\x12\x04\x90\x02\x04\x0c\n\r\n\x05\x04\x14\x02\x01\x05\x12\
    \x04\x90\x02\r\x12\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\x90\x02\x13!\n\
    \r\n\x05\x04\x14\x02\x01\x03\x12\x04\x90\x02$%\n\x0c\n\x04\x04\x14\x02\
    \x02\x12\x04\x91\x02\x045\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\x91\x02\
    \x04\x0c\n\r\n\x05\x04\x14\x02\x02\x06\x12\x04\x91\x02\r&\n\r\n\x05\x04\
    \x14\x02\x02\x01\x12\x04\x91\x02'0\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\
    \x91\x0234\n\x1f\n\x04\x04\x14\x02\x03\x12\x04\x92\x02\x04$\"\x11\x20xmr\
    types.RctSig\n\n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\x92\x02\x04\x0c\n\r\
    \n\x05\x04\x14\x02\x03\x06\x12\x04\x92\x02\r\x1c\n\r\n\x05\x04\x14\x02\
    \x03\x01\x12\x04\x92\x02\x1d\x1f\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\
    \x92\x02\"#\nR\n\x04\x04\x14\x03\0\x12\x06\x96\x02\x04\x9a\x02\x05\x1aB\
    \n\x20Structure\x20represents\x20initial\x20fields\x20of\x20the\x20Moner\
    o\x20RCT\x20signature\n\n\r\n\x05\x04\x14\x03\0\x01\x12\x04\x96\x02\x0c\
    \x1b\n\x0e\n\x06\x04\x14\x03\0\x02\0\x12\x04\x97\x02\x08$\n\x0f\n\x07\
    \x04\x14\x03\0\x02\0\x04\x12\x04\x97\x02\x08\x10\n\x0f\n\x07\x04\x14\x03\
    \0\x02\0\x05\x12\x04\x97\x02\x11\x17\n\x0f\n\x07\x04\x14\x03\0\x02\0\x01\
    \x12\x04\x97\x02\x18\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\0\x03\x12\x04\x97\
    \x02\"#\n\x0e\n\x06\x04\x14\x03\0\x02\x01\x12\x04\x98\x02\x08#\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x01\x04\x12\x04\x98\x02\x08\x10\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x01\x05\x12\x04\x98\x02\x11\x16\n\x0f\n\x07\x04\x14\x03\0\
    \x02\x01\x01\x12\x04\x98\x02\x17\x1e\n\x0f\n\x07\x04\x14\x03\0\x02\x01\
    \x03\x12\x04\x98\x02!\"\n\x0e\n\x06\x04\x14\x03\0\x02\x02\x12\x04\x99\
    \x02\x08$\n\x0f\n\x07\x04\x14\x03\0\x02\x02\x04\x12\x04\x99\x02\x08\x10\
    \n\x0f\n\x07\x04\x14\x03\0\x02\x02\x05\x12\x04\x99\x02\x11\x17\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x02\x01\x12\x04\x99\x02\x18\x1f\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x02\x03\x12\x04\x99\x02\"#\ne\n\x02\x04\x15\x12\x06\xa1\
    \x02\0\xa2\x02\x01\x1aW*\n\x20Request:\x20Sub\x20request\x20of\x20Monero\
    TransactionSign.\n\x20@next\x20MoneroTransactionMlsagDoneAck\n\n\x0b\n\
    \x03\x04\x15\x01\x12\x04\xa1\x02\x08)\nx\n\x02\x04\x16\x12\x06\xa8\x02\0\
    \xaa\x02\x01\x1aj*\n\x20Response:\x20Contains\x20full\x20message\x20hash\
    \x20needed\x20for\x20the\x20signature\n\x20@next\x20MoneroTransactionSig\
    nInputRequest\n\n\x0b\n\x03\x04\x16\x01\x12\x04\xa8\x02\x08%\n\x0c\n\x04\
    \x04\x16\x02\0\x12\x04\xa9\x02\x04)\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\
    \xa9\x02\x04\x0c\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xa9\x02\r\x12\n\r\n\
    \x05\x04\x16\x02\0\x01\x12\x04\xa9\x02\x13$\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\xa9\x02'(\n\x81\x01\n\x02\x04\x17\x12\x06\xb0\x02\0\xb8\x02\x01\
    \x1as*\n\x20Request:\x20Sub\x20request\x20of\x20MoneroTransactionSign.\
    \x20Sends\x20UTXO\x20for\x20the\x20signing.\n\x20@next\x20MoneroTransact\
    ionSignInputAck\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xb0\x02\x08)\n\x0c\n\
    \x04\x04\x17\x02\0\x12\x04\xb1\x02\x047\n\r\n\x05\x04\x17\x02\0\x04\x12\
    \x04\xb1\x02\x04\x0c\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xb1\x02\r)\n\r\
    \n\x05\x04\x17\x02\0\x01\x12\x04\xb1\x02*2\n\r\n\x05\x04\x17\x02\0\x03\
    \x12\x04\xb1\x0256\n\"\n\x04\x04\x17\x02\x01\x12\x04\xb2\x02\x04\x1c\"\
    \x14\x20xmrtypes.TxinToKey\n\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xb2\
    \x02\x04\x0c\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xb2\x02\r\x12\n\r\n\
    \x05\x04\x17\x02\x01\x01\x12\x04\xb2\x02\x13\x17\n\r\n\x05\x04\x17\x02\
    \x01\x03\x12\x04\xb2\x02\x1a\x1b\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\xb3\
    \x02\x04!\n\r\n\x05\x04\x17\x02\x02\x04\x12\x04\xb3\x02\x04\x0c\n\r\n\
    \x05\x04\x17\x02\x02\x05\x12\x04\xb3\x02\r\x12\n\r\n\x05\x04\x17\x02\x02\
    \x01\x12\x04\xb3\x02\x13\x1c\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xb3\
    \x02\x1f\x20\n\x0c\n\x04\x04\x17\x02\x03\x12\x04\xb4\x02\x04\"\n\r\n\x05\
    \x04\x17\x02\x03\x04\x12\x04\xb4\x02\x04\x0c\n\r\n\x05\x04\x17\x02\x03\
    \x05\x12\x04\xb4\x02\r\x12\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\xb4\x02\
    \x13\x1d\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\xb4\x02\x20!\n\x0c\n\x04\
    \x04\x17\x02\x04\x12\x04\xb5\x02\x04'\n\r\n\x05\x04\x17\x02\x04\x04\x12\
    \x04\xb5\x02\x04\x0c\n\r\n\x05\x04\x17\x02\x04\x05\x12\x04\xb5\x02\r\x12\
    \n\r\n\x05\x04\x17\x02\x04\x01\x12\x04\xb5\x02\x13\"\n\r\n\x05\x04\x17\
    \x02\x04\x03\x12\x04\xb5\x02%&\n\x0c\n\x04\x04\x17\x02\x05\x12\x04\xb6\
    \x02\x04!\n\r\n\x05\x04\x17\x02\x05\x04\x12\x04\xb6\x02\x04\x0c\n\r\n\
    \x05\x04\x17\x02\x05\x05\x12\x04\xb6\x02\r\x12\n\r\n\x05\x04\x17\x02\x05\
    \x01\x12\x04\xb6\x02\x13\x1c\n\r\n\x05\x04\x17\x02\x05\x03\x12\x04\xb6\
    \x02\x1f\x20\n\x0c\n\x04\x04\x17\x02\x06\x12\x04\xb7\x02\x04!\n\r\n\x05\
    \x04\x17\x02\x06\x04\x12\x04\xb7\x02\x04\x0c\n\r\n\x05\x04\x17\x02\x06\
    \x05\x12\x04\xb7\x02\r\x12\n\r\n\x05\x04\x17\x02\x06\x01\x12\x04\xb7\x02\
    \x13\x1c\n\r\n\x05\x04\x17\x02\x06\x03\x12\x04\xb7\x02\x1f\x20\n\xb0\x01\
    \n\x02\x04\x18\x12\x06\xbf\x02\0\xc2\x02\x01\x1a\xa1\x01*\n\x20Response:\
    \x20Contains\x20full\x20MG\x20signature\x20of\x20the\x20UTXO\x20+\x20mul\
    tisig\x20data\x20if\x20applicable.\n\x20@next\x20MoneroTransactionSignIn\
    putRequest\n\x20@next\x20MoneroTransactionFinalRequest\n\n\x0b\n\x03\x04\
    \x18\x01\x12\x04\xbf\x02\x08%\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xc0\x02\
    \x04!\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\xc0\x02\x04\x0c\n\r\n\x05\x04\
    \x18\x02\0\x05\x12\x04\xc0\x02\r\x12\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\
    \xc0\x02\x13\x1c\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xc0\x02\x1f\x20\n\
    \x0c\n\x04\x04\x18\x02\x01\x12\x04\xc1\x02\x04\x1c\n\r\n\x05\x04\x18\x02\
    \x01\x04\x12\x04\xc1\x02\x04\x0c\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\
    \xc1\x02\r\x12\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xc1\x02\x13\x17\n\r\
    \n\x05\x04\x18\x02\x01\x03\x12\x04\xc1\x02\x1a\x1b\n\x99\x01\n\x02\x04\
    \x19\x12\x06\xc8\x02\0\xc9\x02\x01\x1a\x8a\x01*\n\x20Request:\x20Sub\x20\
    request\x20of\x20MoneroTransactionSign.\x20Final\x20message\x20of\x20the\
    \x20procol\x20after\x20all\x20UTXOs\x20are\x20signed\n\x20@next\x20Moner\
    oTransactionFinalAck\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xc8\x02\x08%\n\
    \x9b\x01\n\x02\x04\x1a\x12\x06\xcf\x02\0\xd4\x02\x01\x1a\x8c\x01*\n\x20R\
    esponse:\x20Contains\x20transaction\x20metadata\x20and\x20encryption\x20\
    keys\x20needed\x20for\x20further\x20transaction\x20operations\x20(e.g.\
    \x20multisig,\x20send\x20proof).\n\x20@end\n\n\x0b\n\x03\x04\x1a\x01\x12\
    \x04\xcf\x02\x08!\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xd0\x02\x04\x20\n\r\
    \n\x05\x04\x1a\x02\0\x04\x12\x04\xd0\x02\x04\x0c\n\r\n\x05\x04\x1a\x02\0\
    \x05\x12\x04\xd0\x02\r\x12\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xd0\x02\
    \x13\x1b\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xd0\x02\x1e\x1f\n\x0c\n\x04\
    \x04\x1a\x02\x01\x12\x04\xd1\x02\x04\x1c\n\r\n\x05\x04\x1a\x02\x01\x04\
    \x12\x04\xd1\x02\x04\x0c\n\r\n\x05\x04\x1a\x02\x01\x05\x12\x04\xd1\x02\r\
    \x12\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xd1\x02\x13\x17\n\r\n\x05\x04\
    \x1a\x02\x01\x03\x12\x04\xd1\x02\x1a\x1b\n\x0c\n\x04\x04\x1a\x02\x02\x12\
    \x04\xd2\x02\x04!\n\r\n\x05\x04\x1a\x02\x02\x04\x12\x04\xd2\x02\x04\x0c\
    \n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xd2\x02\r\x12\n\r\n\x05\x04\x1a\
    \x02\x02\x01\x12\x04\xd2\x02\x13\x1c\n\r\n\x05\x04\x1a\x02\x02\x03\x12\
    \x04\xd2\x02\x1f\x20\n\x0c\n\x04\x04\x1a\x02\x03\x12\x04\xd3\x02\x04#\n\
    \r\n\x05\x04\x1a\x02\x03\x04\x12\x04\xd3\x02\x04\x0c\n\r\n\x05\x04\x1a\
    \x02\x03\x05\x12\x04\xd3\x02\r\x12\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\
    \xd3\x02\x13\x1e\n\r\n\x05\x04\x1a\x02\x03\x03\x12\x04\xd3\x02!\"\n\x85\
    \x01\n\x02\x04\x1b\x12\x06\xdb\x02\0\xe8\x02\x01\x1aw*\n\x20Request:\x20\
    Sub\x20request\x20of\x20MoneroKeyImageSync.\x20Initializing\x20key\x20im\
    age\x20sync.\n\x20@start\n\x20@next\x20MoneroKeyImageExportInitAck\n\n\
    \x0b\n\x03\x04\x1b\x01\x12\x04\xdb\x02\x08'\n\x0c\n\x04\x04\x1b\x02\0\
    \x12\x04\xdc\x02\x04\x1c\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xdc\x02\x04\
    \x0c\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xdc\x02\r\x13\n\r\n\x05\x04\x1b\
    \x02\0\x01\x12\x04\xdc\x02\x14\x17\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\
    \xdc\x02\x1a\x1b\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xdd\x02\x04\x1c\n\r\
    \n\x05\x04\x1b\x02\x01\x04\x12\x04\xdd\x02\x04\x0c\n\r\n\x05\x04\x1b\x02\
    \x01\x05\x12\x04\xdd\x02\r\x12\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xdd\
    \x02\x13\x17\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xdd\x02\x1a\x1b\n>\n\
    \x04\x04\x1b\x02\x02\x12\x04\xde\x02\x04\"\"0\x20BIP-32\x20path\x20to\
    \x20derive\x20the\x20key\x20from\x20master\x20node\n\n\r\n\x05\x04\x1b\
    \x02\x02\x04\x12\x04\xde\x02\x04\x0c\n\r\n\x05\x04\x1b\x02\x02\x05\x12\
    \x04\xde\x02\r\x13\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xde\x02\x14\x1d\
    \n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xde\x02\x20!\n-\n\x04\x04\x1b\x02\
    \x03\x12\x04\xdf\x02\x04%\"\x1f\x20Main-net\x20/\x20testnet\x20/\x20stag\
    enet\n\n\r\n\x05\x04\x1b\x02\x03\x04\x12\x04\xdf\x02\x04\x0c\n\r\n\x05\
    \x04\x1b\x02\x03\x05\x12\x04\xdf\x02\r\x13\n\r\n\x05\x04\x1b\x02\x03\x01\
    \x12\x04\xdf\x02\x14\x20\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\xdf\x02#$\
    \n\x0c\n\x04\x04\x1b\x02\x04\x12\x04\xe0\x02\x042\n\r\n\x05\x04\x1b\x02\
    \x04\x04\x12\x04\xe0\x02\x04\x0c\n\r\n\x05\x04\x1b\x02\x04\x06\x12\x04\
    \xe0\x02\r(\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\xe0\x02)-\n\r\n\x05\
    \x04\x1b\x02\x04\x03\x12\x04\xe0\x0201\nG\n\x04\x04\x1b\x03\0\x12\x06\
    \xe4\x02\x04\xe7\x02\x05\x1a7*\n\x20Structure\x20representing\x20Monero\
    \x20list\x20of\x20sub-addresses\n\n\r\n\x05\x04\x1b\x03\0\x01\x12\x04\
    \xe4\x02\x0c'\n\x0e\n\x06\x04\x1b\x03\0\x02\0\x12\x04\xe5\x02\x08$\n\x0f\
    \n\x07\x04\x1b\x03\0\x02\0\x04\x12\x04\xe5\x02\x08\x10\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\0\x05\x12\x04\xe5\x02\x11\x17\n\x0f\n\x07\x04\x1b\x03\0\
    \x02\0\x01\x12\x04\xe5\x02\x18\x1f\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x03\
    \x12\x04\xe5\x02\"#\n\x0e\n\x06\x04\x1b\x03\0\x02\x01\x12\x04\xe6\x02\
    \x08*\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x04\x12\x04\xe6\x02\x08\x10\n\
    \x0f\n\x07\x04\x1b\x03\0\x02\x01\x05\x12\x04\xe6\x02\x11\x17\n\x0f\n\x07\
    \x04\x1b\x03\0\x02\x01\x01\x12\x04\xe6\x02\x18%\n\x0f\n\x07\x04\x1b\x03\
    \0\x02\x01\x03\x12\x04\xe6\x02()\nk\n\x02\x04\x1c\x12\x06\xee\x02\0\xef\
    \x02\x01\x1a]*\n\x20Response:\x20Response\x20to\x20key\x20image\x20sync\
    \x20initialization.\n\x20@next\x20MoneroKeyImageSyncStepRequest\n\n\x0b\
    \n\x03\x04\x1c\x01\x12\x04\xee\x02\x08#\n\x93\x01\n\x02\x04\x1d\x12\x06\
    \xf5\x02\0\x80\x03\x01\x1a\x84\x01*\n\x20Request:\x20Sub\x20request\x20o\
    f\x20MoneroKeyImageSync.\x20Contains\x20batch\x20of\x20the\x20UTXO\x20to\
    \x20export\x20key\x20image\x20for.\n\x20@next\x20MoneroKeyImageSyncStepA\
    ck\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xf5\x02\x08%\n\x0c\n\x04\x04\x1d\
    \x02\0\x12\x04\xf6\x02\x04,\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xf6\x02\
    \x04\x0c\n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\xf6\x02\r\"\n\r\n\x05\x04\
    \x1d\x02\0\x01\x12\x04\xf6\x02#'\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xf6\
    \x02*+\nI\n\x04\x04\x1d\x03\0\x12\x06\xfa\x02\x04\xff\x02\x05\x1a9*\n\
    \x20Structure\x20representing\x20Monero\x20UTXO\x20for\x20key\x20image\
    \x20sync\n\n\r\n\x05\x04\x1d\x03\0\x01\x12\x04\xfa\x02\x0c!\n\x0e\n\x06\
    \x04\x1d\x03\0\x02\0\x12\x04\xfb\x02\x08#\n\x0f\n\x07\x04\x1d\x03\0\x02\
    \0\x04\x12\x04\xfb\x02\x08\x10\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x05\x12\
    \x04\xfb\x02\x11\x16\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x01\x12\x04\xfb\x02\
    \x17\x1e\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x03\x12\x04\xfb\x02!\"\n\x0e\n\
    \x06\x04\x1d\x03\0\x02\x01\x12\x04\xfc\x02\x08&\n\x0f\n\x07\x04\x1d\x03\
    \0\x02\x01\x04\x12\x04\xfc\x02\x08\x10\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\
    \x05\x12\x04\xfc\x02\x11\x16\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x01\x12\
    \x04\xfc\x02\x17!\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x03\x12\x04\xfc\x02$\
    %\n\x0e\n\x06\x04\x1d\x03\0\x02\x02\x12\x04\xfd\x02\x082\n\x0f\n\x07\x04\
    \x1d\x03\0\x02\x02\x04\x12\x04\xfd\x02\x08\x10\n\x0f\n\x07\x04\x1d\x03\0\
    \x02\x02\x05\x12\x04\xfd\x02\x11\x16\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\
    \x01\x12\x04\xfd\x02\x17-\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x03\x12\x04\
    \xfd\x0201\n\x0e\n\x06\x04\x1d\x03\0\x02\x03\x12\x04\xfe\x02\x082\n\x0f\
    \n\x07\x04\x1d\x03\0\x02\x03\x04\x12\x04\xfe\x02\x08\x10\n\x0f\n\x07\x04\
    \x1d\x03\0\x02\x03\x05\x12\x04\xfe\x02\x11\x17\n\x0f\n\x07\x04\x1d\x03\0\
    \x02\x03\x01\x12\x04\xfe\x02\x18-\n\x0f\n\x07\x04\x1d\x03\0\x02\x03\x03\
    \x12\x04\xfe\x0201\n\xaf\x01\n\x02\x04\x1e\x12\x06\x87\x03\0\x91\x03\x01\
    \x1a\xa0\x01*\n\x20Response:\x20Response\x20to\x20key\x20image\x20sync\
    \x20step.\x20Contains\x20encrypted\x20exported\x20key\x20image.\n\x20@ne\
    xt\x20MoneroKeyImageSyncStepRequest\n\x20@next\x20MoneroKeyImageSyncFina\
    lRequest\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\x87\x03\x08!\n\x0c\n\x04\x04\
    \x1e\x02\0\x12\x04\x88\x03\x04,\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\x88\
    \x03\x04\x0c\n\r\n\x05\x04\x1e\x02\0\x06\x12\x04\x88\x03\r#\n\r\n\x05\
    \x04\x1e\x02\0\x01\x12\x04\x88\x03$'\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\
    \x88\x03*+\nN\n\x04\x04\x1e\x03\0\x12\x06\x8c\x03\x04\x90\x03\x05\x1a>*\
    \n\x20Structure\x20representing\x20Monero\x20encrypted\x20exported\x20ke\
    y\x20image\n\n\r\n\x05\x04\x1e\x03\0\x01\x12\x04\x8c\x03\x0c\"\n\x0e\n\
    \x06\x04\x1e\x03\0\x02\0\x12\x04\x8d\x03\x08\x1e\n\x0f\n\x07\x04\x1e\x03\
    \0\x02\0\x04\x12\x04\x8d\x03\x08\x10\n\x0f\n\x07\x04\x1e\x03\0\x02\0\x05\
    \x12\x04\x8d\x03\x11\x16\n\x0f\n\x07\x04\x1e\x03\0\x02\0\x01\x12\x04\x8d\
    \x03\x17\x19\n\x0f\n\x07\x04\x1e\x03\0\x02\0\x03\x12\x04\x8d\x03\x1c\x1d\
    \n\x0e\n\x06\x04\x1e\x03\0\x02\x01\x12\x04\x8e\x03\x08\x1f\n\x0f\n\x07\
    \x04\x1e\x03\0\x02\x01\x04\x12\x04\x8e\x03\x08\x10\n\x0f\n\x07\x04\x1e\
    \x03\0\x02\x01\x05\x12\x04\x8e\x03\x11\x16\n\x0f\n\x07\x04\x1e\x03\0\x02\
    \x01\x01\x12\x04\x8e\x03\x17\x1a\n\x0f\n\x07\x04\x1e\x03\0\x02\x01\x03\
    \x12\x04\x8e\x03\x1d\x1e\n\x0e\n\x06\x04\x1e\x03\0\x02\x02\x12\x04\x8f\
    \x03\x08\x20\n\x0f\n\x07\x04\x1e\x03\0\x02\x02\x04\x12\x04\x8f\x03\x08\
    \x10\n\x0f\n\x07\x04\x1e\x03\0\x02\x02\x05\x12\x04\x8f\x03\x11\x16\n\x0f\
    \n\x07\x04\x1e\x03\0\x02\x02\x01\x12\x04\x8f\x03\x17\x1b\n\x0f\n\x07\x04\
    \x1e\x03\0\x02\x02\x03\x12\x04\x8f\x03\x1e\x1f\n\x83\x01\n\x02\x04\x1f\
    \x12\x06\x97\x03\0\x98\x03\x01\x1au*\n\x20Request:\x20Sub\x20request\x20\
    of\x20MoneroKeyImageSync.\x20Final\x20message\x20of\x20the\x20sync\x20pr\
    otocol.\n\x20@next\x20MoneroKeyImageSyncFinalAck\n\n\x0b\n\x03\x04\x1f\
    \x01\x12\x04\x97\x03\x08&\nt\n\x02\x04\x20\x12\x06\x9e\x03\0\xa0\x03\x01\
    \x1af*\n\x20Response:\x20Response\x20to\x20key\x20image\x20sync\x20step.\
    \x20Contains\x20encryption\x20keys\x20for\x20exported\x20key\x20images.\
    \n\x20@end\n\n\x0b\n\x03\x04\x20\x01\x12\x04\x9e\x03\x08\"\n\x0c\n\x04\
    \x04\x20\x02\0\x12\x04\x9f\x03\x04\x1f\n\r\n\x05\x04\x20\x02\0\x04\x12\
    \x04\x9f\x03\x04\x0c\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\x9f\x03\r\x12\n\
    \r\n\x05\x04\x20\x02\0\x01\x12\x04\x9f\x03\x13\x1a\n\r\n\x05\x04\x20\x02\
    \0\x03\x12\x04\x9f\x03\x1d\x1e\nx\n\x02\x04!\x12\x06\xa7\x03\0\xae\x03\
    \x01\x1aj*\n\x20Request:\x20Universal\x20Monero\x20protocol\x20implement\
    ation\x20diagnosis\x20request.\n\x20@start\n\x20@next\x20DebugMoneroDiag\
    Ack\n\n\x0b\n\x03\x04!\x01\x12\x04\xa7\x03\x08\x1e\n\x0c\n\x04\x04!\x02\
    \0\x12\x04\xa8\x03\x04\x1c\n\r\n\x05\x04!\x02\0\x04\x12\x04\xa8\x03\x04\
    \x0c\n\r\n\x05\x04!\x02\0\x05\x12\x04\xa8\x03\r\x13\n\r\n\x05\x04!\x02\0\
    \x01\x12\x04\xa8\x03\x14\x17\n\r\n\x05\x04!\x02\0\x03\x12\x04\xa8\x03\
    \x1a\x1b\n\x0c\n\x04\x04!\x02\x01\x12\x04\xa9\x03\x04\x1b\n\r\n\x05\x04!\
    \x02\x01\x04\x12\x04\xa9\x03\x04\x0c\n\r\n\x05\x04!\x02\x01\x05\x12\x04\
    \xa9\x03\r\x13\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xa9\x03\x14\x16\n\r\n\
    \x05\x04!\x02\x01\x03\x12\x04\xa9\x03\x19\x1a\n\x0c\n\x04\x04!\x02\x02\
    \x12\x04\xaa\x03\x04\x1b\n\r\n\x05\x04!\x02\x02\x04\x12\x04\xaa\x03\x04\
    \x0c\n\r\n\x05\x04!\x02\x02\x05\x12\x04\xaa\x03\r\x13\n\r\n\x05\x04!\x02\
    \x02\x01\x12\x04\xaa\x03\x14\x16\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xaa\
    \x03\x19\x1a\n\x0c\n\x04\x04!\x02\x03\x12\x04\xab\x03\x04\x1b\n\r\n\x05\
    \x04!\x02\x03\x04\x12\x04\xab\x03\x04\x0c\n\r\n\x05\x04!\x02\x03\x05\x12\
    \x04\xab\x03\r\x13\n\r\n\x05\x04!\x02\x03\x01\x12\x04\xab\x03\x14\x16\n\
    \r\n\x05\x04!\x02\x03\x03\x12\x04\xab\x03\x19\x1a\n\x0c\n\x04\x04!\x02\
    \x04\x12\x04\xac\x03\x04\x1d\n\r\n\x05\x04!\x02\x04\x04\x12\x04\xac\x03\
    \x04\x0c\n\r\n\x05\x04!\x02\x04\x05\x12\x04\xac\x03\r\x12\n\r\n\x05\x04!\
    \x02\x04\x01\x12\x04\xac\x03\x13\x18\n\r\n\x05\x04!\x02\x04\x03\x12\x04\
    \xac\x03\x1b\x1c\n\x0c\n\x04\x04!\x02\x05\x12\x04\xad\x03\x04\x1d\n\r\n\
    \x05\x04!\x02\x05\x04\x12\x04\xad\x03\x04\x0c\n\r\n\x05\x04!\x02\x05\x05\
    \x12\x04\xad\x03\r\x12\n\r\n\x05\x04!\x02\x05\x01\x12\x04\xad\x03\x13\
    \x18\n\r\n\x05\x04!\x02\x05\x03\x12\x04\xad\x03\x1b\x1c\nH\n\x02\x04\"\
    \x12\x06\xb4\x03\0\xbb\x03\x01\x1a:*\n\x20Response:\x20Response\x20to\
    \x20Monero\x20diagnosis\x20protocol.\n\x20@end\n\n\x0b\n\x03\x04\"\x01\
    \x12\x04\xb4\x03\x08\x1a\n\x0c\n\x04\x04\"\x02\0\x12\x04\xb5\x03\x04\x1c\
    \n\r\n\x05\x04\"\x02\0\x04\x12\x04\xb5\x03\x04\x0c\n\r\n\x05\x04\"\x02\0\
    \x05\x12\x04\xb5\x03\r\x13\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xb5\x03\x14\
    \x17\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xb5\x03\x1a\x1b\n\x0c\n\x04\x04\"\
    \x02\x01\x12\x04\xb6\x03\x04\x1b\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\xb6\
    \x03\x04\x0c\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\xb6\x03\r\x13\n\r\n\x05\
    \x04\"\x02\x01\x01\x12\x04\xb6\x03\x14\x16\n\r\n\x05\x04\"\x02\x01\x03\
    \x12\x04\xb6\x03\x19\x1a\n\x0c\n\x04\x04\"\x02\x02\x12\x04\xb7\x03\x04\
    \x1b\n\r\n\x05\x04\"\x02\x02\x04\x12\x04\xb7\x03\x04\x0c\n\r\n\x05\x04\"\
    \x02\x02\x05\x12\x04\xb7\x03\r\x13\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\
    \xb7\x03\x14\x16\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xb7\x03\x19\x1a\n\
    \x0c\n\x04\x04\"\x02\x03\x12\x04\xb8\x03\x04\x1b\n\r\n\x05\x04\"\x02\x03\
    \x04\x12\x04\xb8\x03\x04\x0c\n\r\n\x05\x04\"\x02\x03\x05\x12\x04\xb8\x03\
    \r\x13\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\xb8\x03\x14\x16\n\r\n\x05\x04\
    \"\x02\x03\x03\x12\x04\xb8\x03\x19\x1a\n\x0c\n\x04\x04\"\x02\x04\x12\x04\
    \xb9\x03\x04\x1d\n\r\n\x05\x04\"\x02\x04\x04\x12\x04\xb9\x03\x04\x0c\n\r\
    \n\x05\x04\"\x02\x04\x05\x12\x04\xb9\x03\r\x12\n\r\n\x05\x04\"\x02\x04\
    \x01\x12\x04\xb9\x03\x13\x18\n\r\n\x05\x04\"\x02\x04\x03\x12\x04\xb9\x03\
    \x1b\x1c\n\x0c\n\x04\x04\"\x02\x05\x12\x04\xba\x03\x04\x1d\n\r\n\x05\x04\
    \"\x02\x05\x04\x12\x04\xba\x03\x04\x0c\n\r\n\x05\x04\"\x02\x05\x05\x12\
    \x04\xba\x03\r\x12\n\r\n\x05\x04\"\x02\x05\x01\x12\x04\xba\x03\x13\x18\n\
    \r\n\x05\x04\"\x02\x05\x03\x12\x04\xba\x03\x1b\x1c\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
