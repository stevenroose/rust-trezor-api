// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `messages-tezos.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct TezosGetAddress {
    // message fields
    address_n: ::std::vec::Vec<u32>,
    show_display: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosGetAddress {
    fn default() -> &'a TezosGetAddress {
        <TezosGetAddress as ::protobuf::Message>::default_instance()
    }
}

impl TezosGetAddress {
    pub fn new() -> TezosGetAddress {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional bool show_display = 2;


    pub fn get_show_display(&self) -> bool {
        self.show_display.unwrap_or(false)
    }
    pub fn clear_show_display(&mut self) {
        self.show_display = ::std::option::Option::None;
    }

    pub fn has_show_display(&self) -> bool {
        self.show_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_display(&mut self, v: bool) {
        self.show_display = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TezosGetAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_display = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.show_display {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.show_display {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosGetAddress {
        TezosGetAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address_n",
                    |m: &TezosGetAddress| { &m.address_n },
                    |m: &mut TezosGetAddress| { &mut m.address_n },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "show_display",
                    |m: &TezosGetAddress| { &m.show_display },
                    |m: &mut TezosGetAddress| { &mut m.show_display },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TezosGetAddress>(
                    "TezosGetAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TezosGetAddress {
        static mut instance: ::protobuf::lazy::Lazy<TezosGetAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TezosGetAddress,
        };
        unsafe {
            instance.get(TezosGetAddress::new)
        }
    }
}

impl ::protobuf::Clear for TezosGetAddress {
    fn clear(&mut self) {
        self.address_n.clear();
        self.show_display = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosGetAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosGetAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosAddress {
    // message fields
    address: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosAddress {
    fn default() -> &'a TezosAddress {
        <TezosAddress as ::protobuf::Message>::default_instance()
    }
}

impl TezosAddress {
    pub fn new() -> TezosAddress {
        ::std::default::Default::default()
    }

    // optional string address = 1;


    pub fn get_address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TezosAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.address.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosAddress {
        TezosAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &TezosAddress| { &m.address },
                    |m: &mut TezosAddress| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TezosAddress>(
                    "TezosAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TezosAddress {
        static mut instance: ::protobuf::lazy::Lazy<TezosAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TezosAddress,
        };
        unsafe {
            instance.get(TezosAddress::new)
        }
    }
}

impl ::protobuf::Clear for TezosAddress {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosGetPublicKey {
    // message fields
    address_n: ::std::vec::Vec<u32>,
    show_display: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosGetPublicKey {
    fn default() -> &'a TezosGetPublicKey {
        <TezosGetPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl TezosGetPublicKey {
    pub fn new() -> TezosGetPublicKey {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional bool show_display = 2;


    pub fn get_show_display(&self) -> bool {
        self.show_display.unwrap_or(false)
    }
    pub fn clear_show_display(&mut self) {
        self.show_display = ::std::option::Option::None;
    }

    pub fn has_show_display(&self) -> bool {
        self.show_display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_display(&mut self, v: bool) {
        self.show_display = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TezosGetPublicKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_display = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.show_display {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.show_display {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosGetPublicKey {
        TezosGetPublicKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address_n",
                    |m: &TezosGetPublicKey| { &m.address_n },
                    |m: &mut TezosGetPublicKey| { &mut m.address_n },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "show_display",
                    |m: &TezosGetPublicKey| { &m.show_display },
                    |m: &mut TezosGetPublicKey| { &mut m.show_display },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TezosGetPublicKey>(
                    "TezosGetPublicKey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TezosGetPublicKey {
        static mut instance: ::protobuf::lazy::Lazy<TezosGetPublicKey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TezosGetPublicKey,
        };
        unsafe {
            instance.get(TezosGetPublicKey::new)
        }
    }
}

impl ::protobuf::Clear for TezosGetPublicKey {
    fn clear(&mut self) {
        self.address_n.clear();
        self.show_display = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosGetPublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosGetPublicKey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosPublicKey {
    // message fields
    public_key: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosPublicKey {
    fn default() -> &'a TezosPublicKey {
        <TezosPublicKey as ::protobuf::Message>::default_instance()
    }
}

impl TezosPublicKey {
    pub fn new() -> TezosPublicKey {
        ::std::default::Default::default()
    }

    // optional string public_key = 1;


    pub fn get_public_key(&self) -> &str {
        match self.public_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::string::String) {
        self.public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::string::String {
        if self.public_key.is_none() {
            self.public_key.set_default();
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::string::String {
        self.public_key.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TezosPublicKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.public_key.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosPublicKey {
        TezosPublicKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "public_key",
                    |m: &TezosPublicKey| { &m.public_key },
                    |m: &mut TezosPublicKey| { &mut m.public_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TezosPublicKey>(
                    "TezosPublicKey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TezosPublicKey {
        static mut instance: ::protobuf::lazy::Lazy<TezosPublicKey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TezosPublicKey,
        };
        unsafe {
            instance.get(TezosPublicKey::new)
        }
    }
}

impl ::protobuf::Clear for TezosPublicKey {
    fn clear(&mut self) {
        self.public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosPublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosPublicKey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx {
    // message fields
    address_n: ::std::vec::Vec<u32>,
    branch: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    reveal: ::protobuf::SingularPtrField<TezosSignTx_TezosRevealOp>,
    transaction: ::protobuf::SingularPtrField<TezosSignTx_TezosTransactionOp>,
    origination: ::protobuf::SingularPtrField<TezosSignTx_TezosOriginationOp>,
    delegation: ::protobuf::SingularPtrField<TezosSignTx_TezosDelegationOp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx {
    fn default() -> &'a TezosSignTx {
        <TezosSignTx as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx {
    pub fn new() -> TezosSignTx {
        ::std::default::Default::default()
    }

    // repeated uint32 address_n = 1;


    pub fn get_address_n(&self) -> &[u32] {
        &self.address_n
    }
    pub fn clear_address_n(&mut self) {
        self.address_n.clear();
    }

    // Param is passed by value, moved
    pub fn set_address_n(&mut self, v: ::std::vec::Vec<u32>) {
        self.address_n = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address_n(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.address_n
    }

    // Take field
    pub fn take_address_n(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.address_n, ::std::vec::Vec::new())
    }

    // optional bytes branch = 2;


    pub fn get_branch(&self) -> &[u8] {
        match self.branch.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_branch(&mut self) {
        self.branch.clear();
    }

    pub fn has_branch(&self) -> bool {
        self.branch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch(&mut self, v: ::std::vec::Vec<u8>) {
        self.branch = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_branch(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.branch.is_none() {
            self.branch.set_default();
        }
        self.branch.as_mut().unwrap()
    }

    // Take field
    pub fn take_branch(&mut self) -> ::std::vec::Vec<u8> {
        self.branch.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosRevealOp reveal = 3;


    pub fn get_reveal(&self) -> &TezosSignTx_TezosRevealOp {
        self.reveal.as_ref().unwrap_or_else(|| TezosSignTx_TezosRevealOp::default_instance())
    }
    pub fn clear_reveal(&mut self) {
        self.reveal.clear();
    }

    pub fn has_reveal(&self) -> bool {
        self.reveal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reveal(&mut self, v: TezosSignTx_TezosRevealOp) {
        self.reveal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reveal(&mut self) -> &mut TezosSignTx_TezosRevealOp {
        if self.reveal.is_none() {
            self.reveal.set_default();
        }
        self.reveal.as_mut().unwrap()
    }

    // Take field
    pub fn take_reveal(&mut self) -> TezosSignTx_TezosRevealOp {
        self.reveal.take().unwrap_or_else(|| TezosSignTx_TezosRevealOp::new())
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosTransactionOp transaction = 4;


    pub fn get_transaction(&self) -> &TezosSignTx_TezosTransactionOp {
        self.transaction.as_ref().unwrap_or_else(|| TezosSignTx_TezosTransactionOp::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: TezosSignTx_TezosTransactionOp) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut TezosSignTx_TezosTransactionOp {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> TezosSignTx_TezosTransactionOp {
        self.transaction.take().unwrap_or_else(|| TezosSignTx_TezosTransactionOp::new())
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosOriginationOp origination = 5;


    pub fn get_origination(&self) -> &TezosSignTx_TezosOriginationOp {
        self.origination.as_ref().unwrap_or_else(|| TezosSignTx_TezosOriginationOp::default_instance())
    }
    pub fn clear_origination(&mut self) {
        self.origination.clear();
    }

    pub fn has_origination(&self) -> bool {
        self.origination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origination(&mut self, v: TezosSignTx_TezosOriginationOp) {
        self.origination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origination(&mut self) -> &mut TezosSignTx_TezosOriginationOp {
        if self.origination.is_none() {
            self.origination.set_default();
        }
        self.origination.as_mut().unwrap()
    }

    // Take field
    pub fn take_origination(&mut self) -> TezosSignTx_TezosOriginationOp {
        self.origination.take().unwrap_or_else(|| TezosSignTx_TezosOriginationOp::new())
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosDelegationOp delegation = 6;


    pub fn get_delegation(&self) -> &TezosSignTx_TezosDelegationOp {
        self.delegation.as_ref().unwrap_or_else(|| TezosSignTx_TezosDelegationOp::default_instance())
    }
    pub fn clear_delegation(&mut self) {
        self.delegation.clear();
    }

    pub fn has_delegation(&self) -> bool {
        self.delegation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delegation(&mut self, v: TezosSignTx_TezosDelegationOp) {
        self.delegation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegation(&mut self) -> &mut TezosSignTx_TezosDelegationOp {
        if self.delegation.is_none() {
            self.delegation.set_default();
        }
        self.delegation.as_mut().unwrap()
    }

    // Take field
    pub fn take_delegation(&mut self) -> TezosSignTx_TezosDelegationOp {
        self.delegation.take().unwrap_or_else(|| TezosSignTx_TezosDelegationOp::new())
    }
}

impl ::protobuf::Message for TezosSignTx {
    fn is_initialized(&self) -> bool {
        for v in &self.reveal {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.origination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.delegation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.address_n)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.branch)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reveal)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.origination)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.delegation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address_n {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.branch.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.reveal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.origination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.delegation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address_n {
            os.write_uint32(1, *v)?;
        };
        if let Some(ref v) = self.branch.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.reveal.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.origination.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.delegation.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx {
        TezosSignTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "address_n",
                    |m: &TezosSignTx| { &m.address_n },
                    |m: &mut TezosSignTx| { &mut m.address_n },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "branch",
                    |m: &TezosSignTx| { &m.branch },
                    |m: &mut TezosSignTx| { &mut m.branch },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosRevealOp>>(
                    "reveal",
                    |m: &TezosSignTx| { &m.reveal },
                    |m: &mut TezosSignTx| { &mut m.reveal },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosTransactionOp>>(
                    "transaction",
                    |m: &TezosSignTx| { &m.transaction },
                    |m: &mut TezosSignTx| { &mut m.transaction },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosOriginationOp>>(
                    "origination",
                    |m: &TezosSignTx| { &m.origination },
                    |m: &mut TezosSignTx| { &mut m.origination },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosDelegationOp>>(
                    "delegation",
                    |m: &TezosSignTx| { &m.delegation },
                    |m: &mut TezosSignTx| { &mut m.delegation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TezosSignTx>(
                    "TezosSignTx",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TezosSignTx {
        static mut instance: ::protobuf::lazy::Lazy<TezosSignTx> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TezosSignTx,
        };
        unsafe {
            instance.get(TezosSignTx::new)
        }
    }
}

impl ::protobuf::Clear for TezosSignTx {
    fn clear(&mut self) {
        self.address_n.clear();
        self.branch.clear();
        self.reveal.clear();
        self.transaction.clear();
        self.origination.clear();
        self.delegation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx_TezosContractID {
    // message fields
    tag: ::std::option::Option<TezosSignTx_TezosContractID_TezosContractType>,
    hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx_TezosContractID {
    fn default() -> &'a TezosSignTx_TezosContractID {
        <TezosSignTx_TezosContractID as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx_TezosContractID {
    pub fn new() -> TezosSignTx_TezosContractID {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID.TezosContractType tag = 1;


    pub fn get_tag(&self) -> TezosSignTx_TezosContractID_TezosContractType {
        self.tag.unwrap_or(TezosSignTx_TezosContractID_TezosContractType::Implicit)
    }
    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: TezosSignTx_TezosContractID_TezosContractType) {
        self.tag = ::std::option::Option::Some(v);
    }

    // optional bytes hash = 2;


    pub fn get_hash(&self) -> &[u8] {
        match self.hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hash.is_none() {
            self.hash.set_default();
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TezosSignTx_TezosContractID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.tag, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.tag {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tag {
            os.write_enum(1, v.value())?;
        }
        if let Some(ref v) = self.hash.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx_TezosContractID {
        TezosSignTx_TezosContractID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TezosSignTx_TezosContractID_TezosContractType>>(
                    "tag",
                    |m: &TezosSignTx_TezosContractID| { &m.tag },
                    |m: &mut TezosSignTx_TezosContractID| { &mut m.tag },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &TezosSignTx_TezosContractID| { &m.hash },
                    |m: &mut TezosSignTx_TezosContractID| { &mut m.hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TezosSignTx_TezosContractID>(
                    "TezosSignTx_TezosContractID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TezosSignTx_TezosContractID {
        static mut instance: ::protobuf::lazy::Lazy<TezosSignTx_TezosContractID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TezosSignTx_TezosContractID,
        };
        unsafe {
            instance.get(TezosSignTx_TezosContractID::new)
        }
    }
}

impl ::protobuf::Clear for TezosSignTx_TezosContractID {
    fn clear(&mut self) {
        self.tag = ::std::option::Option::None;
        self.hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx_TezosContractID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosContractID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TezosSignTx_TezosContractID_TezosContractType {
    Implicit = 0,
    Originated = 1,
}

impl ::protobuf::ProtobufEnum for TezosSignTx_TezosContractID_TezosContractType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TezosSignTx_TezosContractID_TezosContractType> {
        match value {
            0 => ::std::option::Option::Some(TezosSignTx_TezosContractID_TezosContractType::Implicit),
            1 => ::std::option::Option::Some(TezosSignTx_TezosContractID_TezosContractType::Originated),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TezosSignTx_TezosContractID_TezosContractType] = &[
            TezosSignTx_TezosContractID_TezosContractType::Implicit,
            TezosSignTx_TezosContractID_TezosContractType::Originated,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TezosSignTx_TezosContractID_TezosContractType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TezosSignTx_TezosContractID_TezosContractType {
}

impl ::std::default::Default for TezosSignTx_TezosContractID_TezosContractType {
    fn default() -> Self {
        TezosSignTx_TezosContractID_TezosContractType::Implicit
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosContractID_TezosContractType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx_TezosRevealOp {
    // message fields
    source: ::protobuf::SingularPtrField<TezosSignTx_TezosContractID>,
    fee: ::std::option::Option<u64>,
    counter: ::std::option::Option<u64>,
    gas_limit: ::std::option::Option<u64>,
    storage_limit: ::std::option::Option<u64>,
    public_key: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx_TezosRevealOp {
    fn default() -> &'a TezosSignTx_TezosRevealOp {
        <TezosSignTx_TezosRevealOp as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx_TezosRevealOp {
    pub fn new() -> TezosSignTx_TezosRevealOp {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID source = 1;


    pub fn get_source(&self) -> &TezosSignTx_TezosContractID {
        self.source.as_ref().unwrap_or_else(|| TezosSignTx_TezosContractID::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: TezosSignTx_TezosContractID) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut TezosSignTx_TezosContractID {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> TezosSignTx_TezosContractID {
        self.source.take().unwrap_or_else(|| TezosSignTx_TezosContractID::new())
    }

    // optional uint64 fee = 2;


    pub fn get_fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }
    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }

    // optional uint64 counter = 3;


    pub fn get_counter(&self) -> u64 {
        self.counter.unwrap_or(0)
    }
    pub fn clear_counter(&mut self) {
        self.counter = ::std::option::Option::None;
    }

    pub fn has_counter(&self) -> bool {
        self.counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: u64) {
        self.counter = ::std::option::Option::Some(v);
    }

    // optional uint64 gas_limit = 4;


    pub fn get_gas_limit(&self) -> u64 {
        self.gas_limit.unwrap_or(0)
    }
    pub fn clear_gas_limit(&mut self) {
        self.gas_limit = ::std::option::Option::None;
    }

    pub fn has_gas_limit(&self) -> bool {
        self.gas_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gas_limit(&mut self, v: u64) {
        self.gas_limit = ::std::option::Option::Some(v);
    }

    // optional uint64 storage_limit = 5;


    pub fn get_storage_limit(&self) -> u64 {
        self.storage_limit.unwrap_or(0)
    }
    pub fn clear_storage_limit(&mut self) {
        self.storage_limit = ::std::option::Option::None;
    }

    pub fn has_storage_limit(&self) -> bool {
        self.storage_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage_limit(&mut self, v: u64) {
        self.storage_limit = ::std::option::Option::Some(v);
    }

    // optional bytes public_key = 6;


    pub fn get_public_key(&self) -> &[u8] {
        match self.public_key.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    pub fn has_public_key(&self) -> bool {
        self.public_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.public_key.is_none() {
            self.public_key.set_default();
        }
        self.public_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        self.public_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TezosSignTx_TezosRevealOp {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.counter = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gas_limit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.storage_limit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.counter {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gas_limit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storage_limit {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.public_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.counter {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.gas_limit {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.storage_limit {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.public_key.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx_TezosRevealOp {
        TezosSignTx_TezosRevealOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosContractID>>(
                    "source",
                    |m: &TezosSignTx_TezosRevealOp| { &m.source },
                    |m: &mut TezosSignTx_TezosRevealOp| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fee",
                    |m: &TezosSignTx_TezosRevealOp| { &m.fee },
                    |m: &mut TezosSignTx_TezosRevealOp| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "counter",
                    |m: &TezosSignTx_TezosRevealOp| { &m.counter },
                    |m: &mut TezosSignTx_TezosRevealOp| { &mut m.counter },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "gas_limit",
                    |m: &TezosSignTx_TezosRevealOp| { &m.gas_limit },
                    |m: &mut TezosSignTx_TezosRevealOp| { &mut m.gas_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "storage_limit",
                    |m: &TezosSignTx_TezosRevealOp| { &m.storage_limit },
                    |m: &mut TezosSignTx_TezosRevealOp| { &mut m.storage_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "public_key",
                    |m: &TezosSignTx_TezosRevealOp| { &m.public_key },
                    |m: &mut TezosSignTx_TezosRevealOp| { &mut m.public_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TezosSignTx_TezosRevealOp>(
                    "TezosSignTx_TezosRevealOp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TezosSignTx_TezosRevealOp {
        static mut instance: ::protobuf::lazy::Lazy<TezosSignTx_TezosRevealOp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TezosSignTx_TezosRevealOp,
        };
        unsafe {
            instance.get(TezosSignTx_TezosRevealOp::new)
        }
    }
}

impl ::protobuf::Clear for TezosSignTx_TezosRevealOp {
    fn clear(&mut self) {
        self.source.clear();
        self.fee = ::std::option::Option::None;
        self.counter = ::std::option::Option::None;
        self.gas_limit = ::std::option::Option::None;
        self.storage_limit = ::std::option::Option::None;
        self.public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx_TezosRevealOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosRevealOp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx_TezosTransactionOp {
    // message fields
    source: ::protobuf::SingularPtrField<TezosSignTx_TezosContractID>,
    fee: ::std::option::Option<u64>,
    counter: ::std::option::Option<u64>,
    gas_limit: ::std::option::Option<u64>,
    storage_limit: ::std::option::Option<u64>,
    amount: ::std::option::Option<u64>,
    destination: ::protobuf::SingularPtrField<TezosSignTx_TezosContractID>,
    parameters: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx_TezosTransactionOp {
    fn default() -> &'a TezosSignTx_TezosTransactionOp {
        <TezosSignTx_TezosTransactionOp as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx_TezosTransactionOp {
    pub fn new() -> TezosSignTx_TezosTransactionOp {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID source = 1;


    pub fn get_source(&self) -> &TezosSignTx_TezosContractID {
        self.source.as_ref().unwrap_or_else(|| TezosSignTx_TezosContractID::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: TezosSignTx_TezosContractID) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut TezosSignTx_TezosContractID {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> TezosSignTx_TezosContractID {
        self.source.take().unwrap_or_else(|| TezosSignTx_TezosContractID::new())
    }

    // optional uint64 fee = 2;


    pub fn get_fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }
    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }

    // optional uint64 counter = 3;


    pub fn get_counter(&self) -> u64 {
        self.counter.unwrap_or(0)
    }
    pub fn clear_counter(&mut self) {
        self.counter = ::std::option::Option::None;
    }

    pub fn has_counter(&self) -> bool {
        self.counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: u64) {
        self.counter = ::std::option::Option::Some(v);
    }

    // optional uint64 gas_limit = 4;


    pub fn get_gas_limit(&self) -> u64 {
        self.gas_limit.unwrap_or(0)
    }
    pub fn clear_gas_limit(&mut self) {
        self.gas_limit = ::std::option::Option::None;
    }

    pub fn has_gas_limit(&self) -> bool {
        self.gas_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gas_limit(&mut self, v: u64) {
        self.gas_limit = ::std::option::Option::Some(v);
    }

    // optional uint64 storage_limit = 5;


    pub fn get_storage_limit(&self) -> u64 {
        self.storage_limit.unwrap_or(0)
    }
    pub fn clear_storage_limit(&mut self) {
        self.storage_limit = ::std::option::Option::None;
    }

    pub fn has_storage_limit(&self) -> bool {
        self.storage_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage_limit(&mut self, v: u64) {
        self.storage_limit = ::std::option::Option::Some(v);
    }

    // optional uint64 amount = 6;


    pub fn get_amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }
    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID destination = 7;


    pub fn get_destination(&self) -> &TezosSignTx_TezosContractID {
        self.destination.as_ref().unwrap_or_else(|| TezosSignTx_TezosContractID::default_instance())
    }
    pub fn clear_destination(&mut self) {
        self.destination.clear();
    }

    pub fn has_destination(&self) -> bool {
        self.destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destination(&mut self, v: TezosSignTx_TezosContractID) {
        self.destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destination(&mut self) -> &mut TezosSignTx_TezosContractID {
        if self.destination.is_none() {
            self.destination.set_default();
        }
        self.destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_destination(&mut self) -> TezosSignTx_TezosContractID {
        self.destination.take().unwrap_or_else(|| TezosSignTx_TezosContractID::new())
    }

    // optional bytes parameters = 8;


    pub fn get_parameters(&self) -> &[u8] {
        match self.parameters.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    pub fn has_parameters(&self) -> bool {
        self.parameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::std::vec::Vec<u8>) {
        self.parameters = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameters(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.parameters.is_none() {
            self.parameters.set_default();
        }
        self.parameters.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::std::vec::Vec<u8> {
        self.parameters.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TezosSignTx_TezosTransactionOp {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destination {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.counter = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gas_limit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.storage_limit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.amount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destination)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.parameters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.counter {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gas_limit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storage_limit {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.destination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.parameters.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.counter {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.gas_limit {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.storage_limit {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint64(6, v)?;
        }
        if let Some(ref v) = self.destination.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.parameters.as_ref() {
            os.write_bytes(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx_TezosTransactionOp {
        TezosSignTx_TezosTransactionOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosContractID>>(
                    "source",
                    |m: &TezosSignTx_TezosTransactionOp| { &m.source },
                    |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fee",
                    |m: &TezosSignTx_TezosTransactionOp| { &m.fee },
                    |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "counter",
                    |m: &TezosSignTx_TezosTransactionOp| { &m.counter },
                    |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.counter },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "gas_limit",
                    |m: &TezosSignTx_TezosTransactionOp| { &m.gas_limit },
                    |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.gas_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "storage_limit",
                    |m: &TezosSignTx_TezosTransactionOp| { &m.storage_limit },
                    |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.storage_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "amount",
                    |m: &TezosSignTx_TezosTransactionOp| { &m.amount },
                    |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosContractID>>(
                    "destination",
                    |m: &TezosSignTx_TezosTransactionOp| { &m.destination },
                    |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.destination },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "parameters",
                    |m: &TezosSignTx_TezosTransactionOp| { &m.parameters },
                    |m: &mut TezosSignTx_TezosTransactionOp| { &mut m.parameters },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TezosSignTx_TezosTransactionOp>(
                    "TezosSignTx_TezosTransactionOp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TezosSignTx_TezosTransactionOp {
        static mut instance: ::protobuf::lazy::Lazy<TezosSignTx_TezosTransactionOp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TezosSignTx_TezosTransactionOp,
        };
        unsafe {
            instance.get(TezosSignTx_TezosTransactionOp::new)
        }
    }
}

impl ::protobuf::Clear for TezosSignTx_TezosTransactionOp {
    fn clear(&mut self) {
        self.source.clear();
        self.fee = ::std::option::Option::None;
        self.counter = ::std::option::Option::None;
        self.gas_limit = ::std::option::Option::None;
        self.storage_limit = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.destination.clear();
        self.parameters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx_TezosTransactionOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosTransactionOp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx_TezosOriginationOp {
    // message fields
    source: ::protobuf::SingularPtrField<TezosSignTx_TezosContractID>,
    fee: ::std::option::Option<u64>,
    counter: ::std::option::Option<u64>,
    gas_limit: ::std::option::Option<u64>,
    storage_limit: ::std::option::Option<u64>,
    manager_pubkey: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    balance: ::std::option::Option<u64>,
    spendable: ::std::option::Option<bool>,
    delegatable: ::std::option::Option<bool>,
    delegate: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    script: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx_TezosOriginationOp {
    fn default() -> &'a TezosSignTx_TezosOriginationOp {
        <TezosSignTx_TezosOriginationOp as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx_TezosOriginationOp {
    pub fn new() -> TezosSignTx_TezosOriginationOp {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID source = 1;


    pub fn get_source(&self) -> &TezosSignTx_TezosContractID {
        self.source.as_ref().unwrap_or_else(|| TezosSignTx_TezosContractID::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: TezosSignTx_TezosContractID) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut TezosSignTx_TezosContractID {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> TezosSignTx_TezosContractID {
        self.source.take().unwrap_or_else(|| TezosSignTx_TezosContractID::new())
    }

    // optional uint64 fee = 2;


    pub fn get_fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }
    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }

    // optional uint64 counter = 3;


    pub fn get_counter(&self) -> u64 {
        self.counter.unwrap_or(0)
    }
    pub fn clear_counter(&mut self) {
        self.counter = ::std::option::Option::None;
    }

    pub fn has_counter(&self) -> bool {
        self.counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: u64) {
        self.counter = ::std::option::Option::Some(v);
    }

    // optional uint64 gas_limit = 4;


    pub fn get_gas_limit(&self) -> u64 {
        self.gas_limit.unwrap_or(0)
    }
    pub fn clear_gas_limit(&mut self) {
        self.gas_limit = ::std::option::Option::None;
    }

    pub fn has_gas_limit(&self) -> bool {
        self.gas_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gas_limit(&mut self, v: u64) {
        self.gas_limit = ::std::option::Option::Some(v);
    }

    // optional uint64 storage_limit = 5;


    pub fn get_storage_limit(&self) -> u64 {
        self.storage_limit.unwrap_or(0)
    }
    pub fn clear_storage_limit(&mut self) {
        self.storage_limit = ::std::option::Option::None;
    }

    pub fn has_storage_limit(&self) -> bool {
        self.storage_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage_limit(&mut self, v: u64) {
        self.storage_limit = ::std::option::Option::Some(v);
    }

    // optional bytes manager_pubkey = 6;


    pub fn get_manager_pubkey(&self) -> &[u8] {
        match self.manager_pubkey.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_manager_pubkey(&mut self) {
        self.manager_pubkey.clear();
    }

    pub fn has_manager_pubkey(&self) -> bool {
        self.manager_pubkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manager_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.manager_pubkey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manager_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.manager_pubkey.is_none() {
            self.manager_pubkey.set_default();
        }
        self.manager_pubkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_manager_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        self.manager_pubkey.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 balance = 7;


    pub fn get_balance(&self) -> u64 {
        self.balance.unwrap_or(0)
    }
    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: u64) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional bool spendable = 8;


    pub fn get_spendable(&self) -> bool {
        self.spendable.unwrap_or(false)
    }
    pub fn clear_spendable(&mut self) {
        self.spendable = ::std::option::Option::None;
    }

    pub fn has_spendable(&self) -> bool {
        self.spendable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spendable(&mut self, v: bool) {
        self.spendable = ::std::option::Option::Some(v);
    }

    // optional bool delegatable = 9;


    pub fn get_delegatable(&self) -> bool {
        self.delegatable.unwrap_or(false)
    }
    pub fn clear_delegatable(&mut self) {
        self.delegatable = ::std::option::Option::None;
    }

    pub fn has_delegatable(&self) -> bool {
        self.delegatable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delegatable(&mut self, v: bool) {
        self.delegatable = ::std::option::Option::Some(v);
    }

    // optional bytes delegate = 10;


    pub fn get_delegate(&self) -> &[u8] {
        match self.delegate.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_delegate(&mut self) {
        self.delegate.clear();
    }

    pub fn has_delegate(&self) -> bool {
        self.delegate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delegate(&mut self, v: ::std::vec::Vec<u8>) {
        self.delegate = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegate(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.delegate.is_none() {
            self.delegate.set_default();
        }
        self.delegate.as_mut().unwrap()
    }

    // Take field
    pub fn take_delegate(&mut self) -> ::std::vec::Vec<u8> {
        self.delegate.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes script = 11;


    pub fn get_script(&self) -> &[u8] {
        match self.script.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_script(&mut self) {
        self.script.clear();
    }

    pub fn has_script(&self) -> bool {
        self.script.is_some()
    }

    // Param is passed by value, moved
    pub fn set_script(&mut self, v: ::std::vec::Vec<u8>) {
        self.script = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_script(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.script.is_none() {
            self.script.set_default();
        }
        self.script.as_mut().unwrap()
    }

    // Take field
    pub fn take_script(&mut self) -> ::std::vec::Vec<u8> {
        self.script.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TezosSignTx_TezosOriginationOp {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.counter = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gas_limit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.storage_limit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.manager_pubkey)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.balance = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.spendable = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.delegatable = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.delegate)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.script)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.counter {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gas_limit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storage_limit {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.manager_pubkey.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.balance {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.spendable {
            my_size += 2;
        }
        if let Some(v) = self.delegatable {
            my_size += 2;
        }
        if let Some(ref v) = self.delegate.as_ref() {
            my_size += ::protobuf::rt::bytes_size(10, &v);
        }
        if let Some(ref v) = self.script.as_ref() {
            my_size += ::protobuf::rt::bytes_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.counter {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.gas_limit {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.storage_limit {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.manager_pubkey.as_ref() {
            os.write_bytes(6, &v)?;
        }
        if let Some(v) = self.balance {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.spendable {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.delegatable {
            os.write_bool(9, v)?;
        }
        if let Some(ref v) = self.delegate.as_ref() {
            os.write_bytes(10, &v)?;
        }
        if let Some(ref v) = self.script.as_ref() {
            os.write_bytes(11, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx_TezosOriginationOp {
        TezosSignTx_TezosOriginationOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosContractID>>(
                    "source",
                    |m: &TezosSignTx_TezosOriginationOp| { &m.source },
                    |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fee",
                    |m: &TezosSignTx_TezosOriginationOp| { &m.fee },
                    |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "counter",
                    |m: &TezosSignTx_TezosOriginationOp| { &m.counter },
                    |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.counter },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "gas_limit",
                    |m: &TezosSignTx_TezosOriginationOp| { &m.gas_limit },
                    |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.gas_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "storage_limit",
                    |m: &TezosSignTx_TezosOriginationOp| { &m.storage_limit },
                    |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.storage_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "manager_pubkey",
                    |m: &TezosSignTx_TezosOriginationOp| { &m.manager_pubkey },
                    |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.manager_pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "balance",
                    |m: &TezosSignTx_TezosOriginationOp| { &m.balance },
                    |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "spendable",
                    |m: &TezosSignTx_TezosOriginationOp| { &m.spendable },
                    |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.spendable },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "delegatable",
                    |m: &TezosSignTx_TezosOriginationOp| { &m.delegatable },
                    |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.delegatable },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "delegate",
                    |m: &TezosSignTx_TezosOriginationOp| { &m.delegate },
                    |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.delegate },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "script",
                    |m: &TezosSignTx_TezosOriginationOp| { &m.script },
                    |m: &mut TezosSignTx_TezosOriginationOp| { &mut m.script },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TezosSignTx_TezosOriginationOp>(
                    "TezosSignTx_TezosOriginationOp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TezosSignTx_TezosOriginationOp {
        static mut instance: ::protobuf::lazy::Lazy<TezosSignTx_TezosOriginationOp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TezosSignTx_TezosOriginationOp,
        };
        unsafe {
            instance.get(TezosSignTx_TezosOriginationOp::new)
        }
    }
}

impl ::protobuf::Clear for TezosSignTx_TezosOriginationOp {
    fn clear(&mut self) {
        self.source.clear();
        self.fee = ::std::option::Option::None;
        self.counter = ::std::option::Option::None;
        self.gas_limit = ::std::option::Option::None;
        self.storage_limit = ::std::option::Option::None;
        self.manager_pubkey.clear();
        self.balance = ::std::option::Option::None;
        self.spendable = ::std::option::Option::None;
        self.delegatable = ::std::option::Option::None;
        self.delegate.clear();
        self.script.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx_TezosOriginationOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosOriginationOp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignTx_TezosDelegationOp {
    // message fields
    source: ::protobuf::SingularPtrField<TezosSignTx_TezosContractID>,
    fee: ::std::option::Option<u64>,
    counter: ::std::option::Option<u64>,
    gas_limit: ::std::option::Option<u64>,
    storage_limit: ::std::option::Option<u64>,
    delegate: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignTx_TezosDelegationOp {
    fn default() -> &'a TezosSignTx_TezosDelegationOp {
        <TezosSignTx_TezosDelegationOp as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignTx_TezosDelegationOp {
    pub fn new() -> TezosSignTx_TezosDelegationOp {
        ::std::default::Default::default()
    }

    // optional .hw.trezor.messages.tezos.TezosSignTx.TezosContractID source = 1;


    pub fn get_source(&self) -> &TezosSignTx_TezosContractID {
        self.source.as_ref().unwrap_or_else(|| TezosSignTx_TezosContractID::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: TezosSignTx_TezosContractID) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut TezosSignTx_TezosContractID {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> TezosSignTx_TezosContractID {
        self.source.take().unwrap_or_else(|| TezosSignTx_TezosContractID::new())
    }

    // optional uint64 fee = 2;


    pub fn get_fee(&self) -> u64 {
        self.fee.unwrap_or(0)
    }
    pub fn clear_fee(&mut self) {
        self.fee = ::std::option::Option::None;
    }

    pub fn has_fee(&self) -> bool {
        self.fee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: u64) {
        self.fee = ::std::option::Option::Some(v);
    }

    // optional uint64 counter = 3;


    pub fn get_counter(&self) -> u64 {
        self.counter.unwrap_or(0)
    }
    pub fn clear_counter(&mut self) {
        self.counter = ::std::option::Option::None;
    }

    pub fn has_counter(&self) -> bool {
        self.counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_counter(&mut self, v: u64) {
        self.counter = ::std::option::Option::Some(v);
    }

    // optional uint64 gas_limit = 4;


    pub fn get_gas_limit(&self) -> u64 {
        self.gas_limit.unwrap_or(0)
    }
    pub fn clear_gas_limit(&mut self) {
        self.gas_limit = ::std::option::Option::None;
    }

    pub fn has_gas_limit(&self) -> bool {
        self.gas_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gas_limit(&mut self, v: u64) {
        self.gas_limit = ::std::option::Option::Some(v);
    }

    // optional uint64 storage_limit = 5;


    pub fn get_storage_limit(&self) -> u64 {
        self.storage_limit.unwrap_or(0)
    }
    pub fn clear_storage_limit(&mut self) {
        self.storage_limit = ::std::option::Option::None;
    }

    pub fn has_storage_limit(&self) -> bool {
        self.storage_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storage_limit(&mut self, v: u64) {
        self.storage_limit = ::std::option::Option::Some(v);
    }

    // optional bytes delegate = 6;


    pub fn get_delegate(&self) -> &[u8] {
        match self.delegate.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_delegate(&mut self) {
        self.delegate.clear();
    }

    pub fn has_delegate(&self) -> bool {
        self.delegate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delegate(&mut self, v: ::std::vec::Vec<u8>) {
        self.delegate = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delegate(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.delegate.is_none() {
            self.delegate.set_default();
        }
        self.delegate.as_mut().unwrap()
    }

    // Take field
    pub fn take_delegate(&mut self) -> ::std::vec::Vec<u8> {
        self.delegate.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TezosSignTx_TezosDelegationOp {
    fn is_initialized(&self) -> bool {
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.fee = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.counter = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gas_limit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.storage_limit = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.delegate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fee {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.counter {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.gas_limit {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.storage_limit {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.delegate.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fee {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.counter {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.gas_limit {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.storage_limit {
            os.write_uint64(5, v)?;
        }
        if let Some(ref v) = self.delegate.as_ref() {
            os.write_bytes(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignTx_TezosDelegationOp {
        TezosSignTx_TezosDelegationOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TezosSignTx_TezosContractID>>(
                    "source",
                    |m: &TezosSignTx_TezosDelegationOp| { &m.source },
                    |m: &mut TezosSignTx_TezosDelegationOp| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "fee",
                    |m: &TezosSignTx_TezosDelegationOp| { &m.fee },
                    |m: &mut TezosSignTx_TezosDelegationOp| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "counter",
                    |m: &TezosSignTx_TezosDelegationOp| { &m.counter },
                    |m: &mut TezosSignTx_TezosDelegationOp| { &mut m.counter },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "gas_limit",
                    |m: &TezosSignTx_TezosDelegationOp| { &m.gas_limit },
                    |m: &mut TezosSignTx_TezosDelegationOp| { &mut m.gas_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "storage_limit",
                    |m: &TezosSignTx_TezosDelegationOp| { &m.storage_limit },
                    |m: &mut TezosSignTx_TezosDelegationOp| { &mut m.storage_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "delegate",
                    |m: &TezosSignTx_TezosDelegationOp| { &m.delegate },
                    |m: &mut TezosSignTx_TezosDelegationOp| { &mut m.delegate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TezosSignTx_TezosDelegationOp>(
                    "TezosSignTx_TezosDelegationOp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TezosSignTx_TezosDelegationOp {
        static mut instance: ::protobuf::lazy::Lazy<TezosSignTx_TezosDelegationOp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TezosSignTx_TezosDelegationOp,
        };
        unsafe {
            instance.get(TezosSignTx_TezosDelegationOp::new)
        }
    }
}

impl ::protobuf::Clear for TezosSignTx_TezosDelegationOp {
    fn clear(&mut self) {
        self.source.clear();
        self.fee = ::std::option::Option::None;
        self.counter = ::std::option::Option::None;
        self.gas_limit = ::std::option::Option::None;
        self.storage_limit = ::std::option::Option::None;
        self.delegate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignTx_TezosDelegationOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignTx_TezosDelegationOp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TezosSignedTx {
    // message fields
    signature: ::protobuf::SingularField<::std::string::String>,
    sig_op_contents: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    operation_hash: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TezosSignedTx {
    fn default() -> &'a TezosSignedTx {
        <TezosSignedTx as ::protobuf::Message>::default_instance()
    }
}

impl TezosSignedTx {
    pub fn new() -> TezosSignedTx {
        ::std::default::Default::default()
    }

    // optional string signature = 1;


    pub fn get_signature(&self) -> &str {
        match self.signature.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::string::String) {
        self.signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::string::String {
        if self.signature.is_none() {
            self.signature.set_default();
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::string::String {
        self.signature.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes sig_op_contents = 2;


    pub fn get_sig_op_contents(&self) -> &[u8] {
        match self.sig_op_contents.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sig_op_contents(&mut self) {
        self.sig_op_contents.clear();
    }

    pub fn has_sig_op_contents(&self) -> bool {
        self.sig_op_contents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sig_op_contents(&mut self, v: ::std::vec::Vec<u8>) {
        self.sig_op_contents = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig_op_contents(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sig_op_contents.is_none() {
            self.sig_op_contents.set_default();
        }
        self.sig_op_contents.as_mut().unwrap()
    }

    // Take field
    pub fn take_sig_op_contents(&mut self) -> ::std::vec::Vec<u8> {
        self.sig_op_contents.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string operation_hash = 3;


    pub fn get_operation_hash(&self) -> &str {
        match self.operation_hash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_operation_hash(&mut self) {
        self.operation_hash.clear();
    }

    pub fn has_operation_hash(&self) -> bool {
        self.operation_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation_hash(&mut self, v: ::std::string::String) {
        self.operation_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_hash(&mut self) -> &mut ::std::string::String {
        if self.operation_hash.is_none() {
            self.operation_hash.set_default();
        }
        self.operation_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_operation_hash(&mut self) -> ::std::string::String {
        self.operation_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TezosSignedTx {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.signature)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sig_op_contents)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operation_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.sig_op_contents.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.operation_hash.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signature.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.sig_op_contents.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.operation_hash.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TezosSignedTx {
        TezosSignedTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "signature",
                    |m: &TezosSignedTx| { &m.signature },
                    |m: &mut TezosSignedTx| { &mut m.signature },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "sig_op_contents",
                    |m: &TezosSignedTx| { &m.sig_op_contents },
                    |m: &mut TezosSignedTx| { &mut m.sig_op_contents },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "operation_hash",
                    |m: &TezosSignedTx| { &m.operation_hash },
                    |m: &mut TezosSignedTx| { &mut m.operation_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TezosSignedTx>(
                    "TezosSignedTx",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TezosSignedTx {
        static mut instance: ::protobuf::lazy::Lazy<TezosSignedTx> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TezosSignedTx,
        };
        unsafe {
            instance.get(TezosSignedTx::new)
        }
    }
}

impl ::protobuf::Clear for TezosSignedTx {
    fn clear(&mut self) {
        self.signature.clear();
        self.sig_op_contents.clear();
        self.operation_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TezosSignedTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TezosSignedTx {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x14messages-tezos.proto\x12\x18hw.trezor.messages.tezos\"Q\n\x0fTezos\
    GetAddress\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12!\n\
    \x0cshow_display\x18\x02\x20\x01(\x08R\x0bshowDisplay\"(\n\x0cTezosAddre\
    ss\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07address\"S\n\x11TezosGetP\
    ublicKey\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12!\n\x0c\
    show_display\x18\x02\x20\x01(\x08R\x0bshowDisplay\"/\n\x0eTezosPublicKey\
    \x12\x1d\n\npublic_key\x18\x01\x20\x01(\tR\tpublicKey\"\xa1\x0e\n\x0bTez\
    osSignTx\x12\x1b\n\taddress_n\x18\x01\x20\x03(\rR\x08addressN\x12\x16\n\
    \x06branch\x18\x02\x20\x01(\x0cR\x06branch\x12K\n\x06reveal\x18\x03\x20\
    \x01(\x0b23.hw.trezor.messages.tezos.TezosSignTx.TezosRevealOpR\x06revea\
    l\x12Z\n\x0btransaction\x18\x04\x20\x01(\x0b28.hw.trezor.messages.tezos.\
    TezosSignTx.TezosTransactionOpR\x0btransaction\x12Z\n\x0borigination\x18\
    \x05\x20\x01(\x0b28.hw.trezor.messages.tezos.TezosSignTx.TezosOriginatio\
    nOpR\x0borigination\x12W\n\ndelegation\x18\x06\x20\x01(\x0b27.hw.trezor.\
    messages.tezos.TezosSignTx.TezosDelegationOpR\ndelegation\x1a\xb3\x01\n\
    \x0fTezosContractID\x12Y\n\x03tag\x18\x01\x20\x01(\x0e2G.hw.trezor.messa\
    ges.tezos.TezosSignTx.TezosContractID.TezosContractTypeR\x03tag\x12\x12\
    \n\x04hash\x18\x02\x20\x01(\x0cR\x04hash\"1\n\x11TezosContractType\x12\
    \x0c\n\x08Implicit\x10\0\x12\x0e\n\nOriginated\x10\x01\x1a\xeb\x01\n\rTe\
    zosRevealOp\x12M\n\x06source\x18\x01\x20\x01(\x0b25.hw.trezor.messages.t\
    ezos.TezosSignTx.TezosContractIDR\x06source\x12\x10\n\x03fee\x18\x02\x20\
    \x01(\x04R\x03fee\x12\x18\n\x07counter\x18\x03\x20\x01(\x04R\x07counter\
    \x12\x1b\n\tgas_limit\x18\x04\x20\x01(\x04R\x08gasLimit\x12#\n\rstorage_\
    limit\x18\x05\x20\x01(\x04R\x0cstorageLimit\x12\x1d\n\npublic_key\x18\
    \x06\x20\x01(\x0cR\tpublicKey\x1a\xe2\x02\n\x12TezosTransactionOp\x12M\n\
    \x06source\x18\x01\x20\x01(\x0b25.hw.trezor.messages.tezos.TezosSignTx.T\
    ezosContractIDR\x06source\x12\x10\n\x03fee\x18\x02\x20\x01(\x04R\x03fee\
    \x12\x18\n\x07counter\x18\x03\x20\x01(\x04R\x07counter\x12\x1b\n\tgas_li\
    mit\x18\x04\x20\x01(\x04R\x08gasLimit\x12#\n\rstorage_limit\x18\x05\x20\
    \x01(\x04R\x0cstorageLimit\x12\x16\n\x06amount\x18\x06\x20\x01(\x04R\x06\
    amount\x12W\n\x0bdestination\x18\x07\x20\x01(\x0b25.hw.trezor.messages.t\
    ezos.TezosSignTx.TezosContractIDR\x0bdestination\x12\x1e\n\nparameters\
    \x18\x08\x20\x01(\x0cR\nparameters\x1a\x86\x03\n\x12TezosOriginationOp\
    \x12M\n\x06source\x18\x01\x20\x01(\x0b25.hw.trezor.messages.tezos.TezosS\
    ignTx.TezosContractIDR\x06source\x12\x10\n\x03fee\x18\x02\x20\x01(\x04R\
    \x03fee\x12\x18\n\x07counter\x18\x03\x20\x01(\x04R\x07counter\x12\x1b\n\
    \tgas_limit\x18\x04\x20\x01(\x04R\x08gasLimit\x12#\n\rstorage_limit\x18\
    \x05\x20\x01(\x04R\x0cstorageLimit\x12%\n\x0emanager_pubkey\x18\x06\x20\
    \x01(\x0cR\rmanagerPubkey\x12\x18\n\x07balance\x18\x07\x20\x01(\x04R\x07\
    balance\x12\x1c\n\tspendable\x18\x08\x20\x01(\x08R\tspendable\x12\x20\n\
    \x0bdelegatable\x18\t\x20\x01(\x08R\x0bdelegatable\x12\x1a\n\x08delegate\
    \x18\n\x20\x01(\x0cR\x08delegate\x12\x16\n\x06script\x18\x0b\x20\x01(\
    \x0cR\x06script\x1a\xec\x01\n\x11TezosDelegationOp\x12M\n\x06source\x18\
    \x01\x20\x01(\x0b25.hw.trezor.messages.tezos.TezosSignTx.TezosContractID\
    R\x06source\x12\x10\n\x03fee\x18\x02\x20\x01(\x04R\x03fee\x12\x18\n\x07c\
    ounter\x18\x03\x20\x01(\x04R\x07counter\x12\x1b\n\tgas_limit\x18\x04\x20\
    \x01(\x04R\x08gasLimit\x12#\n\rstorage_limit\x18\x05\x20\x01(\x04R\x0cst\
    orageLimit\x12\x1a\n\x08delegate\x18\x06\x20\x01(\x0cR\x08delegate\"|\n\
    \rTezosSignedTx\x12\x1c\n\tsignature\x18\x01\x20\x01(\tR\tsignature\x12&\
    \n\x0fsig_op_contents\x18\x02\x20\x01(\x0cR\rsigOpContents\x12%\n\x0eope\
    ration_hash\x18\x03\x20\x01(\tR\roperationHashB9\n#com.satoshilabs.trezo\
    r.lib.protobufB\x12TrezorMessageTezosJ\xab,\n\x07\x12\x05\0\0\x84\x01\
    \x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\x08\x20\
    \n\x08\n\x01\x08\x12\x03\x04\0<\n.\n\x02\x08\x01\x12\x03\x04\0<\x1a#\x20\
    Sugar\x20for\x20easier\x20handling\x20in\x20Java\n\n\x08\n\x01\x08\x12\
    \x03\x05\03\n\t\n\x02\x08\x08\x12\x03\x05\03\n\x80\x01\n\x02\x04\0\x12\
    \x04\r\0\x10\x01\x1at*\n\x20Request:\x20Ask\x20device\x20for\x20Tezos\
    \x20address\x20corresponding\x20to\x20address_n\x20path\n\x20@start\n\
    \x20@next\x20TezosAddress\n\x20@next\x20Failure\n\n\n\n\x03\x04\0\x01\
    \x12\x03\r\x08\x17\n=\n\x04\x04\0\x02\0\x12\x03\x0e\x04\"\"0\x20BIP-32\
    \x20path\x20to\x20derive\x20the\x20key\x20from\x20master\x20node\n\n\x0c\
    \n\x05\x04\0\x02\0\x04\x12\x03\x0e\x04\x0c\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x03\x0e\r\x13\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x0e\x14\x1d\n\x0c\
    \n\x05\x04\0\x02\0\x03\x12\x03\x0e\x20!\nC\n\x04\x04\0\x02\x01\x12\x03\
    \x0f\x04#\"6\x20optionally\x20show\x20on\x20display\x20before\x20sending\
    \x20the\x20result\n\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x0f\x04\x0c\n\
    \x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x0f\r\x11\n\x0c\n\x05\x04\0\x02\x01\
    \x01\x12\x03\x0f\x12\x1e\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x0f!\"\nW\
    \n\x02\x04\x01\x12\x04\x16\0\x18\x01\x1aK*\n\x20Response:\x20Contains\
    \x20Tezos\x20address\x20derived\x20from\x20device\x20private\x20seed\n\
    \x20@end\n\n\n\n\x03\x04\x01\x01\x12\x03\x16\x08\x14\n.\n\x04\x04\x01\
    \x02\0\x12\x03\x17\x04\x20\"!\x20Coin\x20address\x20in\x20Base58\x20enco\
    ding\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x17\x04\x0c\n\x0c\n\x05\x04\
    \x01\x02\0\x05\x12\x03\x17\r\x13\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\
    \x17\x14\x1b\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x17\x1e\x1f\nv\n\x02\
    \x04\x02\x12\x04\x1f\0\"\x01\x1aj*\n\x20Request:\x20Ask\x20device\x20for\
    \x20Tezos\x20public\x20key\x20corresponding\x20to\x20address_n\x20path\n\
    \x20@start\n\x20@next\x20TezosPublicKey\n\n\n\n\x03\x04\x02\x01\x12\x03\
    \x1f\x08\x19\n=\n\x04\x04\x02\x02\0\x12\x03\x20\x04\"\"0\x20BIP-32\x20pa\
    th\x20to\x20derive\x20the\x20key\x20from\x20master\x20node\n\n\x0c\n\x05\
    \x04\x02\x02\0\x04\x12\x03\x20\x04\x0c\n\x0c\n\x05\x04\x02\x02\0\x05\x12\
    \x03\x20\r\x13\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x20\x14\x1d\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x03\x20\x20!\nC\n\x04\x04\x02\x02\x01\x12\x03\
    !\x04#\"6\x20Optionally\x20show\x20on\x20display\x20before\x20sending\
    \x20the\x20result\n\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03!\x04\x0c\n\
    \x0c\n\x05\x04\x02\x02\x01\x05\x12\x03!\r\x11\n\x0c\n\x05\x04\x02\x02\
    \x01\x01\x12\x03!\x12\x1e\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03!!\"\nZ\
    \n\x02\x04\x03\x12\x04(\0*\x01\x1aN*\n\x20Response:\x20Contains\x20Tezos\
    \x20public\x20key\x20derived\x20from\x20device\x20private\x20seed\n\x20@\
    end\n\n\n\n\x03\x04\x03\x01\x12\x03(\x08\x16\n7\n\x04\x04\x03\x02\0\x12\
    \x03)\x04#\"*\x20b58\x20encoded\x20Tezos\x20public\x20key\x20with\x20pre\
    fix\n\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03)\x04\x0c\n\x0c\n\x05\x04\x03\
    \x02\0\x05\x12\x03)\r\x13\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03)\x14\x1e\
    \n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03)!\"\nZ\n\x02\x04\x04\x12\x041\0z\
    \x01\x1aN*\n\x20Request:\x20Ask\x20device\x20to\x20sign\x20Tezos\x20tran\
    saction\n\x20@start\n\x20@next\x20TezosSignedTx\n\n\n\n\x03\x04\x04\x01\
    \x12\x031\x08\x13\n=\n\x04\x04\x04\x02\0\x12\x032\x04\"\"0\x20BIP-32\x20\
    path\x20to\x20derive\x20the\x20key\x20from\x20master\x20node\n\n\x0c\n\
    \x05\x04\x04\x02\0\x04\x12\x032\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x05\
    \x12\x032\r\x13\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x032\x14\x1d\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x032\x20!\n\x0b\n\x04\x04\x04\x02\x01\x12\x03\
    3\x04\x1e\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x033\x04\x0c\n\x0c\n\x05\
    \x04\x04\x02\x01\x05\x12\x033\r\x12\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\
    \x033\x13\x19\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x033\x1c\x1d\nD\n\x04\
    \x04\x04\x02\x02\x12\x035\x04&\"7\x20Tezos\x20reveal\x20operation\x20(ma\
    y\x20be\x20bundled\x20with\x20other\x20op)\n\n\x0c\n\x05\x04\x04\x02\x02\
    \x04\x12\x035\x04\x0c\n\x0c\n\x05\x04\x04\x02\x02\x06\x12\x035\r\x1a\n\
    \x0c\n\x05\x04\x04\x02\x02\x01\x12\x035\x1b!\n\x0c\n\x05\x04\x04\x02\x02\
    \x03\x12\x035$%\n*\n\x04\x04\x04\x02\x03\x12\x036\x040\"\x1d\x20Tezos\
    \x20transaction\x20operation\n\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\x036\
    \x04\x0c\n\x0c\n\x05\x04\x04\x02\x03\x06\x12\x036\r\x1f\n\x0c\n\x05\x04\
    \x04\x02\x03\x01\x12\x036\x20+\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x036.\
    /\n*\n\x04\x04\x04\x02\x04\x12\x037\x040\"\x1d\x20Tezos\x20origination\
    \x20operation\n\n\x0c\n\x05\x04\x04\x02\x04\x04\x12\x037\x04\x0c\n\x0c\n\
    \x05\x04\x04\x02\x04\x06\x12\x037\r\x1f\n\x0c\n\x05\x04\x04\x02\x04\x01\
    \x12\x037\x20+\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x037./\n)\n\x04\x04\
    \x04\x02\x05\x12\x038\x04.\"\x1c\x20Tezos\x20delegation\x20operation\n\n\
    \x0c\n\x05\x04\x04\x02\x05\x04\x12\x038\x04\x0c\n\x0c\n\x05\x04\x04\x02\
    \x05\x06\x12\x038\r\x1e\n\x0c\n\x05\x04\x04\x02\x05\x01\x12\x038\x1f)\n\
    \x0c\n\x05\x04\x04\x02\x05\x03\x12\x038,-\n\"\n\x04\x04\x04\x03\0\x12\
    \x04<\x04F\x05\x1a\x14\n\x20Tezos\x20contract\x20ID\n\n\x0c\n\x05\x04\
    \x04\x03\0\x01\x12\x03<\x0c\x1b\n\r\n\x06\x04\x04\x03\0\x02\0\x12\x03=\
    \x08+\n\x0e\n\x07\x04\x04\x03\0\x02\0\x04\x12\x03=\x08\x10\n\x0e\n\x07\
    \x04\x04\x03\0\x02\0\x06\x12\x03=\x11\"\n\x0e\n\x07\x04\x04\x03\0\x02\0\
    \x01\x12\x03=#&\n\x0e\n\x07\x04\x04\x03\0\x02\0\x03\x12\x03=)*\n>\n\x06\
    \x04\x04\x03\0\x02\x01\x12\x03>\x08\x20\"/\x20Implicit\x20=\x2021B,\x20o\
    riginated\x20=\x2020B\x20+\x201B\x20padding\n\n\x0e\n\x07\x04\x04\x03\0\
    \x02\x01\x04\x12\x03>\x08\x10\n\x0e\n\x07\x04\x04\x03\0\x02\x01\x05\x12\
    \x03>\x11\x16\n\x0e\n\x07\x04\x04\x03\0\x02\x01\x01\x12\x03>\x17\x1b\n\
    \x0e\n\x07\x04\x04\x03\0\x02\x01\x03\x12\x03>\x1e\x1f\n.\n\x06\x04\x04\
    \x03\0\x04\0\x12\x04B\x08E\t\x1a\x1e\n\x20Type\x20of\x20Tezos\x20Contrac\
    t\x20type\n\n\x0e\n\x07\x04\x04\x03\0\x04\0\x01\x12\x03B\r\x1e\n\x0f\n\
    \x08\x04\x04\x03\0\x04\0\x02\0\x12\x03C\x0c\x19\n\x10\n\t\x04\x04\x03\0\
    \x04\0\x02\0\x01\x12\x03C\x0c\x14\n\x10\n\t\x04\x04\x03\0\x04\0\x02\0\
    \x02\x12\x03C\x17\x18\n\x0f\n\x08\x04\x04\x03\0\x04\0\x02\x01\x12\x03D\
    \x0c\x1b\n\x10\n\t\x04\x04\x03\0\x04\0\x02\x01\x01\x12\x03D\x0c\x16\n\
    \x10\n\t\x04\x04\x03\0\x04\0\x02\x01\x02\x12\x03D\x19\x1a\n?\n\x04\x04\
    \x04\x03\x01\x12\x04J\x04Q\x05\x1a1*\n\x20Structure\x20representing\x20i\
    nformation\x20for\x20reveal\n\n\x0c\n\x05\x04\x04\x03\x01\x01\x12\x03J\
    \x0c\x19\n\r\n\x06\x04\x04\x03\x01\x02\0\x12\x03K\x08,\n\x0e\n\x07\x04\
    \x04\x03\x01\x02\0\x04\x12\x03K\x08\x10\n\x0e\n\x07\x04\x04\x03\x01\x02\
    \0\x06\x12\x03K\x11\x20\n\x0e\n\x07\x04\x04\x03\x01\x02\0\x01\x12\x03K!'\
    \n\x0e\n\x07\x04\x04\x03\x01\x02\0\x03\x12\x03K*+\n\r\n\x06\x04\x04\x03\
    \x01\x02\x01\x12\x03L\x08\x20\n\x0e\n\x07\x04\x04\x03\x01\x02\x01\x04\
    \x12\x03L\x08\x10\n\x0e\n\x07\x04\x04\x03\x01\x02\x01\x05\x12\x03L\x11\
    \x17\n\x0e\n\x07\x04\x04\x03\x01\x02\x01\x01\x12\x03L\x18\x1b\n\x0e\n\
    \x07\x04\x04\x03\x01\x02\x01\x03\x12\x03L\x1e\x1f\n\r\n\x06\x04\x04\x03\
    \x01\x02\x02\x12\x03M\x08$\n\x0e\n\x07\x04\x04\x03\x01\x02\x02\x04\x12\
    \x03M\x08\x10\n\x0e\n\x07\x04\x04\x03\x01\x02\x02\x05\x12\x03M\x11\x17\n\
    \x0e\n\x07\x04\x04\x03\x01\x02\x02\x01\x12\x03M\x18\x1f\n\x0e\n\x07\x04\
    \x04\x03\x01\x02\x02\x03\x12\x03M\"#\n\r\n\x06\x04\x04\x03\x01\x02\x03\
    \x12\x03N\x08&\n\x0e\n\x07\x04\x04\x03\x01\x02\x03\x04\x12\x03N\x08\x10\
    \n\x0e\n\x07\x04\x04\x03\x01\x02\x03\x05\x12\x03N\x11\x17\n\x0e\n\x07\
    \x04\x04\x03\x01\x02\x03\x01\x12\x03N\x18!\n\x0e\n\x07\x04\x04\x03\x01\
    \x02\x03\x03\x12\x03N$%\n\r\n\x06\x04\x04\x03\x01\x02\x04\x12\x03O\x08*\
    \n\x0e\n\x07\x04\x04\x03\x01\x02\x04\x04\x12\x03O\x08\x10\n\x0e\n\x07\
    \x04\x04\x03\x01\x02\x04\x05\x12\x03O\x11\x17\n\x0e\n\x07\x04\x04\x03\
    \x01\x02\x04\x01\x12\x03O\x18%\n\x0e\n\x07\x04\x04\x03\x01\x02\x04\x03\
    \x12\x03O()\n\r\n\x06\x04\x04\x03\x01\x02\x05\x12\x03P\x08&\n\x0e\n\x07\
    \x04\x04\x03\x01\x02\x05\x04\x12\x03P\x08\x10\n\x0e\n\x07\x04\x04\x03\
    \x01\x02\x05\x05\x12\x03P\x11\x16\n\x0e\n\x07\x04\x04\x03\x01\x02\x05\
    \x01\x12\x03P\x17!\n\x0e\n\x07\x04\x04\x03\x01\x02\x05\x03\x12\x03P$%\nD\
    \n\x04\x04\x04\x03\x02\x12\x04U\x04^\x05\x1a6*\n\x20Structure\x20represe\
    nting\x20information\x20for\x20transaction\n\n\x0c\n\x05\x04\x04\x03\x02\
    \x01\x12\x03U\x0c\x1e\n\r\n\x06\x04\x04\x03\x02\x02\0\x12\x03V\x08,\n\
    \x0e\n\x07\x04\x04\x03\x02\x02\0\x04\x12\x03V\x08\x10\n\x0e\n\x07\x04\
    \x04\x03\x02\x02\0\x06\x12\x03V\x11\x20\n\x0e\n\x07\x04\x04\x03\x02\x02\
    \0\x01\x12\x03V!'\n\x0e\n\x07\x04\x04\x03\x02\x02\0\x03\x12\x03V*+\n\r\n\
    \x06\x04\x04\x03\x02\x02\x01\x12\x03W\x08\x20\n\x0e\n\x07\x04\x04\x03\
    \x02\x02\x01\x04\x12\x03W\x08\x10\n\x0e\n\x07\x04\x04\x03\x02\x02\x01\
    \x05\x12\x03W\x11\x17\n\x0e\n\x07\x04\x04\x03\x02\x02\x01\x01\x12\x03W\
    \x18\x1b\n\x0e\n\x07\x04\x04\x03\x02\x02\x01\x03\x12\x03W\x1e\x1f\n\r\n\
    \x06\x04\x04\x03\x02\x02\x02\x12\x03X\x08$\n\x0e\n\x07\x04\x04\x03\x02\
    \x02\x02\x04\x12\x03X\x08\x10\n\x0e\n\x07\x04\x04\x03\x02\x02\x02\x05\
    \x12\x03X\x11\x17\n\x0e\n\x07\x04\x04\x03\x02\x02\x02\x01\x12\x03X\x18\
    \x1f\n\x0e\n\x07\x04\x04\x03\x02\x02\x02\x03\x12\x03X\"#\n\r\n\x06\x04\
    \x04\x03\x02\x02\x03\x12\x03Y\x08&\n\x0e\n\x07\x04\x04\x03\x02\x02\x03\
    \x04\x12\x03Y\x08\x10\n\x0e\n\x07\x04\x04\x03\x02\x02\x03\x05\x12\x03Y\
    \x11\x17\n\x0e\n\x07\x04\x04\x03\x02\x02\x03\x01\x12\x03Y\x18!\n\x0e\n\
    \x07\x04\x04\x03\x02\x02\x03\x03\x12\x03Y$%\n\r\n\x06\x04\x04\x03\x02\
    \x02\x04\x12\x03Z\x08*\n\x0e\n\x07\x04\x04\x03\x02\x02\x04\x04\x12\x03Z\
    \x08\x10\n\x0e\n\x07\x04\x04\x03\x02\x02\x04\x05\x12\x03Z\x11\x17\n\x0e\
    \n\x07\x04\x04\x03\x02\x02\x04\x01\x12\x03Z\x18%\n\x0e\n\x07\x04\x04\x03\
    \x02\x02\x04\x03\x12\x03Z()\n\r\n\x06\x04\x04\x03\x02\x02\x05\x12\x03[\
    \x08#\n\x0e\n\x07\x04\x04\x03\x02\x02\x05\x04\x12\x03[\x08\x10\n\x0e\n\
    \x07\x04\x04\x03\x02\x02\x05\x05\x12\x03[\x11\x17\n\x0e\n\x07\x04\x04\
    \x03\x02\x02\x05\x01\x12\x03[\x18\x1e\n\x0e\n\x07\x04\x04\x03\x02\x02\
    \x05\x03\x12\x03[!\"\n\r\n\x06\x04\x04\x03\x02\x02\x06\x12\x03\\\x081\n\
    \x0e\n\x07\x04\x04\x03\x02\x02\x06\x04\x12\x03\\\x08\x10\n\x0e\n\x07\x04\
    \x04\x03\x02\x02\x06\x06\x12\x03\\\x11\x20\n\x0e\n\x07\x04\x04\x03\x02\
    \x02\x06\x01\x12\x03\\!,\n\x0e\n\x07\x04\x04\x03\x02\x02\x06\x03\x12\x03\
    \\/0\n\r\n\x06\x04\x04\x03\x02\x02\x07\x12\x03]\x08&\n\x0e\n\x07\x04\x04\
    \x03\x02\x02\x07\x04\x12\x03]\x08\x10\n\x0e\n\x07\x04\x04\x03\x02\x02\
    \x07\x05\x12\x03]\x11\x16\n\x0e\n\x07\x04\x04\x03\x02\x02\x07\x01\x12\
    \x03]\x17!\n\x0e\n\x07\x04\x04\x03\x02\x02\x07\x03\x12\x03]$%\nD\n\x04\
    \x04\x04\x03\x03\x12\x04b\x04n\x05\x1a6*\n\x20Structure\x20representing\
    \x20information\x20for\x20origination\n\n\x0c\n\x05\x04\x04\x03\x03\x01\
    \x12\x03b\x0c\x1e\n\r\n\x06\x04\x04\x03\x03\x02\0\x12\x03c\x08,\n\x0e\n\
    \x07\x04\x04\x03\x03\x02\0\x04\x12\x03c\x08\x10\n\x0e\n\x07\x04\x04\x03\
    \x03\x02\0\x06\x12\x03c\x11\x20\n\x0e\n\x07\x04\x04\x03\x03\x02\0\x01\
    \x12\x03c!'\n\x0e\n\x07\x04\x04\x03\x03\x02\0\x03\x12\x03c*+\n\r\n\x06\
    \x04\x04\x03\x03\x02\x01\x12\x03d\x08\x20\n\x0e\n\x07\x04\x04\x03\x03\
    \x02\x01\x04\x12\x03d\x08\x10\n\x0e\n\x07\x04\x04\x03\x03\x02\x01\x05\
    \x12\x03d\x11\x17\n\x0e\n\x07\x04\x04\x03\x03\x02\x01\x01\x12\x03d\x18\
    \x1b\n\x0e\n\x07\x04\x04\x03\x03\x02\x01\x03\x12\x03d\x1e\x1f\n\r\n\x06\
    \x04\x04\x03\x03\x02\x02\x12\x03e\x08$\n\x0e\n\x07\x04\x04\x03\x03\x02\
    \x02\x04\x12\x03e\x08\x10\n\x0e\n\x07\x04\x04\x03\x03\x02\x02\x05\x12\
    \x03e\x11\x17\n\x0e\n\x07\x04\x04\x03\x03\x02\x02\x01\x12\x03e\x18\x1f\n\
    \x0e\n\x07\x04\x04\x03\x03\x02\x02\x03\x12\x03e\"#\n\r\n\x06\x04\x04\x03\
    \x03\x02\x03\x12\x03f\x08&\n\x0e\n\x07\x04\x04\x03\x03\x02\x03\x04\x12\
    \x03f\x08\x10\n\x0e\n\x07\x04\x04\x03\x03\x02\x03\x05\x12\x03f\x11\x17\n\
    \x0e\n\x07\x04\x04\x03\x03\x02\x03\x01\x12\x03f\x18!\n\x0e\n\x07\x04\x04\
    \x03\x03\x02\x03\x03\x12\x03f$%\n\r\n\x06\x04\x04\x03\x03\x02\x04\x12\
    \x03g\x08*\n\x0e\n\x07\x04\x04\x03\x03\x02\x04\x04\x12\x03g\x08\x10\n\
    \x0e\n\x07\x04\x04\x03\x03\x02\x04\x05\x12\x03g\x11\x17\n\x0e\n\x07\x04\
    \x04\x03\x03\x02\x04\x01\x12\x03g\x18%\n\x0e\n\x07\x04\x04\x03\x03\x02\
    \x04\x03\x12\x03g()\n\r\n\x06\x04\x04\x03\x03\x02\x05\x12\x03h\x08*\n\
    \x0e\n\x07\x04\x04\x03\x03\x02\x05\x04\x12\x03h\x08\x10\n\x0e\n\x07\x04\
    \x04\x03\x03\x02\x05\x05\x12\x03h\x11\x16\n\x0e\n\x07\x04\x04\x03\x03\
    \x02\x05\x01\x12\x03h\x17%\n\x0e\n\x07\x04\x04\x03\x03\x02\x05\x03\x12\
    \x03h()\n\r\n\x06\x04\x04\x03\x03\x02\x06\x12\x03i\x08$\n\x0e\n\x07\x04\
    \x04\x03\x03\x02\x06\x04\x12\x03i\x08\x10\n\x0e\n\x07\x04\x04\x03\x03\
    \x02\x06\x05\x12\x03i\x11\x17\n\x0e\n\x07\x04\x04\x03\x03\x02\x06\x01\
    \x12\x03i\x18\x1f\n\x0e\n\x07\x04\x04\x03\x03\x02\x06\x03\x12\x03i\"#\n\
    \r\n\x06\x04\x04\x03\x03\x02\x07\x12\x03j\x08$\n\x0e\n\x07\x04\x04\x03\
    \x03\x02\x07\x04\x12\x03j\x08\x10\n\x0e\n\x07\x04\x04\x03\x03\x02\x07\
    \x05\x12\x03j\x11\x15\n\x0e\n\x07\x04\x04\x03\x03\x02\x07\x01\x12\x03j\
    \x16\x1f\n\x0e\n\x07\x04\x04\x03\x03\x02\x07\x03\x12\x03j\"#\n\r\n\x06\
    \x04\x04\x03\x03\x02\x08\x12\x03k\x08&\n\x0e\n\x07\x04\x04\x03\x03\x02\
    \x08\x04\x12\x03k\x08\x10\n\x0e\n\x07\x04\x04\x03\x03\x02\x08\x05\x12\
    \x03k\x11\x15\n\x0e\n\x07\x04\x04\x03\x03\x02\x08\x01\x12\x03k\x16!\n\
    \x0e\n\x07\x04\x04\x03\x03\x02\x08\x03\x12\x03k$%\n\r\n\x06\x04\x04\x03\
    \x03\x02\t\x12\x03l\x08%\n\x0e\n\x07\x04\x04\x03\x03\x02\t\x04\x12\x03l\
    \x08\x10\n\x0e\n\x07\x04\x04\x03\x03\x02\t\x05\x12\x03l\x11\x16\n\x0e\n\
    \x07\x04\x04\x03\x03\x02\t\x01\x12\x03l\x17\x1f\n\x0e\n\x07\x04\x04\x03\
    \x03\x02\t\x03\x12\x03l\"$\n\r\n\x06\x04\x04\x03\x03\x02\n\x12\x03m\x08#\
    \n\x0e\n\x07\x04\x04\x03\x03\x02\n\x04\x12\x03m\x08\x10\n\x0e\n\x07\x04\
    \x04\x03\x03\x02\n\x05\x12\x03m\x11\x16\n\x0e\n\x07\x04\x04\x03\x03\x02\
    \n\x01\x12\x03m\x17\x1d\n\x0e\n\x07\x04\x04\x03\x03\x02\n\x03\x12\x03m\
    \x20\"\nC\n\x04\x04\x04\x03\x04\x12\x04r\x04y\x05\x1a5*\n\x20Structure\
    \x20representing\x20information\x20for\x20delegation\n\n\x0c\n\x05\x04\
    \x04\x03\x04\x01\x12\x03r\x0c\x1d\n\r\n\x06\x04\x04\x03\x04\x02\0\x12\
    \x03s\x08,\n\x0e\n\x07\x04\x04\x03\x04\x02\0\x04\x12\x03s\x08\x10\n\x0e\
    \n\x07\x04\x04\x03\x04\x02\0\x06\x12\x03s\x11\x20\n\x0e\n\x07\x04\x04\
    \x03\x04\x02\0\x01\x12\x03s!'\n\x0e\n\x07\x04\x04\x03\x04\x02\0\x03\x12\
    \x03s*+\n\r\n\x06\x04\x04\x03\x04\x02\x01\x12\x03t\x08\x20\n\x0e\n\x07\
    \x04\x04\x03\x04\x02\x01\x04\x12\x03t\x08\x10\n\x0e\n\x07\x04\x04\x03\
    \x04\x02\x01\x05\x12\x03t\x11\x17\n\x0e\n\x07\x04\x04\x03\x04\x02\x01\
    \x01\x12\x03t\x18\x1b\n\x0e\n\x07\x04\x04\x03\x04\x02\x01\x03\x12\x03t\
    \x1e\x1f\n\r\n\x06\x04\x04\x03\x04\x02\x02\x12\x03u\x08$\n\x0e\n\x07\x04\
    \x04\x03\x04\x02\x02\x04\x12\x03u\x08\x10\n\x0e\n\x07\x04\x04\x03\x04\
    \x02\x02\x05\x12\x03u\x11\x17\n\x0e\n\x07\x04\x04\x03\x04\x02\x02\x01\
    \x12\x03u\x18\x1f\n\x0e\n\x07\x04\x04\x03\x04\x02\x02\x03\x12\x03u\"#\n\
    \r\n\x06\x04\x04\x03\x04\x02\x03\x12\x03v\x08&\n\x0e\n\x07\x04\x04\x03\
    \x04\x02\x03\x04\x12\x03v\x08\x10\n\x0e\n\x07\x04\x04\x03\x04\x02\x03\
    \x05\x12\x03v\x11\x17\n\x0e\n\x07\x04\x04\x03\x04\x02\x03\x01\x12\x03v\
    \x18!\n\x0e\n\x07\x04\x04\x03\x04\x02\x03\x03\x12\x03v$%\n\r\n\x06\x04\
    \x04\x03\x04\x02\x04\x12\x03w\x08*\n\x0e\n\x07\x04\x04\x03\x04\x02\x04\
    \x04\x12\x03w\x08\x10\n\x0e\n\x07\x04\x04\x03\x04\x02\x04\x05\x12\x03w\
    \x11\x17\n\x0e\n\x07\x04\x04\x03\x04\x02\x04\x01\x12\x03w\x18%\n\x0e\n\
    \x07\x04\x04\x03\x04\x02\x04\x03\x12\x03w()\n\r\n\x06\x04\x04\x03\x04\
    \x02\x05\x12\x03x\x08$\n\x0e\n\x07\x04\x04\x03\x04\x02\x05\x04\x12\x03x\
    \x08\x10\n\x0e\n\x07\x04\x04\x03\x04\x02\x05\x05\x12\x03x\x11\x16\n\x0e\
    \n\x07\x04\x04\x03\x04\x02\x05\x01\x12\x03x\x17\x1f\n\x0e\n\x07\x04\x04\
    \x03\x04\x02\x05\x03\x12\x03x\"#\nF\n\x02\x04\x05\x12\x06\x80\x01\0\x84\
    \x01\x01\x1a8*\n\x20Response:\x20Contains\x20Tezos\x20transaction\x20sig\
    nature\n\x20@end\n\n\x0b\n\x03\x04\x05\x01\x12\x04\x80\x01\x08\x15\nC\n\
    \x04\x04\x05\x02\0\x12\x04\x81\x01\x04\"\"5\x20Tezos\x20b58\x20encoded\
    \x20transaction\x20signature\x20with\x20prefix\n\n\r\n\x05\x04\x05\x02\0\
    \x04\x12\x04\x81\x01\x04\x0c\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\x81\x01\
    \r\x13\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x81\x01\x14\x1d\n\r\n\x05\x04\
    \x05\x02\0\x03\x12\x04\x81\x01\x20!\n8\n\x04\x04\x05\x02\x01\x12\x04\x82\
    \x01\x04'\"*\x20operation_bytes\x20+\x20signed\x20operation_bytes\n\n\r\
    \n\x05\x04\x05\x02\x01\x04\x12\x04\x82\x01\x04\x0c\n\r\n\x05\x04\x05\x02\
    \x01\x05\x12\x04\x82\x01\r\x12\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\x82\
    \x01\x13\"\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\x82\x01%&\nA\n\x04\x04\
    \x05\x02\x02\x12\x04\x83\x01\x04'\"3\x20b58\x20encoded\x20hashed\x20oper\
    ation\x20contents\x20with\x20prefix\n\n\r\n\x05\x04\x05\x02\x02\x04\x12\
    \x04\x83\x01\x04\x0c\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\x83\x01\r\x13\
    \n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\x83\x01\x14\"\n\r\n\x05\x04\x05\
    \x02\x02\x03\x12\x04\x83\x01%&\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
